
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model advantages
 * 
 */
export type advantages = $Result.DefaultSelection<Prisma.$advantagesPayload>
/**
 * Model alchemy_powers
 * 
 */
export type alchemy_powers = $Result.DefaultSelection<Prisma.$alchemy_powersPayload>
/**
 * Model attributes
 * 
 */
export type attributes = $Result.DefaultSelection<Prisma.$attributesPayload>
/**
 * Model blood_potency
 * 
 */
export type blood_potency = $Result.DefaultSelection<Prisma.$blood_potencyPayload>
/**
 * Model char_groups
 * 
 */
export type char_groups = $Result.DefaultSelection<Prisma.$char_groupsPayload>
/**
 * Model character_advantages
 * 
 */
export type character_advantages = $Result.DefaultSelection<Prisma.$character_advantagesPayload>
/**
 * Model character_alchemy_powers
 * 
 */
export type character_alchemy_powers = $Result.DefaultSelection<Prisma.$character_alchemy_powersPayload>
/**
 * Model character_attributes
 * 
 */
export type character_attributes = $Result.DefaultSelection<Prisma.$character_attributesPayload>
/**
 * Model character_bloodpotencies
 * 
 */
export type character_bloodpotencies = $Result.DefaultSelection<Prisma.$character_bloodpotenciesPayload>
/**
 * Model character_discipline_powers
 * 
 */
export type character_discipline_powers = $Result.DefaultSelection<Prisma.$character_discipline_powersPayload>
/**
 * Model character_disciplines
 * 
 */
export type character_disciplines = $Result.DefaultSelection<Prisma.$character_disciplinesPayload>
/**
 * Model character_healths
 * 
 */
export type character_healths = $Result.DefaultSelection<Prisma.$character_healthsPayload>
/**
 * Model character_humanity
 * 
 */
export type character_humanity = $Result.DefaultSelection<Prisma.$character_humanityPayload>
/**
 * Model character_profile
 * 
 */
export type character_profile = $Result.DefaultSelection<Prisma.$character_profilePayload>
/**
 * Model character_rituals
 * 
 */
export type character_rituals = $Result.DefaultSelection<Prisma.$character_ritualsPayload>
/**
 * Model character_skills
 * 
 */
export type character_skills = $Result.DefaultSelection<Prisma.$character_skillsPayload>
/**
 * Model character_specialties
 * 
 */
export type character_specialties = $Result.DefaultSelection<Prisma.$character_specialtiesPayload>
/**
 * Model character_willpowers
 * 
 */
export type character_willpowers = $Result.DefaultSelection<Prisma.$character_willpowersPayload>
/**
 * Model characters
 * 
 */
export type characters = $Result.DefaultSelection<Prisma.$charactersPayload>
/**
 * Model chronicles
 * 
 */
export type chronicles = $Result.DefaultSelection<Prisma.$chroniclesPayload>
/**
 * Model clan_banes
 * 
 */
export type clan_banes = $Result.DefaultSelection<Prisma.$clan_banesPayload>
/**
 * Model clan_compulsions
 * 
 */
export type clan_compulsions = $Result.DefaultSelection<Prisma.$clan_compulsionsPayload>
/**
 * Model clans
 * 
 */
export type clans = $Result.DefaultSelection<Prisma.$clansPayload>
/**
 * Model discipline_powers
 * 
 */
export type discipline_powers = $Result.DefaultSelection<Prisma.$discipline_powersPayload>
/**
 * Model disciplines
 * 
 */
export type disciplines = $Result.DefaultSelection<Prisma.$disciplinesPayload>
/**
 * Model exp_logs
 * 
 */
export type exp_logs = $Result.DefaultSelection<Prisma.$exp_logsPayload>
/**
 * Model humanity
 * 
 */
export type humanity = $Result.DefaultSelection<Prisma.$humanityPayload>
/**
 * Model predator_types
 * 
 */
export type predator_types = $Result.DefaultSelection<Prisma.$predator_typesPayload>
/**
 * Model rituals
 * 
 */
export type rituals = $Result.DefaultSelection<Prisma.$ritualsPayload>
/**
 * Model sects
 * 
 */
export type sects = $Result.DefaultSelection<Prisma.$sectsPayload>
/**
 * Model skills
 * 
 */
export type skills = $Result.DefaultSelection<Prisma.$skillsPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Entity: {
  Vampire: 'Vampire',
  Ghoul: 'Ghoul',
  Mortal: 'Mortal',
  Hunter: 'Hunter'
};

export type Entity = (typeof Entity)[keyof typeof Entity]


export const category: {
  Physical: 'Physical',
  Social: 'Social',
  Mental: 'Mental'
};

export type category = (typeof category)[keyof typeof category]


export const forWhom: {
  Ghoul: 'Ghoul',
  Vampire: 'Vampire',
  All: 'All'
};

export type forWhom = (typeof forWhom)[keyof typeof forWhom]


export const type: {
  Merit: 'Merit',
  Flaw: 'Flaw',
  Loresheet: 'Loresheet',
  Background: 'Background'
};

export type type = (typeof type)[keyof typeof type]

}

export type Entity = $Enums.Entity

export const Entity: typeof $Enums.Entity

export type category = $Enums.category

export const category: typeof $Enums.category

export type forWhom = $Enums.forWhom

export const forWhom: typeof $Enums.forWhom

export type type = $Enums.type

export const type: typeof $Enums.type

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Advantages
 * const advantages = await prisma.advantages.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Advantages
   * const advantages = await prisma.advantages.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.advantages`: Exposes CRUD operations for the **advantages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Advantages
    * const advantages = await prisma.advantages.findMany()
    * ```
    */
  get advantages(): Prisma.advantagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.alchemy_powers`: Exposes CRUD operations for the **alchemy_powers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alchemy_powers
    * const alchemy_powers = await prisma.alchemy_powers.findMany()
    * ```
    */
  get alchemy_powers(): Prisma.alchemy_powersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attributes`: Exposes CRUD operations for the **attributes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attributes
    * const attributes = await prisma.attributes.findMany()
    * ```
    */
  get attributes(): Prisma.attributesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blood_potency`: Exposes CRUD operations for the **blood_potency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blood_potencies
    * const blood_potencies = await prisma.blood_potency.findMany()
    * ```
    */
  get blood_potency(): Prisma.blood_potencyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.char_groups`: Exposes CRUD operations for the **char_groups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Char_groups
    * const char_groups = await prisma.char_groups.findMany()
    * ```
    */
  get char_groups(): Prisma.char_groupsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.character_advantages`: Exposes CRUD operations for the **character_advantages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Character_advantages
    * const character_advantages = await prisma.character_advantages.findMany()
    * ```
    */
  get character_advantages(): Prisma.character_advantagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.character_alchemy_powers`: Exposes CRUD operations for the **character_alchemy_powers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Character_alchemy_powers
    * const character_alchemy_powers = await prisma.character_alchemy_powers.findMany()
    * ```
    */
  get character_alchemy_powers(): Prisma.character_alchemy_powersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.character_attributes`: Exposes CRUD operations for the **character_attributes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Character_attributes
    * const character_attributes = await prisma.character_attributes.findMany()
    * ```
    */
  get character_attributes(): Prisma.character_attributesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.character_bloodpotencies`: Exposes CRUD operations for the **character_bloodpotencies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Character_bloodpotencies
    * const character_bloodpotencies = await prisma.character_bloodpotencies.findMany()
    * ```
    */
  get character_bloodpotencies(): Prisma.character_bloodpotenciesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.character_discipline_powers`: Exposes CRUD operations for the **character_discipline_powers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Character_discipline_powers
    * const character_discipline_powers = await prisma.character_discipline_powers.findMany()
    * ```
    */
  get character_discipline_powers(): Prisma.character_discipline_powersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.character_disciplines`: Exposes CRUD operations for the **character_disciplines** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Character_disciplines
    * const character_disciplines = await prisma.character_disciplines.findMany()
    * ```
    */
  get character_disciplines(): Prisma.character_disciplinesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.character_healths`: Exposes CRUD operations for the **character_healths** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Character_healths
    * const character_healths = await prisma.character_healths.findMany()
    * ```
    */
  get character_healths(): Prisma.character_healthsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.character_humanity`: Exposes CRUD operations for the **character_humanity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Character_humanities
    * const character_humanities = await prisma.character_humanity.findMany()
    * ```
    */
  get character_humanity(): Prisma.character_humanityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.character_profile`: Exposes CRUD operations for the **character_profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Character_profiles
    * const character_profiles = await prisma.character_profile.findMany()
    * ```
    */
  get character_profile(): Prisma.character_profileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.character_rituals`: Exposes CRUD operations for the **character_rituals** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Character_rituals
    * const character_rituals = await prisma.character_rituals.findMany()
    * ```
    */
  get character_rituals(): Prisma.character_ritualsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.character_skills`: Exposes CRUD operations for the **character_skills** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Character_skills
    * const character_skills = await prisma.character_skills.findMany()
    * ```
    */
  get character_skills(): Prisma.character_skillsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.character_specialties`: Exposes CRUD operations for the **character_specialties** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Character_specialties
    * const character_specialties = await prisma.character_specialties.findMany()
    * ```
    */
  get character_specialties(): Prisma.character_specialtiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.character_willpowers`: Exposes CRUD operations for the **character_willpowers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Character_willpowers
    * const character_willpowers = await prisma.character_willpowers.findMany()
    * ```
    */
  get character_willpowers(): Prisma.character_willpowersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.characters`: Exposes CRUD operations for the **characters** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Characters
    * const characters = await prisma.characters.findMany()
    * ```
    */
  get characters(): Prisma.charactersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chronicles`: Exposes CRUD operations for the **chronicles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chronicles
    * const chronicles = await prisma.chronicles.findMany()
    * ```
    */
  get chronicles(): Prisma.chroniclesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clan_banes`: Exposes CRUD operations for the **clan_banes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clan_banes
    * const clan_banes = await prisma.clan_banes.findMany()
    * ```
    */
  get clan_banes(): Prisma.clan_banesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clan_compulsions`: Exposes CRUD operations for the **clan_compulsions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clan_compulsions
    * const clan_compulsions = await prisma.clan_compulsions.findMany()
    * ```
    */
  get clan_compulsions(): Prisma.clan_compulsionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clans`: Exposes CRUD operations for the **clans** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clans
    * const clans = await prisma.clans.findMany()
    * ```
    */
  get clans(): Prisma.clansDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.discipline_powers`: Exposes CRUD operations for the **discipline_powers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Discipline_powers
    * const discipline_powers = await prisma.discipline_powers.findMany()
    * ```
    */
  get discipline_powers(): Prisma.discipline_powersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.disciplines`: Exposes CRUD operations for the **disciplines** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Disciplines
    * const disciplines = await prisma.disciplines.findMany()
    * ```
    */
  get disciplines(): Prisma.disciplinesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exp_logs`: Exposes CRUD operations for the **exp_logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exp_logs
    * const exp_logs = await prisma.exp_logs.findMany()
    * ```
    */
  get exp_logs(): Prisma.exp_logsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.humanity`: Exposes CRUD operations for the **humanity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Humanities
    * const humanities = await prisma.humanity.findMany()
    * ```
    */
  get humanity(): Prisma.humanityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.predator_types`: Exposes CRUD operations for the **predator_types** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Predator_types
    * const predator_types = await prisma.predator_types.findMany()
    * ```
    */
  get predator_types(): Prisma.predator_typesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.rituals`: Exposes CRUD operations for the **rituals** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rituals
    * const rituals = await prisma.rituals.findMany()
    * ```
    */
  get rituals(): Prisma.ritualsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sects`: Exposes CRUD operations for the **sects** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sects
    * const sects = await prisma.sects.findMany()
    * ```
    */
  get sects(): Prisma.sectsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.skills`: Exposes CRUD operations for the **skills** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Skills
    * const skills = await prisma.skills.findMany()
    * ```
    */
  get skills(): Prisma.skillsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    advantages: 'advantages',
    alchemy_powers: 'alchemy_powers',
    attributes: 'attributes',
    blood_potency: 'blood_potency',
    char_groups: 'char_groups',
    character_advantages: 'character_advantages',
    character_alchemy_powers: 'character_alchemy_powers',
    character_attributes: 'character_attributes',
    character_bloodpotencies: 'character_bloodpotencies',
    character_discipline_powers: 'character_discipline_powers',
    character_disciplines: 'character_disciplines',
    character_healths: 'character_healths',
    character_humanity: 'character_humanity',
    character_profile: 'character_profile',
    character_rituals: 'character_rituals',
    character_skills: 'character_skills',
    character_specialties: 'character_specialties',
    character_willpowers: 'character_willpowers',
    characters: 'characters',
    chronicles: 'chronicles',
    clan_banes: 'clan_banes',
    clan_compulsions: 'clan_compulsions',
    clans: 'clans',
    discipline_powers: 'discipline_powers',
    disciplines: 'disciplines',
    exp_logs: 'exp_logs',
    humanity: 'humanity',
    predator_types: 'predator_types',
    rituals: 'rituals',
    sects: 'sects',
    skills: 'skills',
    users: 'users'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "advantages" | "alchemy_powers" | "attributes" | "blood_potency" | "char_groups" | "character_advantages" | "character_alchemy_powers" | "character_attributes" | "character_bloodpotencies" | "character_discipline_powers" | "character_disciplines" | "character_healths" | "character_humanity" | "character_profile" | "character_rituals" | "character_skills" | "character_specialties" | "character_willpowers" | "characters" | "chronicles" | "clan_banes" | "clan_compulsions" | "clans" | "discipline_powers" | "disciplines" | "exp_logs" | "humanity" | "predator_types" | "rituals" | "sects" | "skills" | "users"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      advantages: {
        payload: Prisma.$advantagesPayload<ExtArgs>
        fields: Prisma.advantagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.advantagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$advantagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.advantagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$advantagesPayload>
          }
          findFirst: {
            args: Prisma.advantagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$advantagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.advantagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$advantagesPayload>
          }
          findMany: {
            args: Prisma.advantagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$advantagesPayload>[]
          }
          create: {
            args: Prisma.advantagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$advantagesPayload>
          }
          createMany: {
            args: Prisma.advantagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.advantagesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$advantagesPayload>[]
          }
          delete: {
            args: Prisma.advantagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$advantagesPayload>
          }
          update: {
            args: Prisma.advantagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$advantagesPayload>
          }
          deleteMany: {
            args: Prisma.advantagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.advantagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.advantagesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$advantagesPayload>[]
          }
          upsert: {
            args: Prisma.advantagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$advantagesPayload>
          }
          aggregate: {
            args: Prisma.AdvantagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdvantages>
          }
          groupBy: {
            args: Prisma.advantagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdvantagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.advantagesCountArgs<ExtArgs>
            result: $Utils.Optional<AdvantagesCountAggregateOutputType> | number
          }
        }
      }
      alchemy_powers: {
        payload: Prisma.$alchemy_powersPayload<ExtArgs>
        fields: Prisma.alchemy_powersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.alchemy_powersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alchemy_powersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.alchemy_powersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alchemy_powersPayload>
          }
          findFirst: {
            args: Prisma.alchemy_powersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alchemy_powersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.alchemy_powersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alchemy_powersPayload>
          }
          findMany: {
            args: Prisma.alchemy_powersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alchemy_powersPayload>[]
          }
          create: {
            args: Prisma.alchemy_powersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alchemy_powersPayload>
          }
          createMany: {
            args: Prisma.alchemy_powersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.alchemy_powersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alchemy_powersPayload>[]
          }
          delete: {
            args: Prisma.alchemy_powersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alchemy_powersPayload>
          }
          update: {
            args: Prisma.alchemy_powersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alchemy_powersPayload>
          }
          deleteMany: {
            args: Prisma.alchemy_powersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.alchemy_powersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.alchemy_powersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alchemy_powersPayload>[]
          }
          upsert: {
            args: Prisma.alchemy_powersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alchemy_powersPayload>
          }
          aggregate: {
            args: Prisma.Alchemy_powersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlchemy_powers>
          }
          groupBy: {
            args: Prisma.alchemy_powersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Alchemy_powersGroupByOutputType>[]
          }
          count: {
            args: Prisma.alchemy_powersCountArgs<ExtArgs>
            result: $Utils.Optional<Alchemy_powersCountAggregateOutputType> | number
          }
        }
      }
      attributes: {
        payload: Prisma.$attributesPayload<ExtArgs>
        fields: Prisma.attributesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.attributesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attributesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.attributesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attributesPayload>
          }
          findFirst: {
            args: Prisma.attributesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attributesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.attributesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attributesPayload>
          }
          findMany: {
            args: Prisma.attributesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attributesPayload>[]
          }
          create: {
            args: Prisma.attributesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attributesPayload>
          }
          createMany: {
            args: Prisma.attributesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.attributesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attributesPayload>[]
          }
          delete: {
            args: Prisma.attributesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attributesPayload>
          }
          update: {
            args: Prisma.attributesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attributesPayload>
          }
          deleteMany: {
            args: Prisma.attributesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.attributesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.attributesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attributesPayload>[]
          }
          upsert: {
            args: Prisma.attributesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$attributesPayload>
          }
          aggregate: {
            args: Prisma.AttributesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttributes>
          }
          groupBy: {
            args: Prisma.attributesGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttributesGroupByOutputType>[]
          }
          count: {
            args: Prisma.attributesCountArgs<ExtArgs>
            result: $Utils.Optional<AttributesCountAggregateOutputType> | number
          }
        }
      }
      blood_potency: {
        payload: Prisma.$blood_potencyPayload<ExtArgs>
        fields: Prisma.blood_potencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.blood_potencyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blood_potencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.blood_potencyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blood_potencyPayload>
          }
          findFirst: {
            args: Prisma.blood_potencyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blood_potencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.blood_potencyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blood_potencyPayload>
          }
          findMany: {
            args: Prisma.blood_potencyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blood_potencyPayload>[]
          }
          create: {
            args: Prisma.blood_potencyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blood_potencyPayload>
          }
          createMany: {
            args: Prisma.blood_potencyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.blood_potencyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blood_potencyPayload>[]
          }
          delete: {
            args: Prisma.blood_potencyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blood_potencyPayload>
          }
          update: {
            args: Prisma.blood_potencyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blood_potencyPayload>
          }
          deleteMany: {
            args: Prisma.blood_potencyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.blood_potencyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.blood_potencyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blood_potencyPayload>[]
          }
          upsert: {
            args: Prisma.blood_potencyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blood_potencyPayload>
          }
          aggregate: {
            args: Prisma.Blood_potencyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlood_potency>
          }
          groupBy: {
            args: Prisma.blood_potencyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Blood_potencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.blood_potencyCountArgs<ExtArgs>
            result: $Utils.Optional<Blood_potencyCountAggregateOutputType> | number
          }
        }
      }
      char_groups: {
        payload: Prisma.$char_groupsPayload<ExtArgs>
        fields: Prisma.char_groupsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.char_groupsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$char_groupsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.char_groupsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$char_groupsPayload>
          }
          findFirst: {
            args: Prisma.char_groupsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$char_groupsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.char_groupsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$char_groupsPayload>
          }
          findMany: {
            args: Prisma.char_groupsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$char_groupsPayload>[]
          }
          create: {
            args: Prisma.char_groupsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$char_groupsPayload>
          }
          createMany: {
            args: Prisma.char_groupsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.char_groupsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$char_groupsPayload>[]
          }
          delete: {
            args: Prisma.char_groupsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$char_groupsPayload>
          }
          update: {
            args: Prisma.char_groupsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$char_groupsPayload>
          }
          deleteMany: {
            args: Prisma.char_groupsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.char_groupsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.char_groupsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$char_groupsPayload>[]
          }
          upsert: {
            args: Prisma.char_groupsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$char_groupsPayload>
          }
          aggregate: {
            args: Prisma.Char_groupsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChar_groups>
          }
          groupBy: {
            args: Prisma.char_groupsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Char_groupsGroupByOutputType>[]
          }
          count: {
            args: Prisma.char_groupsCountArgs<ExtArgs>
            result: $Utils.Optional<Char_groupsCountAggregateOutputType> | number
          }
        }
      }
      character_advantages: {
        payload: Prisma.$character_advantagesPayload<ExtArgs>
        fields: Prisma.character_advantagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.character_advantagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_advantagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.character_advantagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_advantagesPayload>
          }
          findFirst: {
            args: Prisma.character_advantagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_advantagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.character_advantagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_advantagesPayload>
          }
          findMany: {
            args: Prisma.character_advantagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_advantagesPayload>[]
          }
          create: {
            args: Prisma.character_advantagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_advantagesPayload>
          }
          createMany: {
            args: Prisma.character_advantagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.character_advantagesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_advantagesPayload>[]
          }
          delete: {
            args: Prisma.character_advantagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_advantagesPayload>
          }
          update: {
            args: Prisma.character_advantagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_advantagesPayload>
          }
          deleteMany: {
            args: Prisma.character_advantagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.character_advantagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.character_advantagesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_advantagesPayload>[]
          }
          upsert: {
            args: Prisma.character_advantagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_advantagesPayload>
          }
          aggregate: {
            args: Prisma.Character_advantagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacter_advantages>
          }
          groupBy: {
            args: Prisma.character_advantagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Character_advantagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.character_advantagesCountArgs<ExtArgs>
            result: $Utils.Optional<Character_advantagesCountAggregateOutputType> | number
          }
        }
      }
      character_alchemy_powers: {
        payload: Prisma.$character_alchemy_powersPayload<ExtArgs>
        fields: Prisma.character_alchemy_powersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.character_alchemy_powersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_alchemy_powersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.character_alchemy_powersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_alchemy_powersPayload>
          }
          findFirst: {
            args: Prisma.character_alchemy_powersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_alchemy_powersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.character_alchemy_powersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_alchemy_powersPayload>
          }
          findMany: {
            args: Prisma.character_alchemy_powersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_alchemy_powersPayload>[]
          }
          create: {
            args: Prisma.character_alchemy_powersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_alchemy_powersPayload>
          }
          createMany: {
            args: Prisma.character_alchemy_powersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.character_alchemy_powersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_alchemy_powersPayload>[]
          }
          delete: {
            args: Prisma.character_alchemy_powersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_alchemy_powersPayload>
          }
          update: {
            args: Prisma.character_alchemy_powersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_alchemy_powersPayload>
          }
          deleteMany: {
            args: Prisma.character_alchemy_powersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.character_alchemy_powersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.character_alchemy_powersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_alchemy_powersPayload>[]
          }
          upsert: {
            args: Prisma.character_alchemy_powersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_alchemy_powersPayload>
          }
          aggregate: {
            args: Prisma.Character_alchemy_powersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacter_alchemy_powers>
          }
          groupBy: {
            args: Prisma.character_alchemy_powersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Character_alchemy_powersGroupByOutputType>[]
          }
          count: {
            args: Prisma.character_alchemy_powersCountArgs<ExtArgs>
            result: $Utils.Optional<Character_alchemy_powersCountAggregateOutputType> | number
          }
        }
      }
      character_attributes: {
        payload: Prisma.$character_attributesPayload<ExtArgs>
        fields: Prisma.character_attributesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.character_attributesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_attributesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.character_attributesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_attributesPayload>
          }
          findFirst: {
            args: Prisma.character_attributesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_attributesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.character_attributesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_attributesPayload>
          }
          findMany: {
            args: Prisma.character_attributesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_attributesPayload>[]
          }
          create: {
            args: Prisma.character_attributesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_attributesPayload>
          }
          createMany: {
            args: Prisma.character_attributesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.character_attributesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_attributesPayload>[]
          }
          delete: {
            args: Prisma.character_attributesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_attributesPayload>
          }
          update: {
            args: Prisma.character_attributesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_attributesPayload>
          }
          deleteMany: {
            args: Prisma.character_attributesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.character_attributesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.character_attributesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_attributesPayload>[]
          }
          upsert: {
            args: Prisma.character_attributesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_attributesPayload>
          }
          aggregate: {
            args: Prisma.Character_attributesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacter_attributes>
          }
          groupBy: {
            args: Prisma.character_attributesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Character_attributesGroupByOutputType>[]
          }
          count: {
            args: Prisma.character_attributesCountArgs<ExtArgs>
            result: $Utils.Optional<Character_attributesCountAggregateOutputType> | number
          }
        }
      }
      character_bloodpotencies: {
        payload: Prisma.$character_bloodpotenciesPayload<ExtArgs>
        fields: Prisma.character_bloodpotenciesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.character_bloodpotenciesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_bloodpotenciesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.character_bloodpotenciesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_bloodpotenciesPayload>
          }
          findFirst: {
            args: Prisma.character_bloodpotenciesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_bloodpotenciesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.character_bloodpotenciesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_bloodpotenciesPayload>
          }
          findMany: {
            args: Prisma.character_bloodpotenciesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_bloodpotenciesPayload>[]
          }
          create: {
            args: Prisma.character_bloodpotenciesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_bloodpotenciesPayload>
          }
          createMany: {
            args: Prisma.character_bloodpotenciesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.character_bloodpotenciesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_bloodpotenciesPayload>[]
          }
          delete: {
            args: Prisma.character_bloodpotenciesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_bloodpotenciesPayload>
          }
          update: {
            args: Prisma.character_bloodpotenciesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_bloodpotenciesPayload>
          }
          deleteMany: {
            args: Prisma.character_bloodpotenciesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.character_bloodpotenciesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.character_bloodpotenciesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_bloodpotenciesPayload>[]
          }
          upsert: {
            args: Prisma.character_bloodpotenciesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_bloodpotenciesPayload>
          }
          aggregate: {
            args: Prisma.Character_bloodpotenciesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacter_bloodpotencies>
          }
          groupBy: {
            args: Prisma.character_bloodpotenciesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Character_bloodpotenciesGroupByOutputType>[]
          }
          count: {
            args: Prisma.character_bloodpotenciesCountArgs<ExtArgs>
            result: $Utils.Optional<Character_bloodpotenciesCountAggregateOutputType> | number
          }
        }
      }
      character_discipline_powers: {
        payload: Prisma.$character_discipline_powersPayload<ExtArgs>
        fields: Prisma.character_discipline_powersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.character_discipline_powersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_discipline_powersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.character_discipline_powersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_discipline_powersPayload>
          }
          findFirst: {
            args: Prisma.character_discipline_powersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_discipline_powersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.character_discipline_powersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_discipline_powersPayload>
          }
          findMany: {
            args: Prisma.character_discipline_powersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_discipline_powersPayload>[]
          }
          create: {
            args: Prisma.character_discipline_powersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_discipline_powersPayload>
          }
          createMany: {
            args: Prisma.character_discipline_powersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.character_discipline_powersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_discipline_powersPayload>[]
          }
          delete: {
            args: Prisma.character_discipline_powersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_discipline_powersPayload>
          }
          update: {
            args: Prisma.character_discipline_powersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_discipline_powersPayload>
          }
          deleteMany: {
            args: Prisma.character_discipline_powersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.character_discipline_powersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.character_discipline_powersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_discipline_powersPayload>[]
          }
          upsert: {
            args: Prisma.character_discipline_powersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_discipline_powersPayload>
          }
          aggregate: {
            args: Prisma.Character_discipline_powersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacter_discipline_powers>
          }
          groupBy: {
            args: Prisma.character_discipline_powersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Character_discipline_powersGroupByOutputType>[]
          }
          count: {
            args: Prisma.character_discipline_powersCountArgs<ExtArgs>
            result: $Utils.Optional<Character_discipline_powersCountAggregateOutputType> | number
          }
        }
      }
      character_disciplines: {
        payload: Prisma.$character_disciplinesPayload<ExtArgs>
        fields: Prisma.character_disciplinesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.character_disciplinesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_disciplinesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.character_disciplinesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_disciplinesPayload>
          }
          findFirst: {
            args: Prisma.character_disciplinesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_disciplinesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.character_disciplinesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_disciplinesPayload>
          }
          findMany: {
            args: Prisma.character_disciplinesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_disciplinesPayload>[]
          }
          create: {
            args: Prisma.character_disciplinesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_disciplinesPayload>
          }
          createMany: {
            args: Prisma.character_disciplinesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.character_disciplinesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_disciplinesPayload>[]
          }
          delete: {
            args: Prisma.character_disciplinesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_disciplinesPayload>
          }
          update: {
            args: Prisma.character_disciplinesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_disciplinesPayload>
          }
          deleteMany: {
            args: Prisma.character_disciplinesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.character_disciplinesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.character_disciplinesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_disciplinesPayload>[]
          }
          upsert: {
            args: Prisma.character_disciplinesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_disciplinesPayload>
          }
          aggregate: {
            args: Prisma.Character_disciplinesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacter_disciplines>
          }
          groupBy: {
            args: Prisma.character_disciplinesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Character_disciplinesGroupByOutputType>[]
          }
          count: {
            args: Prisma.character_disciplinesCountArgs<ExtArgs>
            result: $Utils.Optional<Character_disciplinesCountAggregateOutputType> | number
          }
        }
      }
      character_healths: {
        payload: Prisma.$character_healthsPayload<ExtArgs>
        fields: Prisma.character_healthsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.character_healthsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_healthsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.character_healthsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_healthsPayload>
          }
          findFirst: {
            args: Prisma.character_healthsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_healthsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.character_healthsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_healthsPayload>
          }
          findMany: {
            args: Prisma.character_healthsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_healthsPayload>[]
          }
          create: {
            args: Prisma.character_healthsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_healthsPayload>
          }
          createMany: {
            args: Prisma.character_healthsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.character_healthsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_healthsPayload>[]
          }
          delete: {
            args: Prisma.character_healthsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_healthsPayload>
          }
          update: {
            args: Prisma.character_healthsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_healthsPayload>
          }
          deleteMany: {
            args: Prisma.character_healthsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.character_healthsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.character_healthsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_healthsPayload>[]
          }
          upsert: {
            args: Prisma.character_healthsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_healthsPayload>
          }
          aggregate: {
            args: Prisma.Character_healthsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacter_healths>
          }
          groupBy: {
            args: Prisma.character_healthsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Character_healthsGroupByOutputType>[]
          }
          count: {
            args: Prisma.character_healthsCountArgs<ExtArgs>
            result: $Utils.Optional<Character_healthsCountAggregateOutputType> | number
          }
        }
      }
      character_humanity: {
        payload: Prisma.$character_humanityPayload<ExtArgs>
        fields: Prisma.character_humanityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.character_humanityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_humanityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.character_humanityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_humanityPayload>
          }
          findFirst: {
            args: Prisma.character_humanityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_humanityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.character_humanityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_humanityPayload>
          }
          findMany: {
            args: Prisma.character_humanityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_humanityPayload>[]
          }
          create: {
            args: Prisma.character_humanityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_humanityPayload>
          }
          createMany: {
            args: Prisma.character_humanityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.character_humanityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_humanityPayload>[]
          }
          delete: {
            args: Prisma.character_humanityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_humanityPayload>
          }
          update: {
            args: Prisma.character_humanityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_humanityPayload>
          }
          deleteMany: {
            args: Prisma.character_humanityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.character_humanityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.character_humanityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_humanityPayload>[]
          }
          upsert: {
            args: Prisma.character_humanityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_humanityPayload>
          }
          aggregate: {
            args: Prisma.Character_humanityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacter_humanity>
          }
          groupBy: {
            args: Prisma.character_humanityGroupByArgs<ExtArgs>
            result: $Utils.Optional<Character_humanityGroupByOutputType>[]
          }
          count: {
            args: Prisma.character_humanityCountArgs<ExtArgs>
            result: $Utils.Optional<Character_humanityCountAggregateOutputType> | number
          }
        }
      }
      character_profile: {
        payload: Prisma.$character_profilePayload<ExtArgs>
        fields: Prisma.character_profileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.character_profileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_profilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.character_profileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_profilePayload>
          }
          findFirst: {
            args: Prisma.character_profileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_profilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.character_profileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_profilePayload>
          }
          findMany: {
            args: Prisma.character_profileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_profilePayload>[]
          }
          create: {
            args: Prisma.character_profileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_profilePayload>
          }
          createMany: {
            args: Prisma.character_profileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.character_profileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_profilePayload>[]
          }
          delete: {
            args: Prisma.character_profileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_profilePayload>
          }
          update: {
            args: Prisma.character_profileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_profilePayload>
          }
          deleteMany: {
            args: Prisma.character_profileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.character_profileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.character_profileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_profilePayload>[]
          }
          upsert: {
            args: Prisma.character_profileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_profilePayload>
          }
          aggregate: {
            args: Prisma.Character_profileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacter_profile>
          }
          groupBy: {
            args: Prisma.character_profileGroupByArgs<ExtArgs>
            result: $Utils.Optional<Character_profileGroupByOutputType>[]
          }
          count: {
            args: Prisma.character_profileCountArgs<ExtArgs>
            result: $Utils.Optional<Character_profileCountAggregateOutputType> | number
          }
        }
      }
      character_rituals: {
        payload: Prisma.$character_ritualsPayload<ExtArgs>
        fields: Prisma.character_ritualsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.character_ritualsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_ritualsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.character_ritualsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_ritualsPayload>
          }
          findFirst: {
            args: Prisma.character_ritualsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_ritualsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.character_ritualsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_ritualsPayload>
          }
          findMany: {
            args: Prisma.character_ritualsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_ritualsPayload>[]
          }
          create: {
            args: Prisma.character_ritualsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_ritualsPayload>
          }
          createMany: {
            args: Prisma.character_ritualsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.character_ritualsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_ritualsPayload>[]
          }
          delete: {
            args: Prisma.character_ritualsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_ritualsPayload>
          }
          update: {
            args: Prisma.character_ritualsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_ritualsPayload>
          }
          deleteMany: {
            args: Prisma.character_ritualsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.character_ritualsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.character_ritualsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_ritualsPayload>[]
          }
          upsert: {
            args: Prisma.character_ritualsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_ritualsPayload>
          }
          aggregate: {
            args: Prisma.Character_ritualsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacter_rituals>
          }
          groupBy: {
            args: Prisma.character_ritualsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Character_ritualsGroupByOutputType>[]
          }
          count: {
            args: Prisma.character_ritualsCountArgs<ExtArgs>
            result: $Utils.Optional<Character_ritualsCountAggregateOutputType> | number
          }
        }
      }
      character_skills: {
        payload: Prisma.$character_skillsPayload<ExtArgs>
        fields: Prisma.character_skillsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.character_skillsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_skillsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.character_skillsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_skillsPayload>
          }
          findFirst: {
            args: Prisma.character_skillsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_skillsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.character_skillsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_skillsPayload>
          }
          findMany: {
            args: Prisma.character_skillsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_skillsPayload>[]
          }
          create: {
            args: Prisma.character_skillsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_skillsPayload>
          }
          createMany: {
            args: Prisma.character_skillsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.character_skillsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_skillsPayload>[]
          }
          delete: {
            args: Prisma.character_skillsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_skillsPayload>
          }
          update: {
            args: Prisma.character_skillsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_skillsPayload>
          }
          deleteMany: {
            args: Prisma.character_skillsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.character_skillsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.character_skillsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_skillsPayload>[]
          }
          upsert: {
            args: Prisma.character_skillsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_skillsPayload>
          }
          aggregate: {
            args: Prisma.Character_skillsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacter_skills>
          }
          groupBy: {
            args: Prisma.character_skillsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Character_skillsGroupByOutputType>[]
          }
          count: {
            args: Prisma.character_skillsCountArgs<ExtArgs>
            result: $Utils.Optional<Character_skillsCountAggregateOutputType> | number
          }
        }
      }
      character_specialties: {
        payload: Prisma.$character_specialtiesPayload<ExtArgs>
        fields: Prisma.character_specialtiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.character_specialtiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_specialtiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.character_specialtiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_specialtiesPayload>
          }
          findFirst: {
            args: Prisma.character_specialtiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_specialtiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.character_specialtiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_specialtiesPayload>
          }
          findMany: {
            args: Prisma.character_specialtiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_specialtiesPayload>[]
          }
          create: {
            args: Prisma.character_specialtiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_specialtiesPayload>
          }
          createMany: {
            args: Prisma.character_specialtiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.character_specialtiesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_specialtiesPayload>[]
          }
          delete: {
            args: Prisma.character_specialtiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_specialtiesPayload>
          }
          update: {
            args: Prisma.character_specialtiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_specialtiesPayload>
          }
          deleteMany: {
            args: Prisma.character_specialtiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.character_specialtiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.character_specialtiesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_specialtiesPayload>[]
          }
          upsert: {
            args: Prisma.character_specialtiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_specialtiesPayload>
          }
          aggregate: {
            args: Prisma.Character_specialtiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacter_specialties>
          }
          groupBy: {
            args: Prisma.character_specialtiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Character_specialtiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.character_specialtiesCountArgs<ExtArgs>
            result: $Utils.Optional<Character_specialtiesCountAggregateOutputType> | number
          }
        }
      }
      character_willpowers: {
        payload: Prisma.$character_willpowersPayload<ExtArgs>
        fields: Prisma.character_willpowersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.character_willpowersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_willpowersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.character_willpowersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_willpowersPayload>
          }
          findFirst: {
            args: Prisma.character_willpowersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_willpowersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.character_willpowersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_willpowersPayload>
          }
          findMany: {
            args: Prisma.character_willpowersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_willpowersPayload>[]
          }
          create: {
            args: Prisma.character_willpowersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_willpowersPayload>
          }
          createMany: {
            args: Prisma.character_willpowersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.character_willpowersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_willpowersPayload>[]
          }
          delete: {
            args: Prisma.character_willpowersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_willpowersPayload>
          }
          update: {
            args: Prisma.character_willpowersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_willpowersPayload>
          }
          deleteMany: {
            args: Prisma.character_willpowersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.character_willpowersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.character_willpowersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_willpowersPayload>[]
          }
          upsert: {
            args: Prisma.character_willpowersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$character_willpowersPayload>
          }
          aggregate: {
            args: Prisma.Character_willpowersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacter_willpowers>
          }
          groupBy: {
            args: Prisma.character_willpowersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Character_willpowersGroupByOutputType>[]
          }
          count: {
            args: Prisma.character_willpowersCountArgs<ExtArgs>
            result: $Utils.Optional<Character_willpowersCountAggregateOutputType> | number
          }
        }
      }
      characters: {
        payload: Prisma.$charactersPayload<ExtArgs>
        fields: Prisma.charactersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.charactersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$charactersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.charactersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$charactersPayload>
          }
          findFirst: {
            args: Prisma.charactersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$charactersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.charactersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$charactersPayload>
          }
          findMany: {
            args: Prisma.charactersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$charactersPayload>[]
          }
          create: {
            args: Prisma.charactersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$charactersPayload>
          }
          createMany: {
            args: Prisma.charactersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.charactersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$charactersPayload>[]
          }
          delete: {
            args: Prisma.charactersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$charactersPayload>
          }
          update: {
            args: Prisma.charactersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$charactersPayload>
          }
          deleteMany: {
            args: Prisma.charactersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.charactersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.charactersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$charactersPayload>[]
          }
          upsert: {
            args: Prisma.charactersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$charactersPayload>
          }
          aggregate: {
            args: Prisma.CharactersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacters>
          }
          groupBy: {
            args: Prisma.charactersGroupByArgs<ExtArgs>
            result: $Utils.Optional<CharactersGroupByOutputType>[]
          }
          count: {
            args: Prisma.charactersCountArgs<ExtArgs>
            result: $Utils.Optional<CharactersCountAggregateOutputType> | number
          }
        }
      }
      chronicles: {
        payload: Prisma.$chroniclesPayload<ExtArgs>
        fields: Prisma.chroniclesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chroniclesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chroniclesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chroniclesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chroniclesPayload>
          }
          findFirst: {
            args: Prisma.chroniclesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chroniclesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chroniclesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chroniclesPayload>
          }
          findMany: {
            args: Prisma.chroniclesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chroniclesPayload>[]
          }
          create: {
            args: Prisma.chroniclesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chroniclesPayload>
          }
          createMany: {
            args: Prisma.chroniclesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.chroniclesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chroniclesPayload>[]
          }
          delete: {
            args: Prisma.chroniclesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chroniclesPayload>
          }
          update: {
            args: Prisma.chroniclesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chroniclesPayload>
          }
          deleteMany: {
            args: Prisma.chroniclesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.chroniclesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.chroniclesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chroniclesPayload>[]
          }
          upsert: {
            args: Prisma.chroniclesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chroniclesPayload>
          }
          aggregate: {
            args: Prisma.ChroniclesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChronicles>
          }
          groupBy: {
            args: Prisma.chroniclesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChroniclesGroupByOutputType>[]
          }
          count: {
            args: Prisma.chroniclesCountArgs<ExtArgs>
            result: $Utils.Optional<ChroniclesCountAggregateOutputType> | number
          }
        }
      }
      clan_banes: {
        payload: Prisma.$clan_banesPayload<ExtArgs>
        fields: Prisma.clan_banesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.clan_banesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clan_banesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.clan_banesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clan_banesPayload>
          }
          findFirst: {
            args: Prisma.clan_banesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clan_banesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.clan_banesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clan_banesPayload>
          }
          findMany: {
            args: Prisma.clan_banesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clan_banesPayload>[]
          }
          create: {
            args: Prisma.clan_banesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clan_banesPayload>
          }
          createMany: {
            args: Prisma.clan_banesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.clan_banesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clan_banesPayload>[]
          }
          delete: {
            args: Prisma.clan_banesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clan_banesPayload>
          }
          update: {
            args: Prisma.clan_banesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clan_banesPayload>
          }
          deleteMany: {
            args: Prisma.clan_banesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.clan_banesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.clan_banesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clan_banesPayload>[]
          }
          upsert: {
            args: Prisma.clan_banesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clan_banesPayload>
          }
          aggregate: {
            args: Prisma.Clan_banesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClan_banes>
          }
          groupBy: {
            args: Prisma.clan_banesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Clan_banesGroupByOutputType>[]
          }
          count: {
            args: Prisma.clan_banesCountArgs<ExtArgs>
            result: $Utils.Optional<Clan_banesCountAggregateOutputType> | number
          }
        }
      }
      clan_compulsions: {
        payload: Prisma.$clan_compulsionsPayload<ExtArgs>
        fields: Prisma.clan_compulsionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.clan_compulsionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clan_compulsionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.clan_compulsionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clan_compulsionsPayload>
          }
          findFirst: {
            args: Prisma.clan_compulsionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clan_compulsionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.clan_compulsionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clan_compulsionsPayload>
          }
          findMany: {
            args: Prisma.clan_compulsionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clan_compulsionsPayload>[]
          }
          create: {
            args: Prisma.clan_compulsionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clan_compulsionsPayload>
          }
          createMany: {
            args: Prisma.clan_compulsionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.clan_compulsionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clan_compulsionsPayload>[]
          }
          delete: {
            args: Prisma.clan_compulsionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clan_compulsionsPayload>
          }
          update: {
            args: Prisma.clan_compulsionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clan_compulsionsPayload>
          }
          deleteMany: {
            args: Prisma.clan_compulsionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.clan_compulsionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.clan_compulsionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clan_compulsionsPayload>[]
          }
          upsert: {
            args: Prisma.clan_compulsionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clan_compulsionsPayload>
          }
          aggregate: {
            args: Prisma.Clan_compulsionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClan_compulsions>
          }
          groupBy: {
            args: Prisma.clan_compulsionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Clan_compulsionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.clan_compulsionsCountArgs<ExtArgs>
            result: $Utils.Optional<Clan_compulsionsCountAggregateOutputType> | number
          }
        }
      }
      clans: {
        payload: Prisma.$clansPayload<ExtArgs>
        fields: Prisma.clansFieldRefs
        operations: {
          findUnique: {
            args: Prisma.clansFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clansPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.clansFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clansPayload>
          }
          findFirst: {
            args: Prisma.clansFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clansPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.clansFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clansPayload>
          }
          findMany: {
            args: Prisma.clansFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clansPayload>[]
          }
          create: {
            args: Prisma.clansCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clansPayload>
          }
          createMany: {
            args: Prisma.clansCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.clansCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clansPayload>[]
          }
          delete: {
            args: Prisma.clansDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clansPayload>
          }
          update: {
            args: Prisma.clansUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clansPayload>
          }
          deleteMany: {
            args: Prisma.clansDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.clansUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.clansUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clansPayload>[]
          }
          upsert: {
            args: Prisma.clansUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$clansPayload>
          }
          aggregate: {
            args: Prisma.ClansAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClans>
          }
          groupBy: {
            args: Prisma.clansGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClansGroupByOutputType>[]
          }
          count: {
            args: Prisma.clansCountArgs<ExtArgs>
            result: $Utils.Optional<ClansCountAggregateOutputType> | number
          }
        }
      }
      discipline_powers: {
        payload: Prisma.$discipline_powersPayload<ExtArgs>
        fields: Prisma.discipline_powersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.discipline_powersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$discipline_powersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.discipline_powersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$discipline_powersPayload>
          }
          findFirst: {
            args: Prisma.discipline_powersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$discipline_powersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.discipline_powersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$discipline_powersPayload>
          }
          findMany: {
            args: Prisma.discipline_powersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$discipline_powersPayload>[]
          }
          create: {
            args: Prisma.discipline_powersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$discipline_powersPayload>
          }
          createMany: {
            args: Prisma.discipline_powersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.discipline_powersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$discipline_powersPayload>[]
          }
          delete: {
            args: Prisma.discipline_powersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$discipline_powersPayload>
          }
          update: {
            args: Prisma.discipline_powersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$discipline_powersPayload>
          }
          deleteMany: {
            args: Prisma.discipline_powersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.discipline_powersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.discipline_powersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$discipline_powersPayload>[]
          }
          upsert: {
            args: Prisma.discipline_powersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$discipline_powersPayload>
          }
          aggregate: {
            args: Prisma.Discipline_powersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDiscipline_powers>
          }
          groupBy: {
            args: Prisma.discipline_powersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Discipline_powersGroupByOutputType>[]
          }
          count: {
            args: Prisma.discipline_powersCountArgs<ExtArgs>
            result: $Utils.Optional<Discipline_powersCountAggregateOutputType> | number
          }
        }
      }
      disciplines: {
        payload: Prisma.$disciplinesPayload<ExtArgs>
        fields: Prisma.disciplinesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.disciplinesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$disciplinesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.disciplinesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$disciplinesPayload>
          }
          findFirst: {
            args: Prisma.disciplinesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$disciplinesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.disciplinesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$disciplinesPayload>
          }
          findMany: {
            args: Prisma.disciplinesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$disciplinesPayload>[]
          }
          create: {
            args: Prisma.disciplinesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$disciplinesPayload>
          }
          createMany: {
            args: Prisma.disciplinesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.disciplinesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$disciplinesPayload>[]
          }
          delete: {
            args: Prisma.disciplinesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$disciplinesPayload>
          }
          update: {
            args: Prisma.disciplinesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$disciplinesPayload>
          }
          deleteMany: {
            args: Prisma.disciplinesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.disciplinesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.disciplinesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$disciplinesPayload>[]
          }
          upsert: {
            args: Prisma.disciplinesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$disciplinesPayload>
          }
          aggregate: {
            args: Prisma.DisciplinesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDisciplines>
          }
          groupBy: {
            args: Prisma.disciplinesGroupByArgs<ExtArgs>
            result: $Utils.Optional<DisciplinesGroupByOutputType>[]
          }
          count: {
            args: Prisma.disciplinesCountArgs<ExtArgs>
            result: $Utils.Optional<DisciplinesCountAggregateOutputType> | number
          }
        }
      }
      exp_logs: {
        payload: Prisma.$exp_logsPayload<ExtArgs>
        fields: Prisma.exp_logsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.exp_logsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exp_logsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.exp_logsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exp_logsPayload>
          }
          findFirst: {
            args: Prisma.exp_logsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exp_logsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.exp_logsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exp_logsPayload>
          }
          findMany: {
            args: Prisma.exp_logsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exp_logsPayload>[]
          }
          create: {
            args: Prisma.exp_logsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exp_logsPayload>
          }
          createMany: {
            args: Prisma.exp_logsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.exp_logsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exp_logsPayload>[]
          }
          delete: {
            args: Prisma.exp_logsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exp_logsPayload>
          }
          update: {
            args: Prisma.exp_logsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exp_logsPayload>
          }
          deleteMany: {
            args: Prisma.exp_logsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.exp_logsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.exp_logsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exp_logsPayload>[]
          }
          upsert: {
            args: Prisma.exp_logsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exp_logsPayload>
          }
          aggregate: {
            args: Prisma.Exp_logsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExp_logs>
          }
          groupBy: {
            args: Prisma.exp_logsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Exp_logsGroupByOutputType>[]
          }
          count: {
            args: Prisma.exp_logsCountArgs<ExtArgs>
            result: $Utils.Optional<Exp_logsCountAggregateOutputType> | number
          }
        }
      }
      humanity: {
        payload: Prisma.$humanityPayload<ExtArgs>
        fields: Prisma.humanityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.humanityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$humanityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.humanityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$humanityPayload>
          }
          findFirst: {
            args: Prisma.humanityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$humanityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.humanityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$humanityPayload>
          }
          findMany: {
            args: Prisma.humanityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$humanityPayload>[]
          }
          create: {
            args: Prisma.humanityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$humanityPayload>
          }
          createMany: {
            args: Prisma.humanityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.humanityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$humanityPayload>[]
          }
          delete: {
            args: Prisma.humanityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$humanityPayload>
          }
          update: {
            args: Prisma.humanityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$humanityPayload>
          }
          deleteMany: {
            args: Prisma.humanityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.humanityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.humanityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$humanityPayload>[]
          }
          upsert: {
            args: Prisma.humanityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$humanityPayload>
          }
          aggregate: {
            args: Prisma.HumanityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHumanity>
          }
          groupBy: {
            args: Prisma.humanityGroupByArgs<ExtArgs>
            result: $Utils.Optional<HumanityGroupByOutputType>[]
          }
          count: {
            args: Prisma.humanityCountArgs<ExtArgs>
            result: $Utils.Optional<HumanityCountAggregateOutputType> | number
          }
        }
      }
      predator_types: {
        payload: Prisma.$predator_typesPayload<ExtArgs>
        fields: Prisma.predator_typesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.predator_typesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$predator_typesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.predator_typesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$predator_typesPayload>
          }
          findFirst: {
            args: Prisma.predator_typesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$predator_typesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.predator_typesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$predator_typesPayload>
          }
          findMany: {
            args: Prisma.predator_typesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$predator_typesPayload>[]
          }
          create: {
            args: Prisma.predator_typesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$predator_typesPayload>
          }
          createMany: {
            args: Prisma.predator_typesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.predator_typesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$predator_typesPayload>[]
          }
          delete: {
            args: Prisma.predator_typesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$predator_typesPayload>
          }
          update: {
            args: Prisma.predator_typesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$predator_typesPayload>
          }
          deleteMany: {
            args: Prisma.predator_typesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.predator_typesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.predator_typesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$predator_typesPayload>[]
          }
          upsert: {
            args: Prisma.predator_typesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$predator_typesPayload>
          }
          aggregate: {
            args: Prisma.Predator_typesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePredator_types>
          }
          groupBy: {
            args: Prisma.predator_typesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Predator_typesGroupByOutputType>[]
          }
          count: {
            args: Prisma.predator_typesCountArgs<ExtArgs>
            result: $Utils.Optional<Predator_typesCountAggregateOutputType> | number
          }
        }
      }
      rituals: {
        payload: Prisma.$ritualsPayload<ExtArgs>
        fields: Prisma.ritualsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ritualsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ritualsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ritualsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ritualsPayload>
          }
          findFirst: {
            args: Prisma.ritualsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ritualsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ritualsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ritualsPayload>
          }
          findMany: {
            args: Prisma.ritualsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ritualsPayload>[]
          }
          create: {
            args: Prisma.ritualsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ritualsPayload>
          }
          createMany: {
            args: Prisma.ritualsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ritualsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ritualsPayload>[]
          }
          delete: {
            args: Prisma.ritualsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ritualsPayload>
          }
          update: {
            args: Prisma.ritualsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ritualsPayload>
          }
          deleteMany: {
            args: Prisma.ritualsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ritualsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ritualsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ritualsPayload>[]
          }
          upsert: {
            args: Prisma.ritualsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ritualsPayload>
          }
          aggregate: {
            args: Prisma.RitualsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRituals>
          }
          groupBy: {
            args: Prisma.ritualsGroupByArgs<ExtArgs>
            result: $Utils.Optional<RitualsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ritualsCountArgs<ExtArgs>
            result: $Utils.Optional<RitualsCountAggregateOutputType> | number
          }
        }
      }
      sects: {
        payload: Prisma.$sectsPayload<ExtArgs>
        fields: Prisma.sectsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sectsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sectsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sectsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sectsPayload>
          }
          findFirst: {
            args: Prisma.sectsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sectsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sectsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sectsPayload>
          }
          findMany: {
            args: Prisma.sectsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sectsPayload>[]
          }
          create: {
            args: Prisma.sectsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sectsPayload>
          }
          createMany: {
            args: Prisma.sectsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.sectsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sectsPayload>[]
          }
          delete: {
            args: Prisma.sectsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sectsPayload>
          }
          update: {
            args: Prisma.sectsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sectsPayload>
          }
          deleteMany: {
            args: Prisma.sectsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sectsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.sectsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sectsPayload>[]
          }
          upsert: {
            args: Prisma.sectsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sectsPayload>
          }
          aggregate: {
            args: Prisma.SectsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSects>
          }
          groupBy: {
            args: Prisma.sectsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SectsGroupByOutputType>[]
          }
          count: {
            args: Prisma.sectsCountArgs<ExtArgs>
            result: $Utils.Optional<SectsCountAggregateOutputType> | number
          }
        }
      }
      skills: {
        payload: Prisma.$skillsPayload<ExtArgs>
        fields: Prisma.skillsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.skillsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.skillsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillsPayload>
          }
          findFirst: {
            args: Prisma.skillsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.skillsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillsPayload>
          }
          findMany: {
            args: Prisma.skillsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillsPayload>[]
          }
          create: {
            args: Prisma.skillsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillsPayload>
          }
          createMany: {
            args: Prisma.skillsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.skillsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillsPayload>[]
          }
          delete: {
            args: Prisma.skillsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillsPayload>
          }
          update: {
            args: Prisma.skillsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillsPayload>
          }
          deleteMany: {
            args: Prisma.skillsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.skillsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.skillsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillsPayload>[]
          }
          upsert: {
            args: Prisma.skillsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$skillsPayload>
          }
          aggregate: {
            args: Prisma.SkillsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkills>
          }
          groupBy: {
            args: Prisma.skillsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkillsGroupByOutputType>[]
          }
          count: {
            args: Prisma.skillsCountArgs<ExtArgs>
            result: $Utils.Optional<SkillsCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.usersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    advantages?: advantagesOmit
    alchemy_powers?: alchemy_powersOmit
    attributes?: attributesOmit
    blood_potency?: blood_potencyOmit
    char_groups?: char_groupsOmit
    character_advantages?: character_advantagesOmit
    character_alchemy_powers?: character_alchemy_powersOmit
    character_attributes?: character_attributesOmit
    character_bloodpotencies?: character_bloodpotenciesOmit
    character_discipline_powers?: character_discipline_powersOmit
    character_disciplines?: character_disciplinesOmit
    character_healths?: character_healthsOmit
    character_humanity?: character_humanityOmit
    character_profile?: character_profileOmit
    character_rituals?: character_ritualsOmit
    character_skills?: character_skillsOmit
    character_specialties?: character_specialtiesOmit
    character_willpowers?: character_willpowersOmit
    characters?: charactersOmit
    chronicles?: chroniclesOmit
    clan_banes?: clan_banesOmit
    clan_compulsions?: clan_compulsionsOmit
    clans?: clansOmit
    discipline_powers?: discipline_powersOmit
    disciplines?: disciplinesOmit
    exp_logs?: exp_logsOmit
    humanity?: humanityOmit
    predator_types?: predator_typesOmit
    rituals?: ritualsOmit
    sects?: sectsOmit
    skills?: skillsOmit
    users?: usersOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AdvantagesCountOutputType
   */

  export type AdvantagesCountOutputType = {
    character_advantages: number
  }

  export type AdvantagesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character_advantages?: boolean | AdvantagesCountOutputTypeCountCharacter_advantagesArgs
  }

  // Custom InputTypes
  /**
   * AdvantagesCountOutputType without action
   */
  export type AdvantagesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvantagesCountOutputType
     */
    select?: AdvantagesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdvantagesCountOutputType without action
   */
  export type AdvantagesCountOutputTypeCountCharacter_advantagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: character_advantagesWhereInput
  }


  /**
   * Count Type Alchemy_powersCountOutputType
   */

  export type Alchemy_powersCountOutputType = {
    character_alchemy_powers: number
  }

  export type Alchemy_powersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character_alchemy_powers?: boolean | Alchemy_powersCountOutputTypeCountCharacter_alchemy_powersArgs
  }

  // Custom InputTypes
  /**
   * Alchemy_powersCountOutputType without action
   */
  export type Alchemy_powersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alchemy_powersCountOutputType
     */
    select?: Alchemy_powersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Alchemy_powersCountOutputType without action
   */
  export type Alchemy_powersCountOutputTypeCountCharacter_alchemy_powersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: character_alchemy_powersWhereInput
  }


  /**
   * Count Type AttributesCountOutputType
   */

  export type AttributesCountOutputType = {
    character_attributes: number
  }

  export type AttributesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character_attributes?: boolean | AttributesCountOutputTypeCountCharacter_attributesArgs
  }

  // Custom InputTypes
  /**
   * AttributesCountOutputType without action
   */
  export type AttributesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttributesCountOutputType
     */
    select?: AttributesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AttributesCountOutputType without action
   */
  export type AttributesCountOutputTypeCountCharacter_attributesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: character_attributesWhereInput
  }


  /**
   * Count Type Blood_potencyCountOutputType
   */

  export type Blood_potencyCountOutputType = {
    character_bloodpotencies: number
  }

  export type Blood_potencyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character_bloodpotencies?: boolean | Blood_potencyCountOutputTypeCountCharacter_bloodpotenciesArgs
  }

  // Custom InputTypes
  /**
   * Blood_potencyCountOutputType without action
   */
  export type Blood_potencyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Blood_potencyCountOutputType
     */
    select?: Blood_potencyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Blood_potencyCountOutputType without action
   */
  export type Blood_potencyCountOutputTypeCountCharacter_bloodpotenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: character_bloodpotenciesWhereInput
  }


  /**
   * Count Type Char_groupsCountOutputType
   */

  export type Char_groupsCountOutputType = {
    other_char_groups: number
    characters: number
  }

  export type Char_groupsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    other_char_groups?: boolean | Char_groupsCountOutputTypeCountOther_char_groupsArgs
    characters?: boolean | Char_groupsCountOutputTypeCountCharactersArgs
  }

  // Custom InputTypes
  /**
   * Char_groupsCountOutputType without action
   */
  export type Char_groupsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Char_groupsCountOutputType
     */
    select?: Char_groupsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Char_groupsCountOutputType without action
   */
  export type Char_groupsCountOutputTypeCountOther_char_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: char_groupsWhereInput
  }

  /**
   * Char_groupsCountOutputType without action
   */
  export type Char_groupsCountOutputTypeCountCharactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: charactersWhereInput
  }


  /**
   * Count Type CharactersCountOutputType
   */

  export type CharactersCountOutputType = {
    character_advantages: number
    character_alchemy_powers: number
    character_attributes: number
    character_bloodpotencies: number
    character_discipline_powers: number
    character_disciplines: number
    character_healths: number
    character_humanity: number
    character_profile: number
    character_rituals: number
    character_skills: number
    character_specialties: number
    character_willpowers: number
    exp_logs: number
  }

  export type CharactersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character_advantages?: boolean | CharactersCountOutputTypeCountCharacter_advantagesArgs
    character_alchemy_powers?: boolean | CharactersCountOutputTypeCountCharacter_alchemy_powersArgs
    character_attributes?: boolean | CharactersCountOutputTypeCountCharacter_attributesArgs
    character_bloodpotencies?: boolean | CharactersCountOutputTypeCountCharacter_bloodpotenciesArgs
    character_discipline_powers?: boolean | CharactersCountOutputTypeCountCharacter_discipline_powersArgs
    character_disciplines?: boolean | CharactersCountOutputTypeCountCharacter_disciplinesArgs
    character_healths?: boolean | CharactersCountOutputTypeCountCharacter_healthsArgs
    character_humanity?: boolean | CharactersCountOutputTypeCountCharacter_humanityArgs
    character_profile?: boolean | CharactersCountOutputTypeCountCharacter_profileArgs
    character_rituals?: boolean | CharactersCountOutputTypeCountCharacter_ritualsArgs
    character_skills?: boolean | CharactersCountOutputTypeCountCharacter_skillsArgs
    character_specialties?: boolean | CharactersCountOutputTypeCountCharacter_specialtiesArgs
    character_willpowers?: boolean | CharactersCountOutputTypeCountCharacter_willpowersArgs
    exp_logs?: boolean | CharactersCountOutputTypeCountExp_logsArgs
  }

  // Custom InputTypes
  /**
   * CharactersCountOutputType without action
   */
  export type CharactersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharactersCountOutputType
     */
    select?: CharactersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CharactersCountOutputType without action
   */
  export type CharactersCountOutputTypeCountCharacter_advantagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: character_advantagesWhereInput
  }

  /**
   * CharactersCountOutputType without action
   */
  export type CharactersCountOutputTypeCountCharacter_alchemy_powersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: character_alchemy_powersWhereInput
  }

  /**
   * CharactersCountOutputType without action
   */
  export type CharactersCountOutputTypeCountCharacter_attributesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: character_attributesWhereInput
  }

  /**
   * CharactersCountOutputType without action
   */
  export type CharactersCountOutputTypeCountCharacter_bloodpotenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: character_bloodpotenciesWhereInput
  }

  /**
   * CharactersCountOutputType without action
   */
  export type CharactersCountOutputTypeCountCharacter_discipline_powersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: character_discipline_powersWhereInput
  }

  /**
   * CharactersCountOutputType without action
   */
  export type CharactersCountOutputTypeCountCharacter_disciplinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: character_disciplinesWhereInput
  }

  /**
   * CharactersCountOutputType without action
   */
  export type CharactersCountOutputTypeCountCharacter_healthsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: character_healthsWhereInput
  }

  /**
   * CharactersCountOutputType without action
   */
  export type CharactersCountOutputTypeCountCharacter_humanityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: character_humanityWhereInput
  }

  /**
   * CharactersCountOutputType without action
   */
  export type CharactersCountOutputTypeCountCharacter_profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: character_profileWhereInput
  }

  /**
   * CharactersCountOutputType without action
   */
  export type CharactersCountOutputTypeCountCharacter_ritualsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: character_ritualsWhereInput
  }

  /**
   * CharactersCountOutputType without action
   */
  export type CharactersCountOutputTypeCountCharacter_skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: character_skillsWhereInput
  }

  /**
   * CharactersCountOutputType without action
   */
  export type CharactersCountOutputTypeCountCharacter_specialtiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: character_specialtiesWhereInput
  }

  /**
   * CharactersCountOutputType without action
   */
  export type CharactersCountOutputTypeCountCharacter_willpowersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: character_willpowersWhereInput
  }

  /**
   * CharactersCountOutputType without action
   */
  export type CharactersCountOutputTypeCountExp_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: exp_logsWhereInput
  }


  /**
   * Count Type ChroniclesCountOutputType
   */

  export type ChroniclesCountOutputType = {
    characters: number
  }

  export type ChroniclesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | ChroniclesCountOutputTypeCountCharactersArgs
  }

  // Custom InputTypes
  /**
   * ChroniclesCountOutputType without action
   */
  export type ChroniclesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChroniclesCountOutputType
     */
    select?: ChroniclesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChroniclesCountOutputType without action
   */
  export type ChroniclesCountOutputTypeCountCharactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: charactersWhereInput
  }


  /**
   * Count Type Clan_banesCountOutputType
   */

  export type Clan_banesCountOutputType = {
    character_bloodpotencies: number
    characters: number
  }

  export type Clan_banesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character_bloodpotencies?: boolean | Clan_banesCountOutputTypeCountCharacter_bloodpotenciesArgs
    characters?: boolean | Clan_banesCountOutputTypeCountCharactersArgs
  }

  // Custom InputTypes
  /**
   * Clan_banesCountOutputType without action
   */
  export type Clan_banesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clan_banesCountOutputType
     */
    select?: Clan_banesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Clan_banesCountOutputType without action
   */
  export type Clan_banesCountOutputTypeCountCharacter_bloodpotenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: character_bloodpotenciesWhereInput
  }

  /**
   * Clan_banesCountOutputType without action
   */
  export type Clan_banesCountOutputTypeCountCharactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: charactersWhereInput
  }


  /**
   * Count Type Clan_compulsionsCountOutputType
   */

  export type Clan_compulsionsCountOutputType = {
    character_bloodpotencies: number
    characters: number
  }

  export type Clan_compulsionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character_bloodpotencies?: boolean | Clan_compulsionsCountOutputTypeCountCharacter_bloodpotenciesArgs
    characters?: boolean | Clan_compulsionsCountOutputTypeCountCharactersArgs
  }

  // Custom InputTypes
  /**
   * Clan_compulsionsCountOutputType without action
   */
  export type Clan_compulsionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clan_compulsionsCountOutputType
     */
    select?: Clan_compulsionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Clan_compulsionsCountOutputType without action
   */
  export type Clan_compulsionsCountOutputTypeCountCharacter_bloodpotenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: character_bloodpotenciesWhereInput
  }

  /**
   * Clan_compulsionsCountOutputType without action
   */
  export type Clan_compulsionsCountOutputTypeCountCharactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: charactersWhereInput
  }


  /**
   * Count Type ClansCountOutputType
   */

  export type ClansCountOutputType = {
    advantages: number
    characters: number
    clan_banes: number
    clan_compulsions: number
  }

  export type ClansCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    advantages?: boolean | ClansCountOutputTypeCountAdvantagesArgs
    characters?: boolean | ClansCountOutputTypeCountCharactersArgs
    clan_banes?: boolean | ClansCountOutputTypeCountClan_banesArgs
    clan_compulsions?: boolean | ClansCountOutputTypeCountClan_compulsionsArgs
  }

  // Custom InputTypes
  /**
   * ClansCountOutputType without action
   */
  export type ClansCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClansCountOutputType
     */
    select?: ClansCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClansCountOutputType without action
   */
  export type ClansCountOutputTypeCountAdvantagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: advantagesWhereInput
  }

  /**
   * ClansCountOutputType without action
   */
  export type ClansCountOutputTypeCountCharactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: charactersWhereInput
  }

  /**
   * ClansCountOutputType without action
   */
  export type ClansCountOutputTypeCountClan_banesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clan_banesWhereInput
  }

  /**
   * ClansCountOutputType without action
   */
  export type ClansCountOutputTypeCountClan_compulsionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clan_compulsionsWhereInput
  }


  /**
   * Count Type Discipline_powersCountOutputType
   */

  export type Discipline_powersCountOutputType = {
    character_discipline_powers: number
  }

  export type Discipline_powersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character_discipline_powers?: boolean | Discipline_powersCountOutputTypeCountCharacter_discipline_powersArgs
  }

  // Custom InputTypes
  /**
   * Discipline_powersCountOutputType without action
   */
  export type Discipline_powersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discipline_powersCountOutputType
     */
    select?: Discipline_powersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Discipline_powersCountOutputType without action
   */
  export type Discipline_powersCountOutputTypeCountCharacter_discipline_powersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: character_discipline_powersWhereInput
  }


  /**
   * Count Type DisciplinesCountOutputType
   */

  export type DisciplinesCountOutputType = {
    character_disciplines: number
    discipline_powers: number
  }

  export type DisciplinesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character_disciplines?: boolean | DisciplinesCountOutputTypeCountCharacter_disciplinesArgs
    discipline_powers?: boolean | DisciplinesCountOutputTypeCountDiscipline_powersArgs
  }

  // Custom InputTypes
  /**
   * DisciplinesCountOutputType without action
   */
  export type DisciplinesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisciplinesCountOutputType
     */
    select?: DisciplinesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DisciplinesCountOutputType without action
   */
  export type DisciplinesCountOutputTypeCountCharacter_disciplinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: character_disciplinesWhereInput
  }

  /**
   * DisciplinesCountOutputType without action
   */
  export type DisciplinesCountOutputTypeCountDiscipline_powersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: discipline_powersWhereInput
  }


  /**
   * Count Type Predator_typesCountOutputType
   */

  export type Predator_typesCountOutputType = {
    characters: number
  }

  export type Predator_typesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | Predator_typesCountOutputTypeCountCharactersArgs
  }

  // Custom InputTypes
  /**
   * Predator_typesCountOutputType without action
   */
  export type Predator_typesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Predator_typesCountOutputType
     */
    select?: Predator_typesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Predator_typesCountOutputType without action
   */
  export type Predator_typesCountOutputTypeCountCharactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: charactersWhereInput
  }


  /**
   * Count Type RitualsCountOutputType
   */

  export type RitualsCountOutputType = {
    character_rituals: number
  }

  export type RitualsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character_rituals?: boolean | RitualsCountOutputTypeCountCharacter_ritualsArgs
  }

  // Custom InputTypes
  /**
   * RitualsCountOutputType without action
   */
  export type RitualsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RitualsCountOutputType
     */
    select?: RitualsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RitualsCountOutputType without action
   */
  export type RitualsCountOutputTypeCountCharacter_ritualsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: character_ritualsWhereInput
  }


  /**
   * Count Type SectsCountOutputType
   */

  export type SectsCountOutputType = {
    advantages: number
    characters: number
  }

  export type SectsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    advantages?: boolean | SectsCountOutputTypeCountAdvantagesArgs
    characters?: boolean | SectsCountOutputTypeCountCharactersArgs
  }

  // Custom InputTypes
  /**
   * SectsCountOutputType without action
   */
  export type SectsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectsCountOutputType
     */
    select?: SectsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SectsCountOutputType without action
   */
  export type SectsCountOutputTypeCountAdvantagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: advantagesWhereInput
  }

  /**
   * SectsCountOutputType without action
   */
  export type SectsCountOutputTypeCountCharactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: charactersWhereInput
  }


  /**
   * Count Type SkillsCountOutputType
   */

  export type SkillsCountOutputType = {
    character_skills: number
    character_specialties: number
  }

  export type SkillsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character_skills?: boolean | SkillsCountOutputTypeCountCharacter_skillsArgs
    character_specialties?: boolean | SkillsCountOutputTypeCountCharacter_specialtiesArgs
  }

  // Custom InputTypes
  /**
   * SkillsCountOutputType without action
   */
  export type SkillsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillsCountOutputType
     */
    select?: SkillsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SkillsCountOutputType without action
   */
  export type SkillsCountOutputTypeCountCharacter_skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: character_skillsWhereInput
  }

  /**
   * SkillsCountOutputType without action
   */
  export type SkillsCountOutputTypeCountCharacter_specialtiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: character_specialtiesWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    char_groups: number
    characters: number
    chronicles: number
    exp_logs: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    char_groups?: boolean | UsersCountOutputTypeCountChar_groupsArgs
    characters?: boolean | UsersCountOutputTypeCountCharactersArgs
    chronicles?: boolean | UsersCountOutputTypeCountChroniclesArgs
    exp_logs?: boolean | UsersCountOutputTypeCountExp_logsArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountChar_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: char_groupsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountCharactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: charactersWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountChroniclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chroniclesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountExp_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: exp_logsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model advantages
   */

  export type AggregateAdvantages = {
    _count: AdvantagesCountAggregateOutputType | null
    _avg: AdvantagesAvgAggregateOutputType | null
    _sum: AdvantagesSumAggregateOutputType | null
    _min: AdvantagesMinAggregateOutputType | null
    _max: AdvantagesMaxAggregateOutputType | null
  }

  export type AdvantagesAvgAggregateOutputType = {
    level: number | null
  }

  export type AdvantagesSumAggregateOutputType = {
    level: number | null
  }

  export type AdvantagesMinAggregateOutputType = {
    id: string | null
    parent_name: string | null
    name: string | null
    description: string | null
    type: $Enums.type | null
    level: number | null
    for: $Enums.forWhom | null
    clan_req: string | null
    sect_req: string | null
  }

  export type AdvantagesMaxAggregateOutputType = {
    id: string | null
    parent_name: string | null
    name: string | null
    description: string | null
    type: $Enums.type | null
    level: number | null
    for: $Enums.forWhom | null
    clan_req: string | null
    sect_req: string | null
  }

  export type AdvantagesCountAggregateOutputType = {
    id: number
    parent_name: number
    name: number
    description: number
    type: number
    level: number
    for: number
    clan_req: number
    sect_req: number
    _all: number
  }


  export type AdvantagesAvgAggregateInputType = {
    level?: true
  }

  export type AdvantagesSumAggregateInputType = {
    level?: true
  }

  export type AdvantagesMinAggregateInputType = {
    id?: true
    parent_name?: true
    name?: true
    description?: true
    type?: true
    level?: true
    for?: true
    clan_req?: true
    sect_req?: true
  }

  export type AdvantagesMaxAggregateInputType = {
    id?: true
    parent_name?: true
    name?: true
    description?: true
    type?: true
    level?: true
    for?: true
    clan_req?: true
    sect_req?: true
  }

  export type AdvantagesCountAggregateInputType = {
    id?: true
    parent_name?: true
    name?: true
    description?: true
    type?: true
    level?: true
    for?: true
    clan_req?: true
    sect_req?: true
    _all?: true
  }

  export type AdvantagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which advantages to aggregate.
     */
    where?: advantagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of advantages to fetch.
     */
    orderBy?: advantagesOrderByWithRelationInput | advantagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: advantagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` advantages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` advantages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned advantages
    **/
    _count?: true | AdvantagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdvantagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdvantagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdvantagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdvantagesMaxAggregateInputType
  }

  export type GetAdvantagesAggregateType<T extends AdvantagesAggregateArgs> = {
        [P in keyof T & keyof AggregateAdvantages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdvantages[P]>
      : GetScalarType<T[P], AggregateAdvantages[P]>
  }




  export type advantagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: advantagesWhereInput
    orderBy?: advantagesOrderByWithAggregationInput | advantagesOrderByWithAggregationInput[]
    by: AdvantagesScalarFieldEnum[] | AdvantagesScalarFieldEnum
    having?: advantagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdvantagesCountAggregateInputType | true
    _avg?: AdvantagesAvgAggregateInputType
    _sum?: AdvantagesSumAggregateInputType
    _min?: AdvantagesMinAggregateInputType
    _max?: AdvantagesMaxAggregateInputType
  }

  export type AdvantagesGroupByOutputType = {
    id: string
    parent_name: string | null
    name: string
    description: string
    type: $Enums.type
    level: number
    for: $Enums.forWhom
    clan_req: string | null
    sect_req: string | null
    _count: AdvantagesCountAggregateOutputType | null
    _avg: AdvantagesAvgAggregateOutputType | null
    _sum: AdvantagesSumAggregateOutputType | null
    _min: AdvantagesMinAggregateOutputType | null
    _max: AdvantagesMaxAggregateOutputType | null
  }

  type GetAdvantagesGroupByPayload<T extends advantagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdvantagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdvantagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdvantagesGroupByOutputType[P]>
            : GetScalarType<T[P], AdvantagesGroupByOutputType[P]>
        }
      >
    >


  export type advantagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parent_name?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    level?: boolean
    for?: boolean
    clan_req?: boolean
    sect_req?: boolean
    clans?: boolean | advantages$clansArgs<ExtArgs>
    sects?: boolean | advantages$sectsArgs<ExtArgs>
    character_advantages?: boolean | advantages$character_advantagesArgs<ExtArgs>
    _count?: boolean | AdvantagesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["advantages"]>

  export type advantagesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parent_name?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    level?: boolean
    for?: boolean
    clan_req?: boolean
    sect_req?: boolean
    clans?: boolean | advantages$clansArgs<ExtArgs>
    sects?: boolean | advantages$sectsArgs<ExtArgs>
  }, ExtArgs["result"]["advantages"]>

  export type advantagesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parent_name?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    level?: boolean
    for?: boolean
    clan_req?: boolean
    sect_req?: boolean
    clans?: boolean | advantages$clansArgs<ExtArgs>
    sects?: boolean | advantages$sectsArgs<ExtArgs>
  }, ExtArgs["result"]["advantages"]>

  export type advantagesSelectScalar = {
    id?: boolean
    parent_name?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    level?: boolean
    for?: boolean
    clan_req?: boolean
    sect_req?: boolean
  }

  export type advantagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "parent_name" | "name" | "description" | "type" | "level" | "for" | "clan_req" | "sect_req", ExtArgs["result"]["advantages"]>
  export type advantagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clans?: boolean | advantages$clansArgs<ExtArgs>
    sects?: boolean | advantages$sectsArgs<ExtArgs>
    character_advantages?: boolean | advantages$character_advantagesArgs<ExtArgs>
    _count?: boolean | AdvantagesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type advantagesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clans?: boolean | advantages$clansArgs<ExtArgs>
    sects?: boolean | advantages$sectsArgs<ExtArgs>
  }
  export type advantagesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clans?: boolean | advantages$clansArgs<ExtArgs>
    sects?: boolean | advantages$sectsArgs<ExtArgs>
  }

  export type $advantagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "advantages"
    objects: {
      clans: Prisma.$clansPayload<ExtArgs> | null
      sects: Prisma.$sectsPayload<ExtArgs> | null
      character_advantages: Prisma.$character_advantagesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      parent_name: string | null
      name: string
      description: string
      type: $Enums.type
      level: number
      for: $Enums.forWhom
      clan_req: string | null
      sect_req: string | null
    }, ExtArgs["result"]["advantages"]>
    composites: {}
  }

  type advantagesGetPayload<S extends boolean | null | undefined | advantagesDefaultArgs> = $Result.GetResult<Prisma.$advantagesPayload, S>

  type advantagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<advantagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdvantagesCountAggregateInputType | true
    }

  export interface advantagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['advantages'], meta: { name: 'advantages' } }
    /**
     * Find zero or one Advantages that matches the filter.
     * @param {advantagesFindUniqueArgs} args - Arguments to find a Advantages
     * @example
     * // Get one Advantages
     * const advantages = await prisma.advantages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends advantagesFindUniqueArgs>(args: SelectSubset<T, advantagesFindUniqueArgs<ExtArgs>>): Prisma__advantagesClient<$Result.GetResult<Prisma.$advantagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Advantages that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {advantagesFindUniqueOrThrowArgs} args - Arguments to find a Advantages
     * @example
     * // Get one Advantages
     * const advantages = await prisma.advantages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends advantagesFindUniqueOrThrowArgs>(args: SelectSubset<T, advantagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__advantagesClient<$Result.GetResult<Prisma.$advantagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Advantages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {advantagesFindFirstArgs} args - Arguments to find a Advantages
     * @example
     * // Get one Advantages
     * const advantages = await prisma.advantages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends advantagesFindFirstArgs>(args?: SelectSubset<T, advantagesFindFirstArgs<ExtArgs>>): Prisma__advantagesClient<$Result.GetResult<Prisma.$advantagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Advantages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {advantagesFindFirstOrThrowArgs} args - Arguments to find a Advantages
     * @example
     * // Get one Advantages
     * const advantages = await prisma.advantages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends advantagesFindFirstOrThrowArgs>(args?: SelectSubset<T, advantagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__advantagesClient<$Result.GetResult<Prisma.$advantagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Advantages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {advantagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Advantages
     * const advantages = await prisma.advantages.findMany()
     * 
     * // Get first 10 Advantages
     * const advantages = await prisma.advantages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const advantagesWithIdOnly = await prisma.advantages.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends advantagesFindManyArgs>(args?: SelectSubset<T, advantagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$advantagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Advantages.
     * @param {advantagesCreateArgs} args - Arguments to create a Advantages.
     * @example
     * // Create one Advantages
     * const Advantages = await prisma.advantages.create({
     *   data: {
     *     // ... data to create a Advantages
     *   }
     * })
     * 
     */
    create<T extends advantagesCreateArgs>(args: SelectSubset<T, advantagesCreateArgs<ExtArgs>>): Prisma__advantagesClient<$Result.GetResult<Prisma.$advantagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Advantages.
     * @param {advantagesCreateManyArgs} args - Arguments to create many Advantages.
     * @example
     * // Create many Advantages
     * const advantages = await prisma.advantages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends advantagesCreateManyArgs>(args?: SelectSubset<T, advantagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Advantages and returns the data saved in the database.
     * @param {advantagesCreateManyAndReturnArgs} args - Arguments to create many Advantages.
     * @example
     * // Create many Advantages
     * const advantages = await prisma.advantages.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Advantages and only return the `id`
     * const advantagesWithIdOnly = await prisma.advantages.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends advantagesCreateManyAndReturnArgs>(args?: SelectSubset<T, advantagesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$advantagesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Advantages.
     * @param {advantagesDeleteArgs} args - Arguments to delete one Advantages.
     * @example
     * // Delete one Advantages
     * const Advantages = await prisma.advantages.delete({
     *   where: {
     *     // ... filter to delete one Advantages
     *   }
     * })
     * 
     */
    delete<T extends advantagesDeleteArgs>(args: SelectSubset<T, advantagesDeleteArgs<ExtArgs>>): Prisma__advantagesClient<$Result.GetResult<Prisma.$advantagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Advantages.
     * @param {advantagesUpdateArgs} args - Arguments to update one Advantages.
     * @example
     * // Update one Advantages
     * const advantages = await prisma.advantages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends advantagesUpdateArgs>(args: SelectSubset<T, advantagesUpdateArgs<ExtArgs>>): Prisma__advantagesClient<$Result.GetResult<Prisma.$advantagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Advantages.
     * @param {advantagesDeleteManyArgs} args - Arguments to filter Advantages to delete.
     * @example
     * // Delete a few Advantages
     * const { count } = await prisma.advantages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends advantagesDeleteManyArgs>(args?: SelectSubset<T, advantagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Advantages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {advantagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Advantages
     * const advantages = await prisma.advantages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends advantagesUpdateManyArgs>(args: SelectSubset<T, advantagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Advantages and returns the data updated in the database.
     * @param {advantagesUpdateManyAndReturnArgs} args - Arguments to update many Advantages.
     * @example
     * // Update many Advantages
     * const advantages = await prisma.advantages.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Advantages and only return the `id`
     * const advantagesWithIdOnly = await prisma.advantages.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends advantagesUpdateManyAndReturnArgs>(args: SelectSubset<T, advantagesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$advantagesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Advantages.
     * @param {advantagesUpsertArgs} args - Arguments to update or create a Advantages.
     * @example
     * // Update or create a Advantages
     * const advantages = await prisma.advantages.upsert({
     *   create: {
     *     // ... data to create a Advantages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Advantages we want to update
     *   }
     * })
     */
    upsert<T extends advantagesUpsertArgs>(args: SelectSubset<T, advantagesUpsertArgs<ExtArgs>>): Prisma__advantagesClient<$Result.GetResult<Prisma.$advantagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Advantages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {advantagesCountArgs} args - Arguments to filter Advantages to count.
     * @example
     * // Count the number of Advantages
     * const count = await prisma.advantages.count({
     *   where: {
     *     // ... the filter for the Advantages we want to count
     *   }
     * })
    **/
    count<T extends advantagesCountArgs>(
      args?: Subset<T, advantagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdvantagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Advantages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvantagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdvantagesAggregateArgs>(args: Subset<T, AdvantagesAggregateArgs>): Prisma.PrismaPromise<GetAdvantagesAggregateType<T>>

    /**
     * Group by Advantages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {advantagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends advantagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: advantagesGroupByArgs['orderBy'] }
        : { orderBy?: advantagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, advantagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdvantagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the advantages model
   */
  readonly fields: advantagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for advantages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__advantagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clans<T extends advantages$clansArgs<ExtArgs> = {}>(args?: Subset<T, advantages$clansArgs<ExtArgs>>): Prisma__clansClient<$Result.GetResult<Prisma.$clansPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sects<T extends advantages$sectsArgs<ExtArgs> = {}>(args?: Subset<T, advantages$sectsArgs<ExtArgs>>): Prisma__sectsClient<$Result.GetResult<Prisma.$sectsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    character_advantages<T extends advantages$character_advantagesArgs<ExtArgs> = {}>(args?: Subset<T, advantages$character_advantagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_advantagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the advantages model
   */
  interface advantagesFieldRefs {
    readonly id: FieldRef<"advantages", 'String'>
    readonly parent_name: FieldRef<"advantages", 'String'>
    readonly name: FieldRef<"advantages", 'String'>
    readonly description: FieldRef<"advantages", 'String'>
    readonly type: FieldRef<"advantages", 'type'>
    readonly level: FieldRef<"advantages", 'Int'>
    readonly for: FieldRef<"advantages", 'forWhom'>
    readonly clan_req: FieldRef<"advantages", 'String'>
    readonly sect_req: FieldRef<"advantages", 'String'>
  }
    

  // Custom InputTypes
  /**
   * advantages findUnique
   */
  export type advantagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the advantages
     */
    select?: advantagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the advantages
     */
    omit?: advantagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: advantagesInclude<ExtArgs> | null
    /**
     * Filter, which advantages to fetch.
     */
    where: advantagesWhereUniqueInput
  }

  /**
   * advantages findUniqueOrThrow
   */
  export type advantagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the advantages
     */
    select?: advantagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the advantages
     */
    omit?: advantagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: advantagesInclude<ExtArgs> | null
    /**
     * Filter, which advantages to fetch.
     */
    where: advantagesWhereUniqueInput
  }

  /**
   * advantages findFirst
   */
  export type advantagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the advantages
     */
    select?: advantagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the advantages
     */
    omit?: advantagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: advantagesInclude<ExtArgs> | null
    /**
     * Filter, which advantages to fetch.
     */
    where?: advantagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of advantages to fetch.
     */
    orderBy?: advantagesOrderByWithRelationInput | advantagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for advantages.
     */
    cursor?: advantagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` advantages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` advantages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of advantages.
     */
    distinct?: AdvantagesScalarFieldEnum | AdvantagesScalarFieldEnum[]
  }

  /**
   * advantages findFirstOrThrow
   */
  export type advantagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the advantages
     */
    select?: advantagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the advantages
     */
    omit?: advantagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: advantagesInclude<ExtArgs> | null
    /**
     * Filter, which advantages to fetch.
     */
    where?: advantagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of advantages to fetch.
     */
    orderBy?: advantagesOrderByWithRelationInput | advantagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for advantages.
     */
    cursor?: advantagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` advantages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` advantages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of advantages.
     */
    distinct?: AdvantagesScalarFieldEnum | AdvantagesScalarFieldEnum[]
  }

  /**
   * advantages findMany
   */
  export type advantagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the advantages
     */
    select?: advantagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the advantages
     */
    omit?: advantagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: advantagesInclude<ExtArgs> | null
    /**
     * Filter, which advantages to fetch.
     */
    where?: advantagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of advantages to fetch.
     */
    orderBy?: advantagesOrderByWithRelationInput | advantagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing advantages.
     */
    cursor?: advantagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` advantages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` advantages.
     */
    skip?: number
    distinct?: AdvantagesScalarFieldEnum | AdvantagesScalarFieldEnum[]
  }

  /**
   * advantages create
   */
  export type advantagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the advantages
     */
    select?: advantagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the advantages
     */
    omit?: advantagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: advantagesInclude<ExtArgs> | null
    /**
     * The data needed to create a advantages.
     */
    data: XOR<advantagesCreateInput, advantagesUncheckedCreateInput>
  }

  /**
   * advantages createMany
   */
  export type advantagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many advantages.
     */
    data: advantagesCreateManyInput | advantagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * advantages createManyAndReturn
   */
  export type advantagesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the advantages
     */
    select?: advantagesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the advantages
     */
    omit?: advantagesOmit<ExtArgs> | null
    /**
     * The data used to create many advantages.
     */
    data: advantagesCreateManyInput | advantagesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: advantagesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * advantages update
   */
  export type advantagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the advantages
     */
    select?: advantagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the advantages
     */
    omit?: advantagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: advantagesInclude<ExtArgs> | null
    /**
     * The data needed to update a advantages.
     */
    data: XOR<advantagesUpdateInput, advantagesUncheckedUpdateInput>
    /**
     * Choose, which advantages to update.
     */
    where: advantagesWhereUniqueInput
  }

  /**
   * advantages updateMany
   */
  export type advantagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update advantages.
     */
    data: XOR<advantagesUpdateManyMutationInput, advantagesUncheckedUpdateManyInput>
    /**
     * Filter which advantages to update
     */
    where?: advantagesWhereInput
    /**
     * Limit how many advantages to update.
     */
    limit?: number
  }

  /**
   * advantages updateManyAndReturn
   */
  export type advantagesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the advantages
     */
    select?: advantagesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the advantages
     */
    omit?: advantagesOmit<ExtArgs> | null
    /**
     * The data used to update advantages.
     */
    data: XOR<advantagesUpdateManyMutationInput, advantagesUncheckedUpdateManyInput>
    /**
     * Filter which advantages to update
     */
    where?: advantagesWhereInput
    /**
     * Limit how many advantages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: advantagesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * advantages upsert
   */
  export type advantagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the advantages
     */
    select?: advantagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the advantages
     */
    omit?: advantagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: advantagesInclude<ExtArgs> | null
    /**
     * The filter to search for the advantages to update in case it exists.
     */
    where: advantagesWhereUniqueInput
    /**
     * In case the advantages found by the `where` argument doesn't exist, create a new advantages with this data.
     */
    create: XOR<advantagesCreateInput, advantagesUncheckedCreateInput>
    /**
     * In case the advantages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<advantagesUpdateInput, advantagesUncheckedUpdateInput>
  }

  /**
   * advantages delete
   */
  export type advantagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the advantages
     */
    select?: advantagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the advantages
     */
    omit?: advantagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: advantagesInclude<ExtArgs> | null
    /**
     * Filter which advantages to delete.
     */
    where: advantagesWhereUniqueInput
  }

  /**
   * advantages deleteMany
   */
  export type advantagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which advantages to delete
     */
    where?: advantagesWhereInput
    /**
     * Limit how many advantages to delete.
     */
    limit?: number
  }

  /**
   * advantages.clans
   */
  export type advantages$clansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clans
     */
    select?: clansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clans
     */
    omit?: clansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clansInclude<ExtArgs> | null
    where?: clansWhereInput
  }

  /**
   * advantages.sects
   */
  export type advantages$sectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sects
     */
    select?: sectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sects
     */
    omit?: sectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectsInclude<ExtArgs> | null
    where?: sectsWhereInput
  }

  /**
   * advantages.character_advantages
   */
  export type advantages$character_advantagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_advantages
     */
    select?: character_advantagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_advantages
     */
    omit?: character_advantagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_advantagesInclude<ExtArgs> | null
    where?: character_advantagesWhereInput
    orderBy?: character_advantagesOrderByWithRelationInput | character_advantagesOrderByWithRelationInput[]
    cursor?: character_advantagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Character_advantagesScalarFieldEnum | Character_advantagesScalarFieldEnum[]
  }

  /**
   * advantages without action
   */
  export type advantagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the advantages
     */
    select?: advantagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the advantages
     */
    omit?: advantagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: advantagesInclude<ExtArgs> | null
  }


  /**
   * Model alchemy_powers
   */

  export type AggregateAlchemy_powers = {
    _count: Alchemy_powersCountAggregateOutputType | null
    _avg: Alchemy_powersAvgAggregateOutputType | null
    _sum: Alchemy_powersSumAggregateOutputType | null
    _min: Alchemy_powersMinAggregateOutputType | null
    _max: Alchemy_powersMaxAggregateOutputType | null
  }

  export type Alchemy_powersAvgAggregateOutputType = {
    level: number | null
  }

  export type Alchemy_powersSumAggregateOutputType = {
    level: number | null
  }

  export type Alchemy_powersMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    ingridients: string | null
    activation: string | null
    dice_pool: string | null
    system: string | null
    duration: string | null
    level: number | null
  }

  export type Alchemy_powersMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    ingridients: string | null
    activation: string | null
    dice_pool: string | null
    system: string | null
    duration: string | null
    level: number | null
  }

  export type Alchemy_powersCountAggregateOutputType = {
    id: number
    name: number
    description: number
    ingridients: number
    activation: number
    dice_pool: number
    system: number
    duration: number
    level: number
    _all: number
  }


  export type Alchemy_powersAvgAggregateInputType = {
    level?: true
  }

  export type Alchemy_powersSumAggregateInputType = {
    level?: true
  }

  export type Alchemy_powersMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    ingridients?: true
    activation?: true
    dice_pool?: true
    system?: true
    duration?: true
    level?: true
  }

  export type Alchemy_powersMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    ingridients?: true
    activation?: true
    dice_pool?: true
    system?: true
    duration?: true
    level?: true
  }

  export type Alchemy_powersCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    ingridients?: true
    activation?: true
    dice_pool?: true
    system?: true
    duration?: true
    level?: true
    _all?: true
  }

  export type Alchemy_powersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which alchemy_powers to aggregate.
     */
    where?: alchemy_powersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alchemy_powers to fetch.
     */
    orderBy?: alchemy_powersOrderByWithRelationInput | alchemy_powersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: alchemy_powersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alchemy_powers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alchemy_powers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned alchemy_powers
    **/
    _count?: true | Alchemy_powersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Alchemy_powersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Alchemy_powersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Alchemy_powersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Alchemy_powersMaxAggregateInputType
  }

  export type GetAlchemy_powersAggregateType<T extends Alchemy_powersAggregateArgs> = {
        [P in keyof T & keyof AggregateAlchemy_powers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlchemy_powers[P]>
      : GetScalarType<T[P], AggregateAlchemy_powers[P]>
  }




  export type alchemy_powersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: alchemy_powersWhereInput
    orderBy?: alchemy_powersOrderByWithAggregationInput | alchemy_powersOrderByWithAggregationInput[]
    by: Alchemy_powersScalarFieldEnum[] | Alchemy_powersScalarFieldEnum
    having?: alchemy_powersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Alchemy_powersCountAggregateInputType | true
    _avg?: Alchemy_powersAvgAggregateInputType
    _sum?: Alchemy_powersSumAggregateInputType
    _min?: Alchemy_powersMinAggregateInputType
    _max?: Alchemy_powersMaxAggregateInputType
  }

  export type Alchemy_powersGroupByOutputType = {
    id: string
    name: string
    description: string | null
    ingridients: string | null
    activation: string | null
    dice_pool: string | null
    system: string | null
    duration: string | null
    level: number | null
    _count: Alchemy_powersCountAggregateOutputType | null
    _avg: Alchemy_powersAvgAggregateOutputType | null
    _sum: Alchemy_powersSumAggregateOutputType | null
    _min: Alchemy_powersMinAggregateOutputType | null
    _max: Alchemy_powersMaxAggregateOutputType | null
  }

  type GetAlchemy_powersGroupByPayload<T extends alchemy_powersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Alchemy_powersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Alchemy_powersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Alchemy_powersGroupByOutputType[P]>
            : GetScalarType<T[P], Alchemy_powersGroupByOutputType[P]>
        }
      >
    >


  export type alchemy_powersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    ingridients?: boolean
    activation?: boolean
    dice_pool?: boolean
    system?: boolean
    duration?: boolean
    level?: boolean
    character_alchemy_powers?: boolean | alchemy_powers$character_alchemy_powersArgs<ExtArgs>
    _count?: boolean | Alchemy_powersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alchemy_powers"]>

  export type alchemy_powersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    ingridients?: boolean
    activation?: boolean
    dice_pool?: boolean
    system?: boolean
    duration?: boolean
    level?: boolean
  }, ExtArgs["result"]["alchemy_powers"]>

  export type alchemy_powersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    ingridients?: boolean
    activation?: boolean
    dice_pool?: boolean
    system?: boolean
    duration?: boolean
    level?: boolean
  }, ExtArgs["result"]["alchemy_powers"]>

  export type alchemy_powersSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    ingridients?: boolean
    activation?: boolean
    dice_pool?: boolean
    system?: boolean
    duration?: boolean
    level?: boolean
  }

  export type alchemy_powersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "ingridients" | "activation" | "dice_pool" | "system" | "duration" | "level", ExtArgs["result"]["alchemy_powers"]>
  export type alchemy_powersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character_alchemy_powers?: boolean | alchemy_powers$character_alchemy_powersArgs<ExtArgs>
    _count?: boolean | Alchemy_powersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type alchemy_powersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type alchemy_powersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $alchemy_powersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "alchemy_powers"
    objects: {
      character_alchemy_powers: Prisma.$character_alchemy_powersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      ingridients: string | null
      activation: string | null
      dice_pool: string | null
      system: string | null
      duration: string | null
      level: number | null
    }, ExtArgs["result"]["alchemy_powers"]>
    composites: {}
  }

  type alchemy_powersGetPayload<S extends boolean | null | undefined | alchemy_powersDefaultArgs> = $Result.GetResult<Prisma.$alchemy_powersPayload, S>

  type alchemy_powersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<alchemy_powersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Alchemy_powersCountAggregateInputType | true
    }

  export interface alchemy_powersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['alchemy_powers'], meta: { name: 'alchemy_powers' } }
    /**
     * Find zero or one Alchemy_powers that matches the filter.
     * @param {alchemy_powersFindUniqueArgs} args - Arguments to find a Alchemy_powers
     * @example
     * // Get one Alchemy_powers
     * const alchemy_powers = await prisma.alchemy_powers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends alchemy_powersFindUniqueArgs>(args: SelectSubset<T, alchemy_powersFindUniqueArgs<ExtArgs>>): Prisma__alchemy_powersClient<$Result.GetResult<Prisma.$alchemy_powersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Alchemy_powers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {alchemy_powersFindUniqueOrThrowArgs} args - Arguments to find a Alchemy_powers
     * @example
     * // Get one Alchemy_powers
     * const alchemy_powers = await prisma.alchemy_powers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends alchemy_powersFindUniqueOrThrowArgs>(args: SelectSubset<T, alchemy_powersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__alchemy_powersClient<$Result.GetResult<Prisma.$alchemy_powersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Alchemy_powers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alchemy_powersFindFirstArgs} args - Arguments to find a Alchemy_powers
     * @example
     * // Get one Alchemy_powers
     * const alchemy_powers = await prisma.alchemy_powers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends alchemy_powersFindFirstArgs>(args?: SelectSubset<T, alchemy_powersFindFirstArgs<ExtArgs>>): Prisma__alchemy_powersClient<$Result.GetResult<Prisma.$alchemy_powersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Alchemy_powers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alchemy_powersFindFirstOrThrowArgs} args - Arguments to find a Alchemy_powers
     * @example
     * // Get one Alchemy_powers
     * const alchemy_powers = await prisma.alchemy_powers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends alchemy_powersFindFirstOrThrowArgs>(args?: SelectSubset<T, alchemy_powersFindFirstOrThrowArgs<ExtArgs>>): Prisma__alchemy_powersClient<$Result.GetResult<Prisma.$alchemy_powersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Alchemy_powers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alchemy_powersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alchemy_powers
     * const alchemy_powers = await prisma.alchemy_powers.findMany()
     * 
     * // Get first 10 Alchemy_powers
     * const alchemy_powers = await prisma.alchemy_powers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alchemy_powersWithIdOnly = await prisma.alchemy_powers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends alchemy_powersFindManyArgs>(args?: SelectSubset<T, alchemy_powersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$alchemy_powersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Alchemy_powers.
     * @param {alchemy_powersCreateArgs} args - Arguments to create a Alchemy_powers.
     * @example
     * // Create one Alchemy_powers
     * const Alchemy_powers = await prisma.alchemy_powers.create({
     *   data: {
     *     // ... data to create a Alchemy_powers
     *   }
     * })
     * 
     */
    create<T extends alchemy_powersCreateArgs>(args: SelectSubset<T, alchemy_powersCreateArgs<ExtArgs>>): Prisma__alchemy_powersClient<$Result.GetResult<Prisma.$alchemy_powersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Alchemy_powers.
     * @param {alchemy_powersCreateManyArgs} args - Arguments to create many Alchemy_powers.
     * @example
     * // Create many Alchemy_powers
     * const alchemy_powers = await prisma.alchemy_powers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends alchemy_powersCreateManyArgs>(args?: SelectSubset<T, alchemy_powersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Alchemy_powers and returns the data saved in the database.
     * @param {alchemy_powersCreateManyAndReturnArgs} args - Arguments to create many Alchemy_powers.
     * @example
     * // Create many Alchemy_powers
     * const alchemy_powers = await prisma.alchemy_powers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Alchemy_powers and only return the `id`
     * const alchemy_powersWithIdOnly = await prisma.alchemy_powers.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends alchemy_powersCreateManyAndReturnArgs>(args?: SelectSubset<T, alchemy_powersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$alchemy_powersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Alchemy_powers.
     * @param {alchemy_powersDeleteArgs} args - Arguments to delete one Alchemy_powers.
     * @example
     * // Delete one Alchemy_powers
     * const Alchemy_powers = await prisma.alchemy_powers.delete({
     *   where: {
     *     // ... filter to delete one Alchemy_powers
     *   }
     * })
     * 
     */
    delete<T extends alchemy_powersDeleteArgs>(args: SelectSubset<T, alchemy_powersDeleteArgs<ExtArgs>>): Prisma__alchemy_powersClient<$Result.GetResult<Prisma.$alchemy_powersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Alchemy_powers.
     * @param {alchemy_powersUpdateArgs} args - Arguments to update one Alchemy_powers.
     * @example
     * // Update one Alchemy_powers
     * const alchemy_powers = await prisma.alchemy_powers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends alchemy_powersUpdateArgs>(args: SelectSubset<T, alchemy_powersUpdateArgs<ExtArgs>>): Prisma__alchemy_powersClient<$Result.GetResult<Prisma.$alchemy_powersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Alchemy_powers.
     * @param {alchemy_powersDeleteManyArgs} args - Arguments to filter Alchemy_powers to delete.
     * @example
     * // Delete a few Alchemy_powers
     * const { count } = await prisma.alchemy_powers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends alchemy_powersDeleteManyArgs>(args?: SelectSubset<T, alchemy_powersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alchemy_powers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alchemy_powersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alchemy_powers
     * const alchemy_powers = await prisma.alchemy_powers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends alchemy_powersUpdateManyArgs>(args: SelectSubset<T, alchemy_powersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alchemy_powers and returns the data updated in the database.
     * @param {alchemy_powersUpdateManyAndReturnArgs} args - Arguments to update many Alchemy_powers.
     * @example
     * // Update many Alchemy_powers
     * const alchemy_powers = await prisma.alchemy_powers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Alchemy_powers and only return the `id`
     * const alchemy_powersWithIdOnly = await prisma.alchemy_powers.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends alchemy_powersUpdateManyAndReturnArgs>(args: SelectSubset<T, alchemy_powersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$alchemy_powersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Alchemy_powers.
     * @param {alchemy_powersUpsertArgs} args - Arguments to update or create a Alchemy_powers.
     * @example
     * // Update or create a Alchemy_powers
     * const alchemy_powers = await prisma.alchemy_powers.upsert({
     *   create: {
     *     // ... data to create a Alchemy_powers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alchemy_powers we want to update
     *   }
     * })
     */
    upsert<T extends alchemy_powersUpsertArgs>(args: SelectSubset<T, alchemy_powersUpsertArgs<ExtArgs>>): Prisma__alchemy_powersClient<$Result.GetResult<Prisma.$alchemy_powersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Alchemy_powers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alchemy_powersCountArgs} args - Arguments to filter Alchemy_powers to count.
     * @example
     * // Count the number of Alchemy_powers
     * const count = await prisma.alchemy_powers.count({
     *   where: {
     *     // ... the filter for the Alchemy_powers we want to count
     *   }
     * })
    **/
    count<T extends alchemy_powersCountArgs>(
      args?: Subset<T, alchemy_powersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Alchemy_powersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alchemy_powers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Alchemy_powersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Alchemy_powersAggregateArgs>(args: Subset<T, Alchemy_powersAggregateArgs>): Prisma.PrismaPromise<GetAlchemy_powersAggregateType<T>>

    /**
     * Group by Alchemy_powers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alchemy_powersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends alchemy_powersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: alchemy_powersGroupByArgs['orderBy'] }
        : { orderBy?: alchemy_powersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, alchemy_powersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlchemy_powersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the alchemy_powers model
   */
  readonly fields: alchemy_powersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for alchemy_powers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__alchemy_powersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    character_alchemy_powers<T extends alchemy_powers$character_alchemy_powersArgs<ExtArgs> = {}>(args?: Subset<T, alchemy_powers$character_alchemy_powersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_alchemy_powersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the alchemy_powers model
   */
  interface alchemy_powersFieldRefs {
    readonly id: FieldRef<"alchemy_powers", 'String'>
    readonly name: FieldRef<"alchemy_powers", 'String'>
    readonly description: FieldRef<"alchemy_powers", 'String'>
    readonly ingridients: FieldRef<"alchemy_powers", 'String'>
    readonly activation: FieldRef<"alchemy_powers", 'String'>
    readonly dice_pool: FieldRef<"alchemy_powers", 'String'>
    readonly system: FieldRef<"alchemy_powers", 'String'>
    readonly duration: FieldRef<"alchemy_powers", 'String'>
    readonly level: FieldRef<"alchemy_powers", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * alchemy_powers findUnique
   */
  export type alchemy_powersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alchemy_powers
     */
    select?: alchemy_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the alchemy_powers
     */
    omit?: alchemy_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alchemy_powersInclude<ExtArgs> | null
    /**
     * Filter, which alchemy_powers to fetch.
     */
    where: alchemy_powersWhereUniqueInput
  }

  /**
   * alchemy_powers findUniqueOrThrow
   */
  export type alchemy_powersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alchemy_powers
     */
    select?: alchemy_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the alchemy_powers
     */
    omit?: alchemy_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alchemy_powersInclude<ExtArgs> | null
    /**
     * Filter, which alchemy_powers to fetch.
     */
    where: alchemy_powersWhereUniqueInput
  }

  /**
   * alchemy_powers findFirst
   */
  export type alchemy_powersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alchemy_powers
     */
    select?: alchemy_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the alchemy_powers
     */
    omit?: alchemy_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alchemy_powersInclude<ExtArgs> | null
    /**
     * Filter, which alchemy_powers to fetch.
     */
    where?: alchemy_powersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alchemy_powers to fetch.
     */
    orderBy?: alchemy_powersOrderByWithRelationInput | alchemy_powersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for alchemy_powers.
     */
    cursor?: alchemy_powersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alchemy_powers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alchemy_powers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of alchemy_powers.
     */
    distinct?: Alchemy_powersScalarFieldEnum | Alchemy_powersScalarFieldEnum[]
  }

  /**
   * alchemy_powers findFirstOrThrow
   */
  export type alchemy_powersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alchemy_powers
     */
    select?: alchemy_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the alchemy_powers
     */
    omit?: alchemy_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alchemy_powersInclude<ExtArgs> | null
    /**
     * Filter, which alchemy_powers to fetch.
     */
    where?: alchemy_powersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alchemy_powers to fetch.
     */
    orderBy?: alchemy_powersOrderByWithRelationInput | alchemy_powersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for alchemy_powers.
     */
    cursor?: alchemy_powersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alchemy_powers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alchemy_powers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of alchemy_powers.
     */
    distinct?: Alchemy_powersScalarFieldEnum | Alchemy_powersScalarFieldEnum[]
  }

  /**
   * alchemy_powers findMany
   */
  export type alchemy_powersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alchemy_powers
     */
    select?: alchemy_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the alchemy_powers
     */
    omit?: alchemy_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alchemy_powersInclude<ExtArgs> | null
    /**
     * Filter, which alchemy_powers to fetch.
     */
    where?: alchemy_powersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alchemy_powers to fetch.
     */
    orderBy?: alchemy_powersOrderByWithRelationInput | alchemy_powersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing alchemy_powers.
     */
    cursor?: alchemy_powersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alchemy_powers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alchemy_powers.
     */
    skip?: number
    distinct?: Alchemy_powersScalarFieldEnum | Alchemy_powersScalarFieldEnum[]
  }

  /**
   * alchemy_powers create
   */
  export type alchemy_powersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alchemy_powers
     */
    select?: alchemy_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the alchemy_powers
     */
    omit?: alchemy_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alchemy_powersInclude<ExtArgs> | null
    /**
     * The data needed to create a alchemy_powers.
     */
    data: XOR<alchemy_powersCreateInput, alchemy_powersUncheckedCreateInput>
  }

  /**
   * alchemy_powers createMany
   */
  export type alchemy_powersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many alchemy_powers.
     */
    data: alchemy_powersCreateManyInput | alchemy_powersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * alchemy_powers createManyAndReturn
   */
  export type alchemy_powersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alchemy_powers
     */
    select?: alchemy_powersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the alchemy_powers
     */
    omit?: alchemy_powersOmit<ExtArgs> | null
    /**
     * The data used to create many alchemy_powers.
     */
    data: alchemy_powersCreateManyInput | alchemy_powersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * alchemy_powers update
   */
  export type alchemy_powersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alchemy_powers
     */
    select?: alchemy_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the alchemy_powers
     */
    omit?: alchemy_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alchemy_powersInclude<ExtArgs> | null
    /**
     * The data needed to update a alchemy_powers.
     */
    data: XOR<alchemy_powersUpdateInput, alchemy_powersUncheckedUpdateInput>
    /**
     * Choose, which alchemy_powers to update.
     */
    where: alchemy_powersWhereUniqueInput
  }

  /**
   * alchemy_powers updateMany
   */
  export type alchemy_powersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update alchemy_powers.
     */
    data: XOR<alchemy_powersUpdateManyMutationInput, alchemy_powersUncheckedUpdateManyInput>
    /**
     * Filter which alchemy_powers to update
     */
    where?: alchemy_powersWhereInput
    /**
     * Limit how many alchemy_powers to update.
     */
    limit?: number
  }

  /**
   * alchemy_powers updateManyAndReturn
   */
  export type alchemy_powersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alchemy_powers
     */
    select?: alchemy_powersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the alchemy_powers
     */
    omit?: alchemy_powersOmit<ExtArgs> | null
    /**
     * The data used to update alchemy_powers.
     */
    data: XOR<alchemy_powersUpdateManyMutationInput, alchemy_powersUncheckedUpdateManyInput>
    /**
     * Filter which alchemy_powers to update
     */
    where?: alchemy_powersWhereInput
    /**
     * Limit how many alchemy_powers to update.
     */
    limit?: number
  }

  /**
   * alchemy_powers upsert
   */
  export type alchemy_powersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alchemy_powers
     */
    select?: alchemy_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the alchemy_powers
     */
    omit?: alchemy_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alchemy_powersInclude<ExtArgs> | null
    /**
     * The filter to search for the alchemy_powers to update in case it exists.
     */
    where: alchemy_powersWhereUniqueInput
    /**
     * In case the alchemy_powers found by the `where` argument doesn't exist, create a new alchemy_powers with this data.
     */
    create: XOR<alchemy_powersCreateInput, alchemy_powersUncheckedCreateInput>
    /**
     * In case the alchemy_powers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<alchemy_powersUpdateInput, alchemy_powersUncheckedUpdateInput>
  }

  /**
   * alchemy_powers delete
   */
  export type alchemy_powersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alchemy_powers
     */
    select?: alchemy_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the alchemy_powers
     */
    omit?: alchemy_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alchemy_powersInclude<ExtArgs> | null
    /**
     * Filter which alchemy_powers to delete.
     */
    where: alchemy_powersWhereUniqueInput
  }

  /**
   * alchemy_powers deleteMany
   */
  export type alchemy_powersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which alchemy_powers to delete
     */
    where?: alchemy_powersWhereInput
    /**
     * Limit how many alchemy_powers to delete.
     */
    limit?: number
  }

  /**
   * alchemy_powers.character_alchemy_powers
   */
  export type alchemy_powers$character_alchemy_powersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_alchemy_powers
     */
    select?: character_alchemy_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_alchemy_powers
     */
    omit?: character_alchemy_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_alchemy_powersInclude<ExtArgs> | null
    where?: character_alchemy_powersWhereInput
    orderBy?: character_alchemy_powersOrderByWithRelationInput | character_alchemy_powersOrderByWithRelationInput[]
    cursor?: character_alchemy_powersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Character_alchemy_powersScalarFieldEnum | Character_alchemy_powersScalarFieldEnum[]
  }

  /**
   * alchemy_powers without action
   */
  export type alchemy_powersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alchemy_powers
     */
    select?: alchemy_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the alchemy_powers
     */
    omit?: alchemy_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alchemy_powersInclude<ExtArgs> | null
  }


  /**
   * Model attributes
   */

  export type AggregateAttributes = {
    _count: AttributesCountAggregateOutputType | null
    _min: AttributesMinAggregateOutputType | null
    _max: AttributesMaxAggregateOutputType | null
  }

  export type AttributesMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: $Enums.category | null
  }

  export type AttributesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: $Enums.category | null
  }

  export type AttributesCountAggregateOutputType = {
    id: number
    name: number
    description: number
    category: number
    _all: number
  }


  export type AttributesMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
  }

  export type AttributesMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
  }

  export type AttributesCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    _all?: true
  }

  export type AttributesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which attributes to aggregate.
     */
    where?: attributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attributes to fetch.
     */
    orderBy?: attributesOrderByWithRelationInput | attributesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: attributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned attributes
    **/
    _count?: true | AttributesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttributesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttributesMaxAggregateInputType
  }

  export type GetAttributesAggregateType<T extends AttributesAggregateArgs> = {
        [P in keyof T & keyof AggregateAttributes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttributes[P]>
      : GetScalarType<T[P], AggregateAttributes[P]>
  }




  export type attributesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: attributesWhereInput
    orderBy?: attributesOrderByWithAggregationInput | attributesOrderByWithAggregationInput[]
    by: AttributesScalarFieldEnum[] | AttributesScalarFieldEnum
    having?: attributesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttributesCountAggregateInputType | true
    _min?: AttributesMinAggregateInputType
    _max?: AttributesMaxAggregateInputType
  }

  export type AttributesGroupByOutputType = {
    id: string
    name: string
    description: string
    category: $Enums.category
    _count: AttributesCountAggregateOutputType | null
    _min: AttributesMinAggregateOutputType | null
    _max: AttributesMaxAggregateOutputType | null
  }

  type GetAttributesGroupByPayload<T extends attributesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttributesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttributesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttributesGroupByOutputType[P]>
            : GetScalarType<T[P], AttributesGroupByOutputType[P]>
        }
      >
    >


  export type attributesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    character_attributes?: boolean | attributes$character_attributesArgs<ExtArgs>
    _count?: boolean | AttributesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attributes"]>

  export type attributesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
  }, ExtArgs["result"]["attributes"]>

  export type attributesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
  }, ExtArgs["result"]["attributes"]>

  export type attributesSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
  }

  export type attributesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "category", ExtArgs["result"]["attributes"]>
  export type attributesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character_attributes?: boolean | attributes$character_attributesArgs<ExtArgs>
    _count?: boolean | AttributesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type attributesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type attributesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $attributesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "attributes"
    objects: {
      character_attributes: Prisma.$character_attributesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      category: $Enums.category
    }, ExtArgs["result"]["attributes"]>
    composites: {}
  }

  type attributesGetPayload<S extends boolean | null | undefined | attributesDefaultArgs> = $Result.GetResult<Prisma.$attributesPayload, S>

  type attributesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<attributesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttributesCountAggregateInputType | true
    }

  export interface attributesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['attributes'], meta: { name: 'attributes' } }
    /**
     * Find zero or one Attributes that matches the filter.
     * @param {attributesFindUniqueArgs} args - Arguments to find a Attributes
     * @example
     * // Get one Attributes
     * const attributes = await prisma.attributes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends attributesFindUniqueArgs>(args: SelectSubset<T, attributesFindUniqueArgs<ExtArgs>>): Prisma__attributesClient<$Result.GetResult<Prisma.$attributesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attributes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {attributesFindUniqueOrThrowArgs} args - Arguments to find a Attributes
     * @example
     * // Get one Attributes
     * const attributes = await prisma.attributes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends attributesFindUniqueOrThrowArgs>(args: SelectSubset<T, attributesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__attributesClient<$Result.GetResult<Prisma.$attributesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attributes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attributesFindFirstArgs} args - Arguments to find a Attributes
     * @example
     * // Get one Attributes
     * const attributes = await prisma.attributes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends attributesFindFirstArgs>(args?: SelectSubset<T, attributesFindFirstArgs<ExtArgs>>): Prisma__attributesClient<$Result.GetResult<Prisma.$attributesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attributes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attributesFindFirstOrThrowArgs} args - Arguments to find a Attributes
     * @example
     * // Get one Attributes
     * const attributes = await prisma.attributes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends attributesFindFirstOrThrowArgs>(args?: SelectSubset<T, attributesFindFirstOrThrowArgs<ExtArgs>>): Prisma__attributesClient<$Result.GetResult<Prisma.$attributesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attributes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attributesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attributes
     * const attributes = await prisma.attributes.findMany()
     * 
     * // Get first 10 Attributes
     * const attributes = await prisma.attributes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attributesWithIdOnly = await prisma.attributes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends attributesFindManyArgs>(args?: SelectSubset<T, attributesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attributesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attributes.
     * @param {attributesCreateArgs} args - Arguments to create a Attributes.
     * @example
     * // Create one Attributes
     * const Attributes = await prisma.attributes.create({
     *   data: {
     *     // ... data to create a Attributes
     *   }
     * })
     * 
     */
    create<T extends attributesCreateArgs>(args: SelectSubset<T, attributesCreateArgs<ExtArgs>>): Prisma__attributesClient<$Result.GetResult<Prisma.$attributesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attributes.
     * @param {attributesCreateManyArgs} args - Arguments to create many Attributes.
     * @example
     * // Create many Attributes
     * const attributes = await prisma.attributes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends attributesCreateManyArgs>(args?: SelectSubset<T, attributesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attributes and returns the data saved in the database.
     * @param {attributesCreateManyAndReturnArgs} args - Arguments to create many Attributes.
     * @example
     * // Create many Attributes
     * const attributes = await prisma.attributes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attributes and only return the `id`
     * const attributesWithIdOnly = await prisma.attributes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends attributesCreateManyAndReturnArgs>(args?: SelectSubset<T, attributesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attributesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Attributes.
     * @param {attributesDeleteArgs} args - Arguments to delete one Attributes.
     * @example
     * // Delete one Attributes
     * const Attributes = await prisma.attributes.delete({
     *   where: {
     *     // ... filter to delete one Attributes
     *   }
     * })
     * 
     */
    delete<T extends attributesDeleteArgs>(args: SelectSubset<T, attributesDeleteArgs<ExtArgs>>): Prisma__attributesClient<$Result.GetResult<Prisma.$attributesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attributes.
     * @param {attributesUpdateArgs} args - Arguments to update one Attributes.
     * @example
     * // Update one Attributes
     * const attributes = await prisma.attributes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends attributesUpdateArgs>(args: SelectSubset<T, attributesUpdateArgs<ExtArgs>>): Prisma__attributesClient<$Result.GetResult<Prisma.$attributesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attributes.
     * @param {attributesDeleteManyArgs} args - Arguments to filter Attributes to delete.
     * @example
     * // Delete a few Attributes
     * const { count } = await prisma.attributes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends attributesDeleteManyArgs>(args?: SelectSubset<T, attributesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attributesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attributes
     * const attributes = await prisma.attributes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends attributesUpdateManyArgs>(args: SelectSubset<T, attributesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attributes and returns the data updated in the database.
     * @param {attributesUpdateManyAndReturnArgs} args - Arguments to update many Attributes.
     * @example
     * // Update many Attributes
     * const attributes = await prisma.attributes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Attributes and only return the `id`
     * const attributesWithIdOnly = await prisma.attributes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends attributesUpdateManyAndReturnArgs>(args: SelectSubset<T, attributesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$attributesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Attributes.
     * @param {attributesUpsertArgs} args - Arguments to update or create a Attributes.
     * @example
     * // Update or create a Attributes
     * const attributes = await prisma.attributes.upsert({
     *   create: {
     *     // ... data to create a Attributes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attributes we want to update
     *   }
     * })
     */
    upsert<T extends attributesUpsertArgs>(args: SelectSubset<T, attributesUpsertArgs<ExtArgs>>): Prisma__attributesClient<$Result.GetResult<Prisma.$attributesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attributesCountArgs} args - Arguments to filter Attributes to count.
     * @example
     * // Count the number of Attributes
     * const count = await prisma.attributes.count({
     *   where: {
     *     // ... the filter for the Attributes we want to count
     *   }
     * })
    **/
    count<T extends attributesCountArgs>(
      args?: Subset<T, attributesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttributesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttributesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttributesAggregateArgs>(args: Subset<T, AttributesAggregateArgs>): Prisma.PrismaPromise<GetAttributesAggregateType<T>>

    /**
     * Group by Attributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {attributesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends attributesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: attributesGroupByArgs['orderBy'] }
        : { orderBy?: attributesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, attributesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttributesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the attributes model
   */
  readonly fields: attributesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for attributes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__attributesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    character_attributes<T extends attributes$character_attributesArgs<ExtArgs> = {}>(args?: Subset<T, attributes$character_attributesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_attributesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the attributes model
   */
  interface attributesFieldRefs {
    readonly id: FieldRef<"attributes", 'String'>
    readonly name: FieldRef<"attributes", 'String'>
    readonly description: FieldRef<"attributes", 'String'>
    readonly category: FieldRef<"attributes", 'category'>
  }
    

  // Custom InputTypes
  /**
   * attributes findUnique
   */
  export type attributesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attributes
     */
    select?: attributesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attributes
     */
    omit?: attributesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attributesInclude<ExtArgs> | null
    /**
     * Filter, which attributes to fetch.
     */
    where: attributesWhereUniqueInput
  }

  /**
   * attributes findUniqueOrThrow
   */
  export type attributesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attributes
     */
    select?: attributesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attributes
     */
    omit?: attributesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attributesInclude<ExtArgs> | null
    /**
     * Filter, which attributes to fetch.
     */
    where: attributesWhereUniqueInput
  }

  /**
   * attributes findFirst
   */
  export type attributesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attributes
     */
    select?: attributesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attributes
     */
    omit?: attributesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attributesInclude<ExtArgs> | null
    /**
     * Filter, which attributes to fetch.
     */
    where?: attributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attributes to fetch.
     */
    orderBy?: attributesOrderByWithRelationInput | attributesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for attributes.
     */
    cursor?: attributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of attributes.
     */
    distinct?: AttributesScalarFieldEnum | AttributesScalarFieldEnum[]
  }

  /**
   * attributes findFirstOrThrow
   */
  export type attributesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attributes
     */
    select?: attributesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attributes
     */
    omit?: attributesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attributesInclude<ExtArgs> | null
    /**
     * Filter, which attributes to fetch.
     */
    where?: attributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attributes to fetch.
     */
    orderBy?: attributesOrderByWithRelationInput | attributesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for attributes.
     */
    cursor?: attributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of attributes.
     */
    distinct?: AttributesScalarFieldEnum | AttributesScalarFieldEnum[]
  }

  /**
   * attributes findMany
   */
  export type attributesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attributes
     */
    select?: attributesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attributes
     */
    omit?: attributesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attributesInclude<ExtArgs> | null
    /**
     * Filter, which attributes to fetch.
     */
    where?: attributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of attributes to fetch.
     */
    orderBy?: attributesOrderByWithRelationInput | attributesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing attributes.
     */
    cursor?: attributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` attributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` attributes.
     */
    skip?: number
    distinct?: AttributesScalarFieldEnum | AttributesScalarFieldEnum[]
  }

  /**
   * attributes create
   */
  export type attributesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attributes
     */
    select?: attributesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attributes
     */
    omit?: attributesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attributesInclude<ExtArgs> | null
    /**
     * The data needed to create a attributes.
     */
    data: XOR<attributesCreateInput, attributesUncheckedCreateInput>
  }

  /**
   * attributes createMany
   */
  export type attributesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many attributes.
     */
    data: attributesCreateManyInput | attributesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * attributes createManyAndReturn
   */
  export type attributesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attributes
     */
    select?: attributesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the attributes
     */
    omit?: attributesOmit<ExtArgs> | null
    /**
     * The data used to create many attributes.
     */
    data: attributesCreateManyInput | attributesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * attributes update
   */
  export type attributesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attributes
     */
    select?: attributesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attributes
     */
    omit?: attributesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attributesInclude<ExtArgs> | null
    /**
     * The data needed to update a attributes.
     */
    data: XOR<attributesUpdateInput, attributesUncheckedUpdateInput>
    /**
     * Choose, which attributes to update.
     */
    where: attributesWhereUniqueInput
  }

  /**
   * attributes updateMany
   */
  export type attributesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update attributes.
     */
    data: XOR<attributesUpdateManyMutationInput, attributesUncheckedUpdateManyInput>
    /**
     * Filter which attributes to update
     */
    where?: attributesWhereInput
    /**
     * Limit how many attributes to update.
     */
    limit?: number
  }

  /**
   * attributes updateManyAndReturn
   */
  export type attributesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attributes
     */
    select?: attributesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the attributes
     */
    omit?: attributesOmit<ExtArgs> | null
    /**
     * The data used to update attributes.
     */
    data: XOR<attributesUpdateManyMutationInput, attributesUncheckedUpdateManyInput>
    /**
     * Filter which attributes to update
     */
    where?: attributesWhereInput
    /**
     * Limit how many attributes to update.
     */
    limit?: number
  }

  /**
   * attributes upsert
   */
  export type attributesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attributes
     */
    select?: attributesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attributes
     */
    omit?: attributesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attributesInclude<ExtArgs> | null
    /**
     * The filter to search for the attributes to update in case it exists.
     */
    where: attributesWhereUniqueInput
    /**
     * In case the attributes found by the `where` argument doesn't exist, create a new attributes with this data.
     */
    create: XOR<attributesCreateInput, attributesUncheckedCreateInput>
    /**
     * In case the attributes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<attributesUpdateInput, attributesUncheckedUpdateInput>
  }

  /**
   * attributes delete
   */
  export type attributesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attributes
     */
    select?: attributesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attributes
     */
    omit?: attributesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attributesInclude<ExtArgs> | null
    /**
     * Filter which attributes to delete.
     */
    where: attributesWhereUniqueInput
  }

  /**
   * attributes deleteMany
   */
  export type attributesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which attributes to delete
     */
    where?: attributesWhereInput
    /**
     * Limit how many attributes to delete.
     */
    limit?: number
  }

  /**
   * attributes.character_attributes
   */
  export type attributes$character_attributesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_attributes
     */
    select?: character_attributesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_attributes
     */
    omit?: character_attributesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_attributesInclude<ExtArgs> | null
    where?: character_attributesWhereInput
    orderBy?: character_attributesOrderByWithRelationInput | character_attributesOrderByWithRelationInput[]
    cursor?: character_attributesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Character_attributesScalarFieldEnum | Character_attributesScalarFieldEnum[]
  }

  /**
   * attributes without action
   */
  export type attributesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the attributes
     */
    select?: attributesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the attributes
     */
    omit?: attributesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: attributesInclude<ExtArgs> | null
  }


  /**
   * Model blood_potency
   */

  export type AggregateBlood_potency = {
    _count: Blood_potencyCountAggregateOutputType | null
    _avg: Blood_potencyAvgAggregateOutputType | null
    _sum: Blood_potencySumAggregateOutputType | null
    _min: Blood_potencyMinAggregateOutputType | null
    _max: Blood_potencyMaxAggregateOutputType | null
  }

  export type Blood_potencyAvgAggregateOutputType = {
    level: number | null
    bane_severity: number | null
  }

  export type Blood_potencySumAggregateOutputType = {
    level: number | null
    bane_severity: number | null
  }

  export type Blood_potencyMinAggregateOutputType = {
    id: string | null
    level: number | null
    description: string | null
    blood_surge: string | null
    damage_mend: string | null
    power_bonus: string | null
    rc_reroll: string | null
    bane_severity: number | null
    feeding_penalty: string | null
  }

  export type Blood_potencyMaxAggregateOutputType = {
    id: string | null
    level: number | null
    description: string | null
    blood_surge: string | null
    damage_mend: string | null
    power_bonus: string | null
    rc_reroll: string | null
    bane_severity: number | null
    feeding_penalty: string | null
  }

  export type Blood_potencyCountAggregateOutputType = {
    id: number
    level: number
    description: number
    blood_surge: number
    damage_mend: number
    power_bonus: number
    rc_reroll: number
    bane_severity: number
    feeding_penalty: number
    _all: number
  }


  export type Blood_potencyAvgAggregateInputType = {
    level?: true
    bane_severity?: true
  }

  export type Blood_potencySumAggregateInputType = {
    level?: true
    bane_severity?: true
  }

  export type Blood_potencyMinAggregateInputType = {
    id?: true
    level?: true
    description?: true
    blood_surge?: true
    damage_mend?: true
    power_bonus?: true
    rc_reroll?: true
    bane_severity?: true
    feeding_penalty?: true
  }

  export type Blood_potencyMaxAggregateInputType = {
    id?: true
    level?: true
    description?: true
    blood_surge?: true
    damage_mend?: true
    power_bonus?: true
    rc_reroll?: true
    bane_severity?: true
    feeding_penalty?: true
  }

  export type Blood_potencyCountAggregateInputType = {
    id?: true
    level?: true
    description?: true
    blood_surge?: true
    damage_mend?: true
    power_bonus?: true
    rc_reroll?: true
    bane_severity?: true
    feeding_penalty?: true
    _all?: true
  }

  export type Blood_potencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which blood_potency to aggregate.
     */
    where?: blood_potencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blood_potencies to fetch.
     */
    orderBy?: blood_potencyOrderByWithRelationInput | blood_potencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: blood_potencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blood_potencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blood_potencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned blood_potencies
    **/
    _count?: true | Blood_potencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Blood_potencyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Blood_potencySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Blood_potencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Blood_potencyMaxAggregateInputType
  }

  export type GetBlood_potencyAggregateType<T extends Blood_potencyAggregateArgs> = {
        [P in keyof T & keyof AggregateBlood_potency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlood_potency[P]>
      : GetScalarType<T[P], AggregateBlood_potency[P]>
  }




  export type blood_potencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: blood_potencyWhereInput
    orderBy?: blood_potencyOrderByWithAggregationInput | blood_potencyOrderByWithAggregationInput[]
    by: Blood_potencyScalarFieldEnum[] | Blood_potencyScalarFieldEnum
    having?: blood_potencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Blood_potencyCountAggregateInputType | true
    _avg?: Blood_potencyAvgAggregateInputType
    _sum?: Blood_potencySumAggregateInputType
    _min?: Blood_potencyMinAggregateInputType
    _max?: Blood_potencyMaxAggregateInputType
  }

  export type Blood_potencyGroupByOutputType = {
    id: string
    level: number
    description: string | null
    blood_surge: string | null
    damage_mend: string | null
    power_bonus: string | null
    rc_reroll: string | null
    bane_severity: number | null
    feeding_penalty: string | null
    _count: Blood_potencyCountAggregateOutputType | null
    _avg: Blood_potencyAvgAggregateOutputType | null
    _sum: Blood_potencySumAggregateOutputType | null
    _min: Blood_potencyMinAggregateOutputType | null
    _max: Blood_potencyMaxAggregateOutputType | null
  }

  type GetBlood_potencyGroupByPayload<T extends blood_potencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Blood_potencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Blood_potencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Blood_potencyGroupByOutputType[P]>
            : GetScalarType<T[P], Blood_potencyGroupByOutputType[P]>
        }
      >
    >


  export type blood_potencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level?: boolean
    description?: boolean
    blood_surge?: boolean
    damage_mend?: boolean
    power_bonus?: boolean
    rc_reroll?: boolean
    bane_severity?: boolean
    feeding_penalty?: boolean
    character_bloodpotencies?: boolean | blood_potency$character_bloodpotenciesArgs<ExtArgs>
    _count?: boolean | Blood_potencyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blood_potency"]>

  export type blood_potencySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level?: boolean
    description?: boolean
    blood_surge?: boolean
    damage_mend?: boolean
    power_bonus?: boolean
    rc_reroll?: boolean
    bane_severity?: boolean
    feeding_penalty?: boolean
  }, ExtArgs["result"]["blood_potency"]>

  export type blood_potencySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    level?: boolean
    description?: boolean
    blood_surge?: boolean
    damage_mend?: boolean
    power_bonus?: boolean
    rc_reroll?: boolean
    bane_severity?: boolean
    feeding_penalty?: boolean
  }, ExtArgs["result"]["blood_potency"]>

  export type blood_potencySelectScalar = {
    id?: boolean
    level?: boolean
    description?: boolean
    blood_surge?: boolean
    damage_mend?: boolean
    power_bonus?: boolean
    rc_reroll?: boolean
    bane_severity?: boolean
    feeding_penalty?: boolean
  }

  export type blood_potencyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "level" | "description" | "blood_surge" | "damage_mend" | "power_bonus" | "rc_reroll" | "bane_severity" | "feeding_penalty", ExtArgs["result"]["blood_potency"]>
  export type blood_potencyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character_bloodpotencies?: boolean | blood_potency$character_bloodpotenciesArgs<ExtArgs>
    _count?: boolean | Blood_potencyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type blood_potencyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type blood_potencyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $blood_potencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "blood_potency"
    objects: {
      character_bloodpotencies: Prisma.$character_bloodpotenciesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      level: number
      description: string | null
      blood_surge: string | null
      damage_mend: string | null
      power_bonus: string | null
      rc_reroll: string | null
      bane_severity: number | null
      feeding_penalty: string | null
    }, ExtArgs["result"]["blood_potency"]>
    composites: {}
  }

  type blood_potencyGetPayload<S extends boolean | null | undefined | blood_potencyDefaultArgs> = $Result.GetResult<Prisma.$blood_potencyPayload, S>

  type blood_potencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<blood_potencyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Blood_potencyCountAggregateInputType | true
    }

  export interface blood_potencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['blood_potency'], meta: { name: 'blood_potency' } }
    /**
     * Find zero or one Blood_potency that matches the filter.
     * @param {blood_potencyFindUniqueArgs} args - Arguments to find a Blood_potency
     * @example
     * // Get one Blood_potency
     * const blood_potency = await prisma.blood_potency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends blood_potencyFindUniqueArgs>(args: SelectSubset<T, blood_potencyFindUniqueArgs<ExtArgs>>): Prisma__blood_potencyClient<$Result.GetResult<Prisma.$blood_potencyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Blood_potency that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {blood_potencyFindUniqueOrThrowArgs} args - Arguments to find a Blood_potency
     * @example
     * // Get one Blood_potency
     * const blood_potency = await prisma.blood_potency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends blood_potencyFindUniqueOrThrowArgs>(args: SelectSubset<T, blood_potencyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__blood_potencyClient<$Result.GetResult<Prisma.$blood_potencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blood_potency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blood_potencyFindFirstArgs} args - Arguments to find a Blood_potency
     * @example
     * // Get one Blood_potency
     * const blood_potency = await prisma.blood_potency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends blood_potencyFindFirstArgs>(args?: SelectSubset<T, blood_potencyFindFirstArgs<ExtArgs>>): Prisma__blood_potencyClient<$Result.GetResult<Prisma.$blood_potencyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blood_potency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blood_potencyFindFirstOrThrowArgs} args - Arguments to find a Blood_potency
     * @example
     * // Get one Blood_potency
     * const blood_potency = await prisma.blood_potency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends blood_potencyFindFirstOrThrowArgs>(args?: SelectSubset<T, blood_potencyFindFirstOrThrowArgs<ExtArgs>>): Prisma__blood_potencyClient<$Result.GetResult<Prisma.$blood_potencyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Blood_potencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blood_potencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blood_potencies
     * const blood_potencies = await prisma.blood_potency.findMany()
     * 
     * // Get first 10 Blood_potencies
     * const blood_potencies = await prisma.blood_potency.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blood_potencyWithIdOnly = await prisma.blood_potency.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends blood_potencyFindManyArgs>(args?: SelectSubset<T, blood_potencyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blood_potencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Blood_potency.
     * @param {blood_potencyCreateArgs} args - Arguments to create a Blood_potency.
     * @example
     * // Create one Blood_potency
     * const Blood_potency = await prisma.blood_potency.create({
     *   data: {
     *     // ... data to create a Blood_potency
     *   }
     * })
     * 
     */
    create<T extends blood_potencyCreateArgs>(args: SelectSubset<T, blood_potencyCreateArgs<ExtArgs>>): Prisma__blood_potencyClient<$Result.GetResult<Prisma.$blood_potencyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Blood_potencies.
     * @param {blood_potencyCreateManyArgs} args - Arguments to create many Blood_potencies.
     * @example
     * // Create many Blood_potencies
     * const blood_potency = await prisma.blood_potency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends blood_potencyCreateManyArgs>(args?: SelectSubset<T, blood_potencyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Blood_potencies and returns the data saved in the database.
     * @param {blood_potencyCreateManyAndReturnArgs} args - Arguments to create many Blood_potencies.
     * @example
     * // Create many Blood_potencies
     * const blood_potency = await prisma.blood_potency.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Blood_potencies and only return the `id`
     * const blood_potencyWithIdOnly = await prisma.blood_potency.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends blood_potencyCreateManyAndReturnArgs>(args?: SelectSubset<T, blood_potencyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blood_potencyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Blood_potency.
     * @param {blood_potencyDeleteArgs} args - Arguments to delete one Blood_potency.
     * @example
     * // Delete one Blood_potency
     * const Blood_potency = await prisma.blood_potency.delete({
     *   where: {
     *     // ... filter to delete one Blood_potency
     *   }
     * })
     * 
     */
    delete<T extends blood_potencyDeleteArgs>(args: SelectSubset<T, blood_potencyDeleteArgs<ExtArgs>>): Prisma__blood_potencyClient<$Result.GetResult<Prisma.$blood_potencyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Blood_potency.
     * @param {blood_potencyUpdateArgs} args - Arguments to update one Blood_potency.
     * @example
     * // Update one Blood_potency
     * const blood_potency = await prisma.blood_potency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends blood_potencyUpdateArgs>(args: SelectSubset<T, blood_potencyUpdateArgs<ExtArgs>>): Prisma__blood_potencyClient<$Result.GetResult<Prisma.$blood_potencyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Blood_potencies.
     * @param {blood_potencyDeleteManyArgs} args - Arguments to filter Blood_potencies to delete.
     * @example
     * // Delete a few Blood_potencies
     * const { count } = await prisma.blood_potency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends blood_potencyDeleteManyArgs>(args?: SelectSubset<T, blood_potencyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blood_potencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blood_potencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blood_potencies
     * const blood_potency = await prisma.blood_potency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends blood_potencyUpdateManyArgs>(args: SelectSubset<T, blood_potencyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blood_potencies and returns the data updated in the database.
     * @param {blood_potencyUpdateManyAndReturnArgs} args - Arguments to update many Blood_potencies.
     * @example
     * // Update many Blood_potencies
     * const blood_potency = await prisma.blood_potency.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Blood_potencies and only return the `id`
     * const blood_potencyWithIdOnly = await prisma.blood_potency.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends blood_potencyUpdateManyAndReturnArgs>(args: SelectSubset<T, blood_potencyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blood_potencyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Blood_potency.
     * @param {blood_potencyUpsertArgs} args - Arguments to update or create a Blood_potency.
     * @example
     * // Update or create a Blood_potency
     * const blood_potency = await prisma.blood_potency.upsert({
     *   create: {
     *     // ... data to create a Blood_potency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Blood_potency we want to update
     *   }
     * })
     */
    upsert<T extends blood_potencyUpsertArgs>(args: SelectSubset<T, blood_potencyUpsertArgs<ExtArgs>>): Prisma__blood_potencyClient<$Result.GetResult<Prisma.$blood_potencyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Blood_potencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blood_potencyCountArgs} args - Arguments to filter Blood_potencies to count.
     * @example
     * // Count the number of Blood_potencies
     * const count = await prisma.blood_potency.count({
     *   where: {
     *     // ... the filter for the Blood_potencies we want to count
     *   }
     * })
    **/
    count<T extends blood_potencyCountArgs>(
      args?: Subset<T, blood_potencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Blood_potencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Blood_potency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Blood_potencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Blood_potencyAggregateArgs>(args: Subset<T, Blood_potencyAggregateArgs>): Prisma.PrismaPromise<GetBlood_potencyAggregateType<T>>

    /**
     * Group by Blood_potency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blood_potencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends blood_potencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: blood_potencyGroupByArgs['orderBy'] }
        : { orderBy?: blood_potencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, blood_potencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlood_potencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the blood_potency model
   */
  readonly fields: blood_potencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for blood_potency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__blood_potencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    character_bloodpotencies<T extends blood_potency$character_bloodpotenciesArgs<ExtArgs> = {}>(args?: Subset<T, blood_potency$character_bloodpotenciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_bloodpotenciesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the blood_potency model
   */
  interface blood_potencyFieldRefs {
    readonly id: FieldRef<"blood_potency", 'String'>
    readonly level: FieldRef<"blood_potency", 'Int'>
    readonly description: FieldRef<"blood_potency", 'String'>
    readonly blood_surge: FieldRef<"blood_potency", 'String'>
    readonly damage_mend: FieldRef<"blood_potency", 'String'>
    readonly power_bonus: FieldRef<"blood_potency", 'String'>
    readonly rc_reroll: FieldRef<"blood_potency", 'String'>
    readonly bane_severity: FieldRef<"blood_potency", 'Int'>
    readonly feeding_penalty: FieldRef<"blood_potency", 'String'>
  }
    

  // Custom InputTypes
  /**
   * blood_potency findUnique
   */
  export type blood_potencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blood_potency
     */
    select?: blood_potencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the blood_potency
     */
    omit?: blood_potencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blood_potencyInclude<ExtArgs> | null
    /**
     * Filter, which blood_potency to fetch.
     */
    where: blood_potencyWhereUniqueInput
  }

  /**
   * blood_potency findUniqueOrThrow
   */
  export type blood_potencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blood_potency
     */
    select?: blood_potencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the blood_potency
     */
    omit?: blood_potencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blood_potencyInclude<ExtArgs> | null
    /**
     * Filter, which blood_potency to fetch.
     */
    where: blood_potencyWhereUniqueInput
  }

  /**
   * blood_potency findFirst
   */
  export type blood_potencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blood_potency
     */
    select?: blood_potencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the blood_potency
     */
    omit?: blood_potencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blood_potencyInclude<ExtArgs> | null
    /**
     * Filter, which blood_potency to fetch.
     */
    where?: blood_potencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blood_potencies to fetch.
     */
    orderBy?: blood_potencyOrderByWithRelationInput | blood_potencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blood_potencies.
     */
    cursor?: blood_potencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blood_potencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blood_potencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blood_potencies.
     */
    distinct?: Blood_potencyScalarFieldEnum | Blood_potencyScalarFieldEnum[]
  }

  /**
   * blood_potency findFirstOrThrow
   */
  export type blood_potencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blood_potency
     */
    select?: blood_potencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the blood_potency
     */
    omit?: blood_potencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blood_potencyInclude<ExtArgs> | null
    /**
     * Filter, which blood_potency to fetch.
     */
    where?: blood_potencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blood_potencies to fetch.
     */
    orderBy?: blood_potencyOrderByWithRelationInput | blood_potencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blood_potencies.
     */
    cursor?: blood_potencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blood_potencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blood_potencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blood_potencies.
     */
    distinct?: Blood_potencyScalarFieldEnum | Blood_potencyScalarFieldEnum[]
  }

  /**
   * blood_potency findMany
   */
  export type blood_potencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blood_potency
     */
    select?: blood_potencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the blood_potency
     */
    omit?: blood_potencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blood_potencyInclude<ExtArgs> | null
    /**
     * Filter, which blood_potencies to fetch.
     */
    where?: blood_potencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blood_potencies to fetch.
     */
    orderBy?: blood_potencyOrderByWithRelationInput | blood_potencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing blood_potencies.
     */
    cursor?: blood_potencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blood_potencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blood_potencies.
     */
    skip?: number
    distinct?: Blood_potencyScalarFieldEnum | Blood_potencyScalarFieldEnum[]
  }

  /**
   * blood_potency create
   */
  export type blood_potencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blood_potency
     */
    select?: blood_potencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the blood_potency
     */
    omit?: blood_potencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blood_potencyInclude<ExtArgs> | null
    /**
     * The data needed to create a blood_potency.
     */
    data: XOR<blood_potencyCreateInput, blood_potencyUncheckedCreateInput>
  }

  /**
   * blood_potency createMany
   */
  export type blood_potencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many blood_potencies.
     */
    data: blood_potencyCreateManyInput | blood_potencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * blood_potency createManyAndReturn
   */
  export type blood_potencyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blood_potency
     */
    select?: blood_potencySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the blood_potency
     */
    omit?: blood_potencyOmit<ExtArgs> | null
    /**
     * The data used to create many blood_potencies.
     */
    data: blood_potencyCreateManyInput | blood_potencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * blood_potency update
   */
  export type blood_potencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blood_potency
     */
    select?: blood_potencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the blood_potency
     */
    omit?: blood_potencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blood_potencyInclude<ExtArgs> | null
    /**
     * The data needed to update a blood_potency.
     */
    data: XOR<blood_potencyUpdateInput, blood_potencyUncheckedUpdateInput>
    /**
     * Choose, which blood_potency to update.
     */
    where: blood_potencyWhereUniqueInput
  }

  /**
   * blood_potency updateMany
   */
  export type blood_potencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update blood_potencies.
     */
    data: XOR<blood_potencyUpdateManyMutationInput, blood_potencyUncheckedUpdateManyInput>
    /**
     * Filter which blood_potencies to update
     */
    where?: blood_potencyWhereInput
    /**
     * Limit how many blood_potencies to update.
     */
    limit?: number
  }

  /**
   * blood_potency updateManyAndReturn
   */
  export type blood_potencyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blood_potency
     */
    select?: blood_potencySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the blood_potency
     */
    omit?: blood_potencyOmit<ExtArgs> | null
    /**
     * The data used to update blood_potencies.
     */
    data: XOR<blood_potencyUpdateManyMutationInput, blood_potencyUncheckedUpdateManyInput>
    /**
     * Filter which blood_potencies to update
     */
    where?: blood_potencyWhereInput
    /**
     * Limit how many blood_potencies to update.
     */
    limit?: number
  }

  /**
   * blood_potency upsert
   */
  export type blood_potencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blood_potency
     */
    select?: blood_potencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the blood_potency
     */
    omit?: blood_potencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blood_potencyInclude<ExtArgs> | null
    /**
     * The filter to search for the blood_potency to update in case it exists.
     */
    where: blood_potencyWhereUniqueInput
    /**
     * In case the blood_potency found by the `where` argument doesn't exist, create a new blood_potency with this data.
     */
    create: XOR<blood_potencyCreateInput, blood_potencyUncheckedCreateInput>
    /**
     * In case the blood_potency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<blood_potencyUpdateInput, blood_potencyUncheckedUpdateInput>
  }

  /**
   * blood_potency delete
   */
  export type blood_potencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blood_potency
     */
    select?: blood_potencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the blood_potency
     */
    omit?: blood_potencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blood_potencyInclude<ExtArgs> | null
    /**
     * Filter which blood_potency to delete.
     */
    where: blood_potencyWhereUniqueInput
  }

  /**
   * blood_potency deleteMany
   */
  export type blood_potencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which blood_potencies to delete
     */
    where?: blood_potencyWhereInput
    /**
     * Limit how many blood_potencies to delete.
     */
    limit?: number
  }

  /**
   * blood_potency.character_bloodpotencies
   */
  export type blood_potency$character_bloodpotenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_bloodpotencies
     */
    select?: character_bloodpotenciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_bloodpotencies
     */
    omit?: character_bloodpotenciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_bloodpotenciesInclude<ExtArgs> | null
    where?: character_bloodpotenciesWhereInput
    orderBy?: character_bloodpotenciesOrderByWithRelationInput | character_bloodpotenciesOrderByWithRelationInput[]
    cursor?: character_bloodpotenciesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Character_bloodpotenciesScalarFieldEnum | Character_bloodpotenciesScalarFieldEnum[]
  }

  /**
   * blood_potency without action
   */
  export type blood_potencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blood_potency
     */
    select?: blood_potencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the blood_potency
     */
    omit?: blood_potencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blood_potencyInclude<ExtArgs> | null
  }


  /**
   * Model char_groups
   */

  export type AggregateChar_groups = {
    _count: Char_groupsCountAggregateOutputType | null
    _min: Char_groupsMinAggregateOutputType | null
    _max: Char_groupsMaxAggregateOutputType | null
  }

  export type Char_groupsMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    parent_id: string | null
    name: string | null
    description: string | null
  }

  export type Char_groupsMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    parent_id: string | null
    name: string | null
    description: string | null
  }

  export type Char_groupsCountAggregateOutputType = {
    id: number
    user_id: number
    parent_id: number
    name: number
    description: number
    _all: number
  }


  export type Char_groupsMinAggregateInputType = {
    id?: true
    user_id?: true
    parent_id?: true
    name?: true
    description?: true
  }

  export type Char_groupsMaxAggregateInputType = {
    id?: true
    user_id?: true
    parent_id?: true
    name?: true
    description?: true
  }

  export type Char_groupsCountAggregateInputType = {
    id?: true
    user_id?: true
    parent_id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type Char_groupsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which char_groups to aggregate.
     */
    where?: char_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of char_groups to fetch.
     */
    orderBy?: char_groupsOrderByWithRelationInput | char_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: char_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` char_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` char_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned char_groups
    **/
    _count?: true | Char_groupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Char_groupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Char_groupsMaxAggregateInputType
  }

  export type GetChar_groupsAggregateType<T extends Char_groupsAggregateArgs> = {
        [P in keyof T & keyof AggregateChar_groups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChar_groups[P]>
      : GetScalarType<T[P], AggregateChar_groups[P]>
  }




  export type char_groupsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: char_groupsWhereInput
    orderBy?: char_groupsOrderByWithAggregationInput | char_groupsOrderByWithAggregationInput[]
    by: Char_groupsScalarFieldEnum[] | Char_groupsScalarFieldEnum
    having?: char_groupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Char_groupsCountAggregateInputType | true
    _min?: Char_groupsMinAggregateInputType
    _max?: Char_groupsMaxAggregateInputType
  }

  export type Char_groupsGroupByOutputType = {
    id: string
    user_id: string
    parent_id: string | null
    name: string
    description: string
    _count: Char_groupsCountAggregateOutputType | null
    _min: Char_groupsMinAggregateOutputType | null
    _max: Char_groupsMaxAggregateOutputType | null
  }

  type GetChar_groupsGroupByPayload<T extends char_groupsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Char_groupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Char_groupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Char_groupsGroupByOutputType[P]>
            : GetScalarType<T[P], Char_groupsGroupByOutputType[P]>
        }
      >
    >


  export type char_groupsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    parent_id?: boolean
    name?: boolean
    description?: boolean
    char_groups?: boolean | char_groups$char_groupsArgs<ExtArgs>
    other_char_groups?: boolean | char_groups$other_char_groupsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    characters?: boolean | char_groups$charactersArgs<ExtArgs>
    _count?: boolean | Char_groupsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["char_groups"]>

  export type char_groupsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    parent_id?: boolean
    name?: boolean
    description?: boolean
    char_groups?: boolean | char_groups$char_groupsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["char_groups"]>

  export type char_groupsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    parent_id?: boolean
    name?: boolean
    description?: boolean
    char_groups?: boolean | char_groups$char_groupsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["char_groups"]>

  export type char_groupsSelectScalar = {
    id?: boolean
    user_id?: boolean
    parent_id?: boolean
    name?: boolean
    description?: boolean
  }

  export type char_groupsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "parent_id" | "name" | "description", ExtArgs["result"]["char_groups"]>
  export type char_groupsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    char_groups?: boolean | char_groups$char_groupsArgs<ExtArgs>
    other_char_groups?: boolean | char_groups$other_char_groupsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    characters?: boolean | char_groups$charactersArgs<ExtArgs>
    _count?: boolean | Char_groupsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type char_groupsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    char_groups?: boolean | char_groups$char_groupsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type char_groupsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    char_groups?: boolean | char_groups$char_groupsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $char_groupsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "char_groups"
    objects: {
      char_groups: Prisma.$char_groupsPayload<ExtArgs> | null
      other_char_groups: Prisma.$char_groupsPayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs>
      characters: Prisma.$charactersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      parent_id: string | null
      name: string
      description: string
    }, ExtArgs["result"]["char_groups"]>
    composites: {}
  }

  type char_groupsGetPayload<S extends boolean | null | undefined | char_groupsDefaultArgs> = $Result.GetResult<Prisma.$char_groupsPayload, S>

  type char_groupsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<char_groupsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Char_groupsCountAggregateInputType | true
    }

  export interface char_groupsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['char_groups'], meta: { name: 'char_groups' } }
    /**
     * Find zero or one Char_groups that matches the filter.
     * @param {char_groupsFindUniqueArgs} args - Arguments to find a Char_groups
     * @example
     * // Get one Char_groups
     * const char_groups = await prisma.char_groups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends char_groupsFindUniqueArgs>(args: SelectSubset<T, char_groupsFindUniqueArgs<ExtArgs>>): Prisma__char_groupsClient<$Result.GetResult<Prisma.$char_groupsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Char_groups that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {char_groupsFindUniqueOrThrowArgs} args - Arguments to find a Char_groups
     * @example
     * // Get one Char_groups
     * const char_groups = await prisma.char_groups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends char_groupsFindUniqueOrThrowArgs>(args: SelectSubset<T, char_groupsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__char_groupsClient<$Result.GetResult<Prisma.$char_groupsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Char_groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {char_groupsFindFirstArgs} args - Arguments to find a Char_groups
     * @example
     * // Get one Char_groups
     * const char_groups = await prisma.char_groups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends char_groupsFindFirstArgs>(args?: SelectSubset<T, char_groupsFindFirstArgs<ExtArgs>>): Prisma__char_groupsClient<$Result.GetResult<Prisma.$char_groupsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Char_groups that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {char_groupsFindFirstOrThrowArgs} args - Arguments to find a Char_groups
     * @example
     * // Get one Char_groups
     * const char_groups = await prisma.char_groups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends char_groupsFindFirstOrThrowArgs>(args?: SelectSubset<T, char_groupsFindFirstOrThrowArgs<ExtArgs>>): Prisma__char_groupsClient<$Result.GetResult<Prisma.$char_groupsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Char_groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {char_groupsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Char_groups
     * const char_groups = await prisma.char_groups.findMany()
     * 
     * // Get first 10 Char_groups
     * const char_groups = await prisma.char_groups.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const char_groupsWithIdOnly = await prisma.char_groups.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends char_groupsFindManyArgs>(args?: SelectSubset<T, char_groupsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$char_groupsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Char_groups.
     * @param {char_groupsCreateArgs} args - Arguments to create a Char_groups.
     * @example
     * // Create one Char_groups
     * const Char_groups = await prisma.char_groups.create({
     *   data: {
     *     // ... data to create a Char_groups
     *   }
     * })
     * 
     */
    create<T extends char_groupsCreateArgs>(args: SelectSubset<T, char_groupsCreateArgs<ExtArgs>>): Prisma__char_groupsClient<$Result.GetResult<Prisma.$char_groupsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Char_groups.
     * @param {char_groupsCreateManyArgs} args - Arguments to create many Char_groups.
     * @example
     * // Create many Char_groups
     * const char_groups = await prisma.char_groups.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends char_groupsCreateManyArgs>(args?: SelectSubset<T, char_groupsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Char_groups and returns the data saved in the database.
     * @param {char_groupsCreateManyAndReturnArgs} args - Arguments to create many Char_groups.
     * @example
     * // Create many Char_groups
     * const char_groups = await prisma.char_groups.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Char_groups and only return the `id`
     * const char_groupsWithIdOnly = await prisma.char_groups.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends char_groupsCreateManyAndReturnArgs>(args?: SelectSubset<T, char_groupsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$char_groupsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Char_groups.
     * @param {char_groupsDeleteArgs} args - Arguments to delete one Char_groups.
     * @example
     * // Delete one Char_groups
     * const Char_groups = await prisma.char_groups.delete({
     *   where: {
     *     // ... filter to delete one Char_groups
     *   }
     * })
     * 
     */
    delete<T extends char_groupsDeleteArgs>(args: SelectSubset<T, char_groupsDeleteArgs<ExtArgs>>): Prisma__char_groupsClient<$Result.GetResult<Prisma.$char_groupsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Char_groups.
     * @param {char_groupsUpdateArgs} args - Arguments to update one Char_groups.
     * @example
     * // Update one Char_groups
     * const char_groups = await prisma.char_groups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends char_groupsUpdateArgs>(args: SelectSubset<T, char_groupsUpdateArgs<ExtArgs>>): Prisma__char_groupsClient<$Result.GetResult<Prisma.$char_groupsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Char_groups.
     * @param {char_groupsDeleteManyArgs} args - Arguments to filter Char_groups to delete.
     * @example
     * // Delete a few Char_groups
     * const { count } = await prisma.char_groups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends char_groupsDeleteManyArgs>(args?: SelectSubset<T, char_groupsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Char_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {char_groupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Char_groups
     * const char_groups = await prisma.char_groups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends char_groupsUpdateManyArgs>(args: SelectSubset<T, char_groupsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Char_groups and returns the data updated in the database.
     * @param {char_groupsUpdateManyAndReturnArgs} args - Arguments to update many Char_groups.
     * @example
     * // Update many Char_groups
     * const char_groups = await prisma.char_groups.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Char_groups and only return the `id`
     * const char_groupsWithIdOnly = await prisma.char_groups.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends char_groupsUpdateManyAndReturnArgs>(args: SelectSubset<T, char_groupsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$char_groupsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Char_groups.
     * @param {char_groupsUpsertArgs} args - Arguments to update or create a Char_groups.
     * @example
     * // Update or create a Char_groups
     * const char_groups = await prisma.char_groups.upsert({
     *   create: {
     *     // ... data to create a Char_groups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Char_groups we want to update
     *   }
     * })
     */
    upsert<T extends char_groupsUpsertArgs>(args: SelectSubset<T, char_groupsUpsertArgs<ExtArgs>>): Prisma__char_groupsClient<$Result.GetResult<Prisma.$char_groupsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Char_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {char_groupsCountArgs} args - Arguments to filter Char_groups to count.
     * @example
     * // Count the number of Char_groups
     * const count = await prisma.char_groups.count({
     *   where: {
     *     // ... the filter for the Char_groups we want to count
     *   }
     * })
    **/
    count<T extends char_groupsCountArgs>(
      args?: Subset<T, char_groupsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Char_groupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Char_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Char_groupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Char_groupsAggregateArgs>(args: Subset<T, Char_groupsAggregateArgs>): Prisma.PrismaPromise<GetChar_groupsAggregateType<T>>

    /**
     * Group by Char_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {char_groupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends char_groupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: char_groupsGroupByArgs['orderBy'] }
        : { orderBy?: char_groupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, char_groupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChar_groupsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the char_groups model
   */
  readonly fields: char_groupsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for char_groups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__char_groupsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    char_groups<T extends char_groups$char_groupsArgs<ExtArgs> = {}>(args?: Subset<T, char_groups$char_groupsArgs<ExtArgs>>): Prisma__char_groupsClient<$Result.GetResult<Prisma.$char_groupsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    other_char_groups<T extends char_groups$other_char_groupsArgs<ExtArgs> = {}>(args?: Subset<T, char_groups$other_char_groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$char_groupsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    characters<T extends char_groups$charactersArgs<ExtArgs> = {}>(args?: Subset<T, char_groups$charactersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$charactersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the char_groups model
   */
  interface char_groupsFieldRefs {
    readonly id: FieldRef<"char_groups", 'String'>
    readonly user_id: FieldRef<"char_groups", 'String'>
    readonly parent_id: FieldRef<"char_groups", 'String'>
    readonly name: FieldRef<"char_groups", 'String'>
    readonly description: FieldRef<"char_groups", 'String'>
  }
    

  // Custom InputTypes
  /**
   * char_groups findUnique
   */
  export type char_groupsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the char_groups
     */
    select?: char_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the char_groups
     */
    omit?: char_groupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: char_groupsInclude<ExtArgs> | null
    /**
     * Filter, which char_groups to fetch.
     */
    where: char_groupsWhereUniqueInput
  }

  /**
   * char_groups findUniqueOrThrow
   */
  export type char_groupsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the char_groups
     */
    select?: char_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the char_groups
     */
    omit?: char_groupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: char_groupsInclude<ExtArgs> | null
    /**
     * Filter, which char_groups to fetch.
     */
    where: char_groupsWhereUniqueInput
  }

  /**
   * char_groups findFirst
   */
  export type char_groupsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the char_groups
     */
    select?: char_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the char_groups
     */
    omit?: char_groupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: char_groupsInclude<ExtArgs> | null
    /**
     * Filter, which char_groups to fetch.
     */
    where?: char_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of char_groups to fetch.
     */
    orderBy?: char_groupsOrderByWithRelationInput | char_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for char_groups.
     */
    cursor?: char_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` char_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` char_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of char_groups.
     */
    distinct?: Char_groupsScalarFieldEnum | Char_groupsScalarFieldEnum[]
  }

  /**
   * char_groups findFirstOrThrow
   */
  export type char_groupsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the char_groups
     */
    select?: char_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the char_groups
     */
    omit?: char_groupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: char_groupsInclude<ExtArgs> | null
    /**
     * Filter, which char_groups to fetch.
     */
    where?: char_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of char_groups to fetch.
     */
    orderBy?: char_groupsOrderByWithRelationInput | char_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for char_groups.
     */
    cursor?: char_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` char_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` char_groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of char_groups.
     */
    distinct?: Char_groupsScalarFieldEnum | Char_groupsScalarFieldEnum[]
  }

  /**
   * char_groups findMany
   */
  export type char_groupsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the char_groups
     */
    select?: char_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the char_groups
     */
    omit?: char_groupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: char_groupsInclude<ExtArgs> | null
    /**
     * Filter, which char_groups to fetch.
     */
    where?: char_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of char_groups to fetch.
     */
    orderBy?: char_groupsOrderByWithRelationInput | char_groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing char_groups.
     */
    cursor?: char_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` char_groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` char_groups.
     */
    skip?: number
    distinct?: Char_groupsScalarFieldEnum | Char_groupsScalarFieldEnum[]
  }

  /**
   * char_groups create
   */
  export type char_groupsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the char_groups
     */
    select?: char_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the char_groups
     */
    omit?: char_groupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: char_groupsInclude<ExtArgs> | null
    /**
     * The data needed to create a char_groups.
     */
    data: XOR<char_groupsCreateInput, char_groupsUncheckedCreateInput>
  }

  /**
   * char_groups createMany
   */
  export type char_groupsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many char_groups.
     */
    data: char_groupsCreateManyInput | char_groupsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * char_groups createManyAndReturn
   */
  export type char_groupsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the char_groups
     */
    select?: char_groupsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the char_groups
     */
    omit?: char_groupsOmit<ExtArgs> | null
    /**
     * The data used to create many char_groups.
     */
    data: char_groupsCreateManyInput | char_groupsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: char_groupsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * char_groups update
   */
  export type char_groupsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the char_groups
     */
    select?: char_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the char_groups
     */
    omit?: char_groupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: char_groupsInclude<ExtArgs> | null
    /**
     * The data needed to update a char_groups.
     */
    data: XOR<char_groupsUpdateInput, char_groupsUncheckedUpdateInput>
    /**
     * Choose, which char_groups to update.
     */
    where: char_groupsWhereUniqueInput
  }

  /**
   * char_groups updateMany
   */
  export type char_groupsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update char_groups.
     */
    data: XOR<char_groupsUpdateManyMutationInput, char_groupsUncheckedUpdateManyInput>
    /**
     * Filter which char_groups to update
     */
    where?: char_groupsWhereInput
    /**
     * Limit how many char_groups to update.
     */
    limit?: number
  }

  /**
   * char_groups updateManyAndReturn
   */
  export type char_groupsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the char_groups
     */
    select?: char_groupsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the char_groups
     */
    omit?: char_groupsOmit<ExtArgs> | null
    /**
     * The data used to update char_groups.
     */
    data: XOR<char_groupsUpdateManyMutationInput, char_groupsUncheckedUpdateManyInput>
    /**
     * Filter which char_groups to update
     */
    where?: char_groupsWhereInput
    /**
     * Limit how many char_groups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: char_groupsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * char_groups upsert
   */
  export type char_groupsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the char_groups
     */
    select?: char_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the char_groups
     */
    omit?: char_groupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: char_groupsInclude<ExtArgs> | null
    /**
     * The filter to search for the char_groups to update in case it exists.
     */
    where: char_groupsWhereUniqueInput
    /**
     * In case the char_groups found by the `where` argument doesn't exist, create a new char_groups with this data.
     */
    create: XOR<char_groupsCreateInput, char_groupsUncheckedCreateInput>
    /**
     * In case the char_groups was found with the provided `where` argument, update it with this data.
     */
    update: XOR<char_groupsUpdateInput, char_groupsUncheckedUpdateInput>
  }

  /**
   * char_groups delete
   */
  export type char_groupsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the char_groups
     */
    select?: char_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the char_groups
     */
    omit?: char_groupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: char_groupsInclude<ExtArgs> | null
    /**
     * Filter which char_groups to delete.
     */
    where: char_groupsWhereUniqueInput
  }

  /**
   * char_groups deleteMany
   */
  export type char_groupsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which char_groups to delete
     */
    where?: char_groupsWhereInput
    /**
     * Limit how many char_groups to delete.
     */
    limit?: number
  }

  /**
   * char_groups.char_groups
   */
  export type char_groups$char_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the char_groups
     */
    select?: char_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the char_groups
     */
    omit?: char_groupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: char_groupsInclude<ExtArgs> | null
    where?: char_groupsWhereInput
  }

  /**
   * char_groups.other_char_groups
   */
  export type char_groups$other_char_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the char_groups
     */
    select?: char_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the char_groups
     */
    omit?: char_groupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: char_groupsInclude<ExtArgs> | null
    where?: char_groupsWhereInput
    orderBy?: char_groupsOrderByWithRelationInput | char_groupsOrderByWithRelationInput[]
    cursor?: char_groupsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Char_groupsScalarFieldEnum | Char_groupsScalarFieldEnum[]
  }

  /**
   * char_groups.characters
   */
  export type char_groups$charactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characters
     */
    select?: charactersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the characters
     */
    omit?: charactersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: charactersInclude<ExtArgs> | null
    where?: charactersWhereInput
    orderBy?: charactersOrderByWithRelationInput | charactersOrderByWithRelationInput[]
    cursor?: charactersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharactersScalarFieldEnum | CharactersScalarFieldEnum[]
  }

  /**
   * char_groups without action
   */
  export type char_groupsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the char_groups
     */
    select?: char_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the char_groups
     */
    omit?: char_groupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: char_groupsInclude<ExtArgs> | null
  }


  /**
   * Model character_advantages
   */

  export type AggregateCharacter_advantages = {
    _count: Character_advantagesCountAggregateOutputType | null
    _min: Character_advantagesMinAggregateOutputType | null
    _max: Character_advantagesMaxAggregateOutputType | null
  }

  export type Character_advantagesMinAggregateOutputType = {
    id: string | null
    char_id: string | null
    advantage_id: string | null
  }

  export type Character_advantagesMaxAggregateOutputType = {
    id: string | null
    char_id: string | null
    advantage_id: string | null
  }

  export type Character_advantagesCountAggregateOutputType = {
    id: number
    char_id: number
    advantage_id: number
    _all: number
  }


  export type Character_advantagesMinAggregateInputType = {
    id?: true
    char_id?: true
    advantage_id?: true
  }

  export type Character_advantagesMaxAggregateInputType = {
    id?: true
    char_id?: true
    advantage_id?: true
  }

  export type Character_advantagesCountAggregateInputType = {
    id?: true
    char_id?: true
    advantage_id?: true
    _all?: true
  }

  export type Character_advantagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which character_advantages to aggregate.
     */
    where?: character_advantagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_advantages to fetch.
     */
    orderBy?: character_advantagesOrderByWithRelationInput | character_advantagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: character_advantagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_advantages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_advantages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned character_advantages
    **/
    _count?: true | Character_advantagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Character_advantagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Character_advantagesMaxAggregateInputType
  }

  export type GetCharacter_advantagesAggregateType<T extends Character_advantagesAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacter_advantages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacter_advantages[P]>
      : GetScalarType<T[P], AggregateCharacter_advantages[P]>
  }




  export type character_advantagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: character_advantagesWhereInput
    orderBy?: character_advantagesOrderByWithAggregationInput | character_advantagesOrderByWithAggregationInput[]
    by: Character_advantagesScalarFieldEnum[] | Character_advantagesScalarFieldEnum
    having?: character_advantagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Character_advantagesCountAggregateInputType | true
    _min?: Character_advantagesMinAggregateInputType
    _max?: Character_advantagesMaxAggregateInputType
  }

  export type Character_advantagesGroupByOutputType = {
    id: string
    char_id: string
    advantage_id: string
    _count: Character_advantagesCountAggregateOutputType | null
    _min: Character_advantagesMinAggregateOutputType | null
    _max: Character_advantagesMaxAggregateOutputType | null
  }

  type GetCharacter_advantagesGroupByPayload<T extends character_advantagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Character_advantagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Character_advantagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Character_advantagesGroupByOutputType[P]>
            : GetScalarType<T[P], Character_advantagesGroupByOutputType[P]>
        }
      >
    >


  export type character_advantagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    char_id?: boolean
    advantage_id?: boolean
    advantages?: boolean | advantagesDefaultArgs<ExtArgs>
    characters?: boolean | charactersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character_advantages"]>

  export type character_advantagesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    char_id?: boolean
    advantage_id?: boolean
    advantages?: boolean | advantagesDefaultArgs<ExtArgs>
    characters?: boolean | charactersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character_advantages"]>

  export type character_advantagesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    char_id?: boolean
    advantage_id?: boolean
    advantages?: boolean | advantagesDefaultArgs<ExtArgs>
    characters?: boolean | charactersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character_advantages"]>

  export type character_advantagesSelectScalar = {
    id?: boolean
    char_id?: boolean
    advantage_id?: boolean
  }

  export type character_advantagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "char_id" | "advantage_id", ExtArgs["result"]["character_advantages"]>
  export type character_advantagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    advantages?: boolean | advantagesDefaultArgs<ExtArgs>
    characters?: boolean | charactersDefaultArgs<ExtArgs>
  }
  export type character_advantagesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    advantages?: boolean | advantagesDefaultArgs<ExtArgs>
    characters?: boolean | charactersDefaultArgs<ExtArgs>
  }
  export type character_advantagesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    advantages?: boolean | advantagesDefaultArgs<ExtArgs>
    characters?: boolean | charactersDefaultArgs<ExtArgs>
  }

  export type $character_advantagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "character_advantages"
    objects: {
      advantages: Prisma.$advantagesPayload<ExtArgs>
      characters: Prisma.$charactersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      char_id: string
      advantage_id: string
    }, ExtArgs["result"]["character_advantages"]>
    composites: {}
  }

  type character_advantagesGetPayload<S extends boolean | null | undefined | character_advantagesDefaultArgs> = $Result.GetResult<Prisma.$character_advantagesPayload, S>

  type character_advantagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<character_advantagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Character_advantagesCountAggregateInputType | true
    }

  export interface character_advantagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['character_advantages'], meta: { name: 'character_advantages' } }
    /**
     * Find zero or one Character_advantages that matches the filter.
     * @param {character_advantagesFindUniqueArgs} args - Arguments to find a Character_advantages
     * @example
     * // Get one Character_advantages
     * const character_advantages = await prisma.character_advantages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends character_advantagesFindUniqueArgs>(args: SelectSubset<T, character_advantagesFindUniqueArgs<ExtArgs>>): Prisma__character_advantagesClient<$Result.GetResult<Prisma.$character_advantagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Character_advantages that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {character_advantagesFindUniqueOrThrowArgs} args - Arguments to find a Character_advantages
     * @example
     * // Get one Character_advantages
     * const character_advantages = await prisma.character_advantages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends character_advantagesFindUniqueOrThrowArgs>(args: SelectSubset<T, character_advantagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__character_advantagesClient<$Result.GetResult<Prisma.$character_advantagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Character_advantages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_advantagesFindFirstArgs} args - Arguments to find a Character_advantages
     * @example
     * // Get one Character_advantages
     * const character_advantages = await prisma.character_advantages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends character_advantagesFindFirstArgs>(args?: SelectSubset<T, character_advantagesFindFirstArgs<ExtArgs>>): Prisma__character_advantagesClient<$Result.GetResult<Prisma.$character_advantagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Character_advantages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_advantagesFindFirstOrThrowArgs} args - Arguments to find a Character_advantages
     * @example
     * // Get one Character_advantages
     * const character_advantages = await prisma.character_advantages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends character_advantagesFindFirstOrThrowArgs>(args?: SelectSubset<T, character_advantagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__character_advantagesClient<$Result.GetResult<Prisma.$character_advantagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Character_advantages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_advantagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Character_advantages
     * const character_advantages = await prisma.character_advantages.findMany()
     * 
     * // Get first 10 Character_advantages
     * const character_advantages = await prisma.character_advantages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const character_advantagesWithIdOnly = await prisma.character_advantages.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends character_advantagesFindManyArgs>(args?: SelectSubset<T, character_advantagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_advantagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Character_advantages.
     * @param {character_advantagesCreateArgs} args - Arguments to create a Character_advantages.
     * @example
     * // Create one Character_advantages
     * const Character_advantages = await prisma.character_advantages.create({
     *   data: {
     *     // ... data to create a Character_advantages
     *   }
     * })
     * 
     */
    create<T extends character_advantagesCreateArgs>(args: SelectSubset<T, character_advantagesCreateArgs<ExtArgs>>): Prisma__character_advantagesClient<$Result.GetResult<Prisma.$character_advantagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Character_advantages.
     * @param {character_advantagesCreateManyArgs} args - Arguments to create many Character_advantages.
     * @example
     * // Create many Character_advantages
     * const character_advantages = await prisma.character_advantages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends character_advantagesCreateManyArgs>(args?: SelectSubset<T, character_advantagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Character_advantages and returns the data saved in the database.
     * @param {character_advantagesCreateManyAndReturnArgs} args - Arguments to create many Character_advantages.
     * @example
     * // Create many Character_advantages
     * const character_advantages = await prisma.character_advantages.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Character_advantages and only return the `id`
     * const character_advantagesWithIdOnly = await prisma.character_advantages.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends character_advantagesCreateManyAndReturnArgs>(args?: SelectSubset<T, character_advantagesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_advantagesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Character_advantages.
     * @param {character_advantagesDeleteArgs} args - Arguments to delete one Character_advantages.
     * @example
     * // Delete one Character_advantages
     * const Character_advantages = await prisma.character_advantages.delete({
     *   where: {
     *     // ... filter to delete one Character_advantages
     *   }
     * })
     * 
     */
    delete<T extends character_advantagesDeleteArgs>(args: SelectSubset<T, character_advantagesDeleteArgs<ExtArgs>>): Prisma__character_advantagesClient<$Result.GetResult<Prisma.$character_advantagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Character_advantages.
     * @param {character_advantagesUpdateArgs} args - Arguments to update one Character_advantages.
     * @example
     * // Update one Character_advantages
     * const character_advantages = await prisma.character_advantages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends character_advantagesUpdateArgs>(args: SelectSubset<T, character_advantagesUpdateArgs<ExtArgs>>): Prisma__character_advantagesClient<$Result.GetResult<Prisma.$character_advantagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Character_advantages.
     * @param {character_advantagesDeleteManyArgs} args - Arguments to filter Character_advantages to delete.
     * @example
     * // Delete a few Character_advantages
     * const { count } = await prisma.character_advantages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends character_advantagesDeleteManyArgs>(args?: SelectSubset<T, character_advantagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Character_advantages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_advantagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Character_advantages
     * const character_advantages = await prisma.character_advantages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends character_advantagesUpdateManyArgs>(args: SelectSubset<T, character_advantagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Character_advantages and returns the data updated in the database.
     * @param {character_advantagesUpdateManyAndReturnArgs} args - Arguments to update many Character_advantages.
     * @example
     * // Update many Character_advantages
     * const character_advantages = await prisma.character_advantages.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Character_advantages and only return the `id`
     * const character_advantagesWithIdOnly = await prisma.character_advantages.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends character_advantagesUpdateManyAndReturnArgs>(args: SelectSubset<T, character_advantagesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_advantagesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Character_advantages.
     * @param {character_advantagesUpsertArgs} args - Arguments to update or create a Character_advantages.
     * @example
     * // Update or create a Character_advantages
     * const character_advantages = await prisma.character_advantages.upsert({
     *   create: {
     *     // ... data to create a Character_advantages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Character_advantages we want to update
     *   }
     * })
     */
    upsert<T extends character_advantagesUpsertArgs>(args: SelectSubset<T, character_advantagesUpsertArgs<ExtArgs>>): Prisma__character_advantagesClient<$Result.GetResult<Prisma.$character_advantagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Character_advantages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_advantagesCountArgs} args - Arguments to filter Character_advantages to count.
     * @example
     * // Count the number of Character_advantages
     * const count = await prisma.character_advantages.count({
     *   where: {
     *     // ... the filter for the Character_advantages we want to count
     *   }
     * })
    **/
    count<T extends character_advantagesCountArgs>(
      args?: Subset<T, character_advantagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Character_advantagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Character_advantages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Character_advantagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Character_advantagesAggregateArgs>(args: Subset<T, Character_advantagesAggregateArgs>): Prisma.PrismaPromise<GetCharacter_advantagesAggregateType<T>>

    /**
     * Group by Character_advantages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_advantagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends character_advantagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: character_advantagesGroupByArgs['orderBy'] }
        : { orderBy?: character_advantagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, character_advantagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacter_advantagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the character_advantages model
   */
  readonly fields: character_advantagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for character_advantages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__character_advantagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    advantages<T extends advantagesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, advantagesDefaultArgs<ExtArgs>>): Prisma__advantagesClient<$Result.GetResult<Prisma.$advantagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    characters<T extends charactersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, charactersDefaultArgs<ExtArgs>>): Prisma__charactersClient<$Result.GetResult<Prisma.$charactersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the character_advantages model
   */
  interface character_advantagesFieldRefs {
    readonly id: FieldRef<"character_advantages", 'String'>
    readonly char_id: FieldRef<"character_advantages", 'String'>
    readonly advantage_id: FieldRef<"character_advantages", 'String'>
  }
    

  // Custom InputTypes
  /**
   * character_advantages findUnique
   */
  export type character_advantagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_advantages
     */
    select?: character_advantagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_advantages
     */
    omit?: character_advantagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_advantagesInclude<ExtArgs> | null
    /**
     * Filter, which character_advantages to fetch.
     */
    where: character_advantagesWhereUniqueInput
  }

  /**
   * character_advantages findUniqueOrThrow
   */
  export type character_advantagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_advantages
     */
    select?: character_advantagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_advantages
     */
    omit?: character_advantagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_advantagesInclude<ExtArgs> | null
    /**
     * Filter, which character_advantages to fetch.
     */
    where: character_advantagesWhereUniqueInput
  }

  /**
   * character_advantages findFirst
   */
  export type character_advantagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_advantages
     */
    select?: character_advantagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_advantages
     */
    omit?: character_advantagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_advantagesInclude<ExtArgs> | null
    /**
     * Filter, which character_advantages to fetch.
     */
    where?: character_advantagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_advantages to fetch.
     */
    orderBy?: character_advantagesOrderByWithRelationInput | character_advantagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for character_advantages.
     */
    cursor?: character_advantagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_advantages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_advantages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of character_advantages.
     */
    distinct?: Character_advantagesScalarFieldEnum | Character_advantagesScalarFieldEnum[]
  }

  /**
   * character_advantages findFirstOrThrow
   */
  export type character_advantagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_advantages
     */
    select?: character_advantagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_advantages
     */
    omit?: character_advantagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_advantagesInclude<ExtArgs> | null
    /**
     * Filter, which character_advantages to fetch.
     */
    where?: character_advantagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_advantages to fetch.
     */
    orderBy?: character_advantagesOrderByWithRelationInput | character_advantagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for character_advantages.
     */
    cursor?: character_advantagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_advantages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_advantages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of character_advantages.
     */
    distinct?: Character_advantagesScalarFieldEnum | Character_advantagesScalarFieldEnum[]
  }

  /**
   * character_advantages findMany
   */
  export type character_advantagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_advantages
     */
    select?: character_advantagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_advantages
     */
    omit?: character_advantagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_advantagesInclude<ExtArgs> | null
    /**
     * Filter, which character_advantages to fetch.
     */
    where?: character_advantagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_advantages to fetch.
     */
    orderBy?: character_advantagesOrderByWithRelationInput | character_advantagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing character_advantages.
     */
    cursor?: character_advantagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_advantages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_advantages.
     */
    skip?: number
    distinct?: Character_advantagesScalarFieldEnum | Character_advantagesScalarFieldEnum[]
  }

  /**
   * character_advantages create
   */
  export type character_advantagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_advantages
     */
    select?: character_advantagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_advantages
     */
    omit?: character_advantagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_advantagesInclude<ExtArgs> | null
    /**
     * The data needed to create a character_advantages.
     */
    data: XOR<character_advantagesCreateInput, character_advantagesUncheckedCreateInput>
  }

  /**
   * character_advantages createMany
   */
  export type character_advantagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many character_advantages.
     */
    data: character_advantagesCreateManyInput | character_advantagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * character_advantages createManyAndReturn
   */
  export type character_advantagesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_advantages
     */
    select?: character_advantagesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the character_advantages
     */
    omit?: character_advantagesOmit<ExtArgs> | null
    /**
     * The data used to create many character_advantages.
     */
    data: character_advantagesCreateManyInput | character_advantagesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_advantagesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * character_advantages update
   */
  export type character_advantagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_advantages
     */
    select?: character_advantagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_advantages
     */
    omit?: character_advantagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_advantagesInclude<ExtArgs> | null
    /**
     * The data needed to update a character_advantages.
     */
    data: XOR<character_advantagesUpdateInput, character_advantagesUncheckedUpdateInput>
    /**
     * Choose, which character_advantages to update.
     */
    where: character_advantagesWhereUniqueInput
  }

  /**
   * character_advantages updateMany
   */
  export type character_advantagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update character_advantages.
     */
    data: XOR<character_advantagesUpdateManyMutationInput, character_advantagesUncheckedUpdateManyInput>
    /**
     * Filter which character_advantages to update
     */
    where?: character_advantagesWhereInput
    /**
     * Limit how many character_advantages to update.
     */
    limit?: number
  }

  /**
   * character_advantages updateManyAndReturn
   */
  export type character_advantagesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_advantages
     */
    select?: character_advantagesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the character_advantages
     */
    omit?: character_advantagesOmit<ExtArgs> | null
    /**
     * The data used to update character_advantages.
     */
    data: XOR<character_advantagesUpdateManyMutationInput, character_advantagesUncheckedUpdateManyInput>
    /**
     * Filter which character_advantages to update
     */
    where?: character_advantagesWhereInput
    /**
     * Limit how many character_advantages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_advantagesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * character_advantages upsert
   */
  export type character_advantagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_advantages
     */
    select?: character_advantagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_advantages
     */
    omit?: character_advantagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_advantagesInclude<ExtArgs> | null
    /**
     * The filter to search for the character_advantages to update in case it exists.
     */
    where: character_advantagesWhereUniqueInput
    /**
     * In case the character_advantages found by the `where` argument doesn't exist, create a new character_advantages with this data.
     */
    create: XOR<character_advantagesCreateInput, character_advantagesUncheckedCreateInput>
    /**
     * In case the character_advantages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<character_advantagesUpdateInput, character_advantagesUncheckedUpdateInput>
  }

  /**
   * character_advantages delete
   */
  export type character_advantagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_advantages
     */
    select?: character_advantagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_advantages
     */
    omit?: character_advantagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_advantagesInclude<ExtArgs> | null
    /**
     * Filter which character_advantages to delete.
     */
    where: character_advantagesWhereUniqueInput
  }

  /**
   * character_advantages deleteMany
   */
  export type character_advantagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which character_advantages to delete
     */
    where?: character_advantagesWhereInput
    /**
     * Limit how many character_advantages to delete.
     */
    limit?: number
  }

  /**
   * character_advantages without action
   */
  export type character_advantagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_advantages
     */
    select?: character_advantagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_advantages
     */
    omit?: character_advantagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_advantagesInclude<ExtArgs> | null
  }


  /**
   * Model character_alchemy_powers
   */

  export type AggregateCharacter_alchemy_powers = {
    _count: Character_alchemy_powersCountAggregateOutputType | null
    _min: Character_alchemy_powersMinAggregateOutputType | null
    _max: Character_alchemy_powersMaxAggregateOutputType | null
  }

  export type Character_alchemy_powersMinAggregateOutputType = {
    id: string | null
    char_id: string | null
    alchemy_power_id: string | null
  }

  export type Character_alchemy_powersMaxAggregateOutputType = {
    id: string | null
    char_id: string | null
    alchemy_power_id: string | null
  }

  export type Character_alchemy_powersCountAggregateOutputType = {
    id: number
    char_id: number
    alchemy_power_id: number
    _all: number
  }


  export type Character_alchemy_powersMinAggregateInputType = {
    id?: true
    char_id?: true
    alchemy_power_id?: true
  }

  export type Character_alchemy_powersMaxAggregateInputType = {
    id?: true
    char_id?: true
    alchemy_power_id?: true
  }

  export type Character_alchemy_powersCountAggregateInputType = {
    id?: true
    char_id?: true
    alchemy_power_id?: true
    _all?: true
  }

  export type Character_alchemy_powersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which character_alchemy_powers to aggregate.
     */
    where?: character_alchemy_powersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_alchemy_powers to fetch.
     */
    orderBy?: character_alchemy_powersOrderByWithRelationInput | character_alchemy_powersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: character_alchemy_powersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_alchemy_powers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_alchemy_powers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned character_alchemy_powers
    **/
    _count?: true | Character_alchemy_powersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Character_alchemy_powersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Character_alchemy_powersMaxAggregateInputType
  }

  export type GetCharacter_alchemy_powersAggregateType<T extends Character_alchemy_powersAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacter_alchemy_powers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacter_alchemy_powers[P]>
      : GetScalarType<T[P], AggregateCharacter_alchemy_powers[P]>
  }




  export type character_alchemy_powersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: character_alchemy_powersWhereInput
    orderBy?: character_alchemy_powersOrderByWithAggregationInput | character_alchemy_powersOrderByWithAggregationInput[]
    by: Character_alchemy_powersScalarFieldEnum[] | Character_alchemy_powersScalarFieldEnum
    having?: character_alchemy_powersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Character_alchemy_powersCountAggregateInputType | true
    _min?: Character_alchemy_powersMinAggregateInputType
    _max?: Character_alchemy_powersMaxAggregateInputType
  }

  export type Character_alchemy_powersGroupByOutputType = {
    id: string
    char_id: string
    alchemy_power_id: string
    _count: Character_alchemy_powersCountAggregateOutputType | null
    _min: Character_alchemy_powersMinAggregateOutputType | null
    _max: Character_alchemy_powersMaxAggregateOutputType | null
  }

  type GetCharacter_alchemy_powersGroupByPayload<T extends character_alchemy_powersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Character_alchemy_powersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Character_alchemy_powersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Character_alchemy_powersGroupByOutputType[P]>
            : GetScalarType<T[P], Character_alchemy_powersGroupByOutputType[P]>
        }
      >
    >


  export type character_alchemy_powersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    char_id?: boolean
    alchemy_power_id?: boolean
    alchemy_powers?: boolean | alchemy_powersDefaultArgs<ExtArgs>
    characters?: boolean | charactersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character_alchemy_powers"]>

  export type character_alchemy_powersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    char_id?: boolean
    alchemy_power_id?: boolean
    alchemy_powers?: boolean | alchemy_powersDefaultArgs<ExtArgs>
    characters?: boolean | charactersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character_alchemy_powers"]>

  export type character_alchemy_powersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    char_id?: boolean
    alchemy_power_id?: boolean
    alchemy_powers?: boolean | alchemy_powersDefaultArgs<ExtArgs>
    characters?: boolean | charactersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character_alchemy_powers"]>

  export type character_alchemy_powersSelectScalar = {
    id?: boolean
    char_id?: boolean
    alchemy_power_id?: boolean
  }

  export type character_alchemy_powersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "char_id" | "alchemy_power_id", ExtArgs["result"]["character_alchemy_powers"]>
  export type character_alchemy_powersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alchemy_powers?: boolean | alchemy_powersDefaultArgs<ExtArgs>
    characters?: boolean | charactersDefaultArgs<ExtArgs>
  }
  export type character_alchemy_powersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alchemy_powers?: boolean | alchemy_powersDefaultArgs<ExtArgs>
    characters?: boolean | charactersDefaultArgs<ExtArgs>
  }
  export type character_alchemy_powersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alchemy_powers?: boolean | alchemy_powersDefaultArgs<ExtArgs>
    characters?: boolean | charactersDefaultArgs<ExtArgs>
  }

  export type $character_alchemy_powersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "character_alchemy_powers"
    objects: {
      alchemy_powers: Prisma.$alchemy_powersPayload<ExtArgs>
      characters: Prisma.$charactersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      char_id: string
      alchemy_power_id: string
    }, ExtArgs["result"]["character_alchemy_powers"]>
    composites: {}
  }

  type character_alchemy_powersGetPayload<S extends boolean | null | undefined | character_alchemy_powersDefaultArgs> = $Result.GetResult<Prisma.$character_alchemy_powersPayload, S>

  type character_alchemy_powersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<character_alchemy_powersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Character_alchemy_powersCountAggregateInputType | true
    }

  export interface character_alchemy_powersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['character_alchemy_powers'], meta: { name: 'character_alchemy_powers' } }
    /**
     * Find zero or one Character_alchemy_powers that matches the filter.
     * @param {character_alchemy_powersFindUniqueArgs} args - Arguments to find a Character_alchemy_powers
     * @example
     * // Get one Character_alchemy_powers
     * const character_alchemy_powers = await prisma.character_alchemy_powers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends character_alchemy_powersFindUniqueArgs>(args: SelectSubset<T, character_alchemy_powersFindUniqueArgs<ExtArgs>>): Prisma__character_alchemy_powersClient<$Result.GetResult<Prisma.$character_alchemy_powersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Character_alchemy_powers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {character_alchemy_powersFindUniqueOrThrowArgs} args - Arguments to find a Character_alchemy_powers
     * @example
     * // Get one Character_alchemy_powers
     * const character_alchemy_powers = await prisma.character_alchemy_powers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends character_alchemy_powersFindUniqueOrThrowArgs>(args: SelectSubset<T, character_alchemy_powersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__character_alchemy_powersClient<$Result.GetResult<Prisma.$character_alchemy_powersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Character_alchemy_powers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_alchemy_powersFindFirstArgs} args - Arguments to find a Character_alchemy_powers
     * @example
     * // Get one Character_alchemy_powers
     * const character_alchemy_powers = await prisma.character_alchemy_powers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends character_alchemy_powersFindFirstArgs>(args?: SelectSubset<T, character_alchemy_powersFindFirstArgs<ExtArgs>>): Prisma__character_alchemy_powersClient<$Result.GetResult<Prisma.$character_alchemy_powersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Character_alchemy_powers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_alchemy_powersFindFirstOrThrowArgs} args - Arguments to find a Character_alchemy_powers
     * @example
     * // Get one Character_alchemy_powers
     * const character_alchemy_powers = await prisma.character_alchemy_powers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends character_alchemy_powersFindFirstOrThrowArgs>(args?: SelectSubset<T, character_alchemy_powersFindFirstOrThrowArgs<ExtArgs>>): Prisma__character_alchemy_powersClient<$Result.GetResult<Prisma.$character_alchemy_powersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Character_alchemy_powers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_alchemy_powersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Character_alchemy_powers
     * const character_alchemy_powers = await prisma.character_alchemy_powers.findMany()
     * 
     * // Get first 10 Character_alchemy_powers
     * const character_alchemy_powers = await prisma.character_alchemy_powers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const character_alchemy_powersWithIdOnly = await prisma.character_alchemy_powers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends character_alchemy_powersFindManyArgs>(args?: SelectSubset<T, character_alchemy_powersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_alchemy_powersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Character_alchemy_powers.
     * @param {character_alchemy_powersCreateArgs} args - Arguments to create a Character_alchemy_powers.
     * @example
     * // Create one Character_alchemy_powers
     * const Character_alchemy_powers = await prisma.character_alchemy_powers.create({
     *   data: {
     *     // ... data to create a Character_alchemy_powers
     *   }
     * })
     * 
     */
    create<T extends character_alchemy_powersCreateArgs>(args: SelectSubset<T, character_alchemy_powersCreateArgs<ExtArgs>>): Prisma__character_alchemy_powersClient<$Result.GetResult<Prisma.$character_alchemy_powersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Character_alchemy_powers.
     * @param {character_alchemy_powersCreateManyArgs} args - Arguments to create many Character_alchemy_powers.
     * @example
     * // Create many Character_alchemy_powers
     * const character_alchemy_powers = await prisma.character_alchemy_powers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends character_alchemy_powersCreateManyArgs>(args?: SelectSubset<T, character_alchemy_powersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Character_alchemy_powers and returns the data saved in the database.
     * @param {character_alchemy_powersCreateManyAndReturnArgs} args - Arguments to create many Character_alchemy_powers.
     * @example
     * // Create many Character_alchemy_powers
     * const character_alchemy_powers = await prisma.character_alchemy_powers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Character_alchemy_powers and only return the `id`
     * const character_alchemy_powersWithIdOnly = await prisma.character_alchemy_powers.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends character_alchemy_powersCreateManyAndReturnArgs>(args?: SelectSubset<T, character_alchemy_powersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_alchemy_powersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Character_alchemy_powers.
     * @param {character_alchemy_powersDeleteArgs} args - Arguments to delete one Character_alchemy_powers.
     * @example
     * // Delete one Character_alchemy_powers
     * const Character_alchemy_powers = await prisma.character_alchemy_powers.delete({
     *   where: {
     *     // ... filter to delete one Character_alchemy_powers
     *   }
     * })
     * 
     */
    delete<T extends character_alchemy_powersDeleteArgs>(args: SelectSubset<T, character_alchemy_powersDeleteArgs<ExtArgs>>): Prisma__character_alchemy_powersClient<$Result.GetResult<Prisma.$character_alchemy_powersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Character_alchemy_powers.
     * @param {character_alchemy_powersUpdateArgs} args - Arguments to update one Character_alchemy_powers.
     * @example
     * // Update one Character_alchemy_powers
     * const character_alchemy_powers = await prisma.character_alchemy_powers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends character_alchemy_powersUpdateArgs>(args: SelectSubset<T, character_alchemy_powersUpdateArgs<ExtArgs>>): Prisma__character_alchemy_powersClient<$Result.GetResult<Prisma.$character_alchemy_powersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Character_alchemy_powers.
     * @param {character_alchemy_powersDeleteManyArgs} args - Arguments to filter Character_alchemy_powers to delete.
     * @example
     * // Delete a few Character_alchemy_powers
     * const { count } = await prisma.character_alchemy_powers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends character_alchemy_powersDeleteManyArgs>(args?: SelectSubset<T, character_alchemy_powersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Character_alchemy_powers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_alchemy_powersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Character_alchemy_powers
     * const character_alchemy_powers = await prisma.character_alchemy_powers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends character_alchemy_powersUpdateManyArgs>(args: SelectSubset<T, character_alchemy_powersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Character_alchemy_powers and returns the data updated in the database.
     * @param {character_alchemy_powersUpdateManyAndReturnArgs} args - Arguments to update many Character_alchemy_powers.
     * @example
     * // Update many Character_alchemy_powers
     * const character_alchemy_powers = await prisma.character_alchemy_powers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Character_alchemy_powers and only return the `id`
     * const character_alchemy_powersWithIdOnly = await prisma.character_alchemy_powers.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends character_alchemy_powersUpdateManyAndReturnArgs>(args: SelectSubset<T, character_alchemy_powersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_alchemy_powersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Character_alchemy_powers.
     * @param {character_alchemy_powersUpsertArgs} args - Arguments to update or create a Character_alchemy_powers.
     * @example
     * // Update or create a Character_alchemy_powers
     * const character_alchemy_powers = await prisma.character_alchemy_powers.upsert({
     *   create: {
     *     // ... data to create a Character_alchemy_powers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Character_alchemy_powers we want to update
     *   }
     * })
     */
    upsert<T extends character_alchemy_powersUpsertArgs>(args: SelectSubset<T, character_alchemy_powersUpsertArgs<ExtArgs>>): Prisma__character_alchemy_powersClient<$Result.GetResult<Prisma.$character_alchemy_powersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Character_alchemy_powers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_alchemy_powersCountArgs} args - Arguments to filter Character_alchemy_powers to count.
     * @example
     * // Count the number of Character_alchemy_powers
     * const count = await prisma.character_alchemy_powers.count({
     *   where: {
     *     // ... the filter for the Character_alchemy_powers we want to count
     *   }
     * })
    **/
    count<T extends character_alchemy_powersCountArgs>(
      args?: Subset<T, character_alchemy_powersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Character_alchemy_powersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Character_alchemy_powers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Character_alchemy_powersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Character_alchemy_powersAggregateArgs>(args: Subset<T, Character_alchemy_powersAggregateArgs>): Prisma.PrismaPromise<GetCharacter_alchemy_powersAggregateType<T>>

    /**
     * Group by Character_alchemy_powers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_alchemy_powersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends character_alchemy_powersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: character_alchemy_powersGroupByArgs['orderBy'] }
        : { orderBy?: character_alchemy_powersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, character_alchemy_powersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacter_alchemy_powersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the character_alchemy_powers model
   */
  readonly fields: character_alchemy_powersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for character_alchemy_powers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__character_alchemy_powersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    alchemy_powers<T extends alchemy_powersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, alchemy_powersDefaultArgs<ExtArgs>>): Prisma__alchemy_powersClient<$Result.GetResult<Prisma.$alchemy_powersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    characters<T extends charactersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, charactersDefaultArgs<ExtArgs>>): Prisma__charactersClient<$Result.GetResult<Prisma.$charactersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the character_alchemy_powers model
   */
  interface character_alchemy_powersFieldRefs {
    readonly id: FieldRef<"character_alchemy_powers", 'String'>
    readonly char_id: FieldRef<"character_alchemy_powers", 'String'>
    readonly alchemy_power_id: FieldRef<"character_alchemy_powers", 'String'>
  }
    

  // Custom InputTypes
  /**
   * character_alchemy_powers findUnique
   */
  export type character_alchemy_powersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_alchemy_powers
     */
    select?: character_alchemy_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_alchemy_powers
     */
    omit?: character_alchemy_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_alchemy_powersInclude<ExtArgs> | null
    /**
     * Filter, which character_alchemy_powers to fetch.
     */
    where: character_alchemy_powersWhereUniqueInput
  }

  /**
   * character_alchemy_powers findUniqueOrThrow
   */
  export type character_alchemy_powersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_alchemy_powers
     */
    select?: character_alchemy_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_alchemy_powers
     */
    omit?: character_alchemy_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_alchemy_powersInclude<ExtArgs> | null
    /**
     * Filter, which character_alchemy_powers to fetch.
     */
    where: character_alchemy_powersWhereUniqueInput
  }

  /**
   * character_alchemy_powers findFirst
   */
  export type character_alchemy_powersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_alchemy_powers
     */
    select?: character_alchemy_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_alchemy_powers
     */
    omit?: character_alchemy_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_alchemy_powersInclude<ExtArgs> | null
    /**
     * Filter, which character_alchemy_powers to fetch.
     */
    where?: character_alchemy_powersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_alchemy_powers to fetch.
     */
    orderBy?: character_alchemy_powersOrderByWithRelationInput | character_alchemy_powersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for character_alchemy_powers.
     */
    cursor?: character_alchemy_powersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_alchemy_powers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_alchemy_powers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of character_alchemy_powers.
     */
    distinct?: Character_alchemy_powersScalarFieldEnum | Character_alchemy_powersScalarFieldEnum[]
  }

  /**
   * character_alchemy_powers findFirstOrThrow
   */
  export type character_alchemy_powersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_alchemy_powers
     */
    select?: character_alchemy_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_alchemy_powers
     */
    omit?: character_alchemy_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_alchemy_powersInclude<ExtArgs> | null
    /**
     * Filter, which character_alchemy_powers to fetch.
     */
    where?: character_alchemy_powersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_alchemy_powers to fetch.
     */
    orderBy?: character_alchemy_powersOrderByWithRelationInput | character_alchemy_powersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for character_alchemy_powers.
     */
    cursor?: character_alchemy_powersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_alchemy_powers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_alchemy_powers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of character_alchemy_powers.
     */
    distinct?: Character_alchemy_powersScalarFieldEnum | Character_alchemy_powersScalarFieldEnum[]
  }

  /**
   * character_alchemy_powers findMany
   */
  export type character_alchemy_powersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_alchemy_powers
     */
    select?: character_alchemy_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_alchemy_powers
     */
    omit?: character_alchemy_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_alchemy_powersInclude<ExtArgs> | null
    /**
     * Filter, which character_alchemy_powers to fetch.
     */
    where?: character_alchemy_powersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_alchemy_powers to fetch.
     */
    orderBy?: character_alchemy_powersOrderByWithRelationInput | character_alchemy_powersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing character_alchemy_powers.
     */
    cursor?: character_alchemy_powersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_alchemy_powers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_alchemy_powers.
     */
    skip?: number
    distinct?: Character_alchemy_powersScalarFieldEnum | Character_alchemy_powersScalarFieldEnum[]
  }

  /**
   * character_alchemy_powers create
   */
  export type character_alchemy_powersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_alchemy_powers
     */
    select?: character_alchemy_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_alchemy_powers
     */
    omit?: character_alchemy_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_alchemy_powersInclude<ExtArgs> | null
    /**
     * The data needed to create a character_alchemy_powers.
     */
    data: XOR<character_alchemy_powersCreateInput, character_alchemy_powersUncheckedCreateInput>
  }

  /**
   * character_alchemy_powers createMany
   */
  export type character_alchemy_powersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many character_alchemy_powers.
     */
    data: character_alchemy_powersCreateManyInput | character_alchemy_powersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * character_alchemy_powers createManyAndReturn
   */
  export type character_alchemy_powersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_alchemy_powers
     */
    select?: character_alchemy_powersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the character_alchemy_powers
     */
    omit?: character_alchemy_powersOmit<ExtArgs> | null
    /**
     * The data used to create many character_alchemy_powers.
     */
    data: character_alchemy_powersCreateManyInput | character_alchemy_powersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_alchemy_powersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * character_alchemy_powers update
   */
  export type character_alchemy_powersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_alchemy_powers
     */
    select?: character_alchemy_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_alchemy_powers
     */
    omit?: character_alchemy_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_alchemy_powersInclude<ExtArgs> | null
    /**
     * The data needed to update a character_alchemy_powers.
     */
    data: XOR<character_alchemy_powersUpdateInput, character_alchemy_powersUncheckedUpdateInput>
    /**
     * Choose, which character_alchemy_powers to update.
     */
    where: character_alchemy_powersWhereUniqueInput
  }

  /**
   * character_alchemy_powers updateMany
   */
  export type character_alchemy_powersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update character_alchemy_powers.
     */
    data: XOR<character_alchemy_powersUpdateManyMutationInput, character_alchemy_powersUncheckedUpdateManyInput>
    /**
     * Filter which character_alchemy_powers to update
     */
    where?: character_alchemy_powersWhereInput
    /**
     * Limit how many character_alchemy_powers to update.
     */
    limit?: number
  }

  /**
   * character_alchemy_powers updateManyAndReturn
   */
  export type character_alchemy_powersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_alchemy_powers
     */
    select?: character_alchemy_powersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the character_alchemy_powers
     */
    omit?: character_alchemy_powersOmit<ExtArgs> | null
    /**
     * The data used to update character_alchemy_powers.
     */
    data: XOR<character_alchemy_powersUpdateManyMutationInput, character_alchemy_powersUncheckedUpdateManyInput>
    /**
     * Filter which character_alchemy_powers to update
     */
    where?: character_alchemy_powersWhereInput
    /**
     * Limit how many character_alchemy_powers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_alchemy_powersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * character_alchemy_powers upsert
   */
  export type character_alchemy_powersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_alchemy_powers
     */
    select?: character_alchemy_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_alchemy_powers
     */
    omit?: character_alchemy_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_alchemy_powersInclude<ExtArgs> | null
    /**
     * The filter to search for the character_alchemy_powers to update in case it exists.
     */
    where: character_alchemy_powersWhereUniqueInput
    /**
     * In case the character_alchemy_powers found by the `where` argument doesn't exist, create a new character_alchemy_powers with this data.
     */
    create: XOR<character_alchemy_powersCreateInput, character_alchemy_powersUncheckedCreateInput>
    /**
     * In case the character_alchemy_powers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<character_alchemy_powersUpdateInput, character_alchemy_powersUncheckedUpdateInput>
  }

  /**
   * character_alchemy_powers delete
   */
  export type character_alchemy_powersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_alchemy_powers
     */
    select?: character_alchemy_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_alchemy_powers
     */
    omit?: character_alchemy_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_alchemy_powersInclude<ExtArgs> | null
    /**
     * Filter which character_alchemy_powers to delete.
     */
    where: character_alchemy_powersWhereUniqueInput
  }

  /**
   * character_alchemy_powers deleteMany
   */
  export type character_alchemy_powersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which character_alchemy_powers to delete
     */
    where?: character_alchemy_powersWhereInput
    /**
     * Limit how many character_alchemy_powers to delete.
     */
    limit?: number
  }

  /**
   * character_alchemy_powers without action
   */
  export type character_alchemy_powersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_alchemy_powers
     */
    select?: character_alchemy_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_alchemy_powers
     */
    omit?: character_alchemy_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_alchemy_powersInclude<ExtArgs> | null
  }


  /**
   * Model character_attributes
   */

  export type AggregateCharacter_attributes = {
    _count: Character_attributesCountAggregateOutputType | null
    _avg: Character_attributesAvgAggregateOutputType | null
    _sum: Character_attributesSumAggregateOutputType | null
    _min: Character_attributesMinAggregateOutputType | null
    _max: Character_attributesMaxAggregateOutputType | null
  }

  export type Character_attributesAvgAggregateOutputType = {
    level: number | null
  }

  export type Character_attributesSumAggregateOutputType = {
    level: number | null
  }

  export type Character_attributesMinAggregateOutputType = {
    id: string | null
    char_id: string | null
    attribute_id: string | null
    level: number | null
  }

  export type Character_attributesMaxAggregateOutputType = {
    id: string | null
    char_id: string | null
    attribute_id: string | null
    level: number | null
  }

  export type Character_attributesCountAggregateOutputType = {
    id: number
    char_id: number
    attribute_id: number
    level: number
    _all: number
  }


  export type Character_attributesAvgAggregateInputType = {
    level?: true
  }

  export type Character_attributesSumAggregateInputType = {
    level?: true
  }

  export type Character_attributesMinAggregateInputType = {
    id?: true
    char_id?: true
    attribute_id?: true
    level?: true
  }

  export type Character_attributesMaxAggregateInputType = {
    id?: true
    char_id?: true
    attribute_id?: true
    level?: true
  }

  export type Character_attributesCountAggregateInputType = {
    id?: true
    char_id?: true
    attribute_id?: true
    level?: true
    _all?: true
  }

  export type Character_attributesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which character_attributes to aggregate.
     */
    where?: character_attributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_attributes to fetch.
     */
    orderBy?: character_attributesOrderByWithRelationInput | character_attributesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: character_attributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_attributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_attributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned character_attributes
    **/
    _count?: true | Character_attributesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Character_attributesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Character_attributesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Character_attributesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Character_attributesMaxAggregateInputType
  }

  export type GetCharacter_attributesAggregateType<T extends Character_attributesAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacter_attributes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacter_attributes[P]>
      : GetScalarType<T[P], AggregateCharacter_attributes[P]>
  }




  export type character_attributesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: character_attributesWhereInput
    orderBy?: character_attributesOrderByWithAggregationInput | character_attributesOrderByWithAggregationInput[]
    by: Character_attributesScalarFieldEnum[] | Character_attributesScalarFieldEnum
    having?: character_attributesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Character_attributesCountAggregateInputType | true
    _avg?: Character_attributesAvgAggregateInputType
    _sum?: Character_attributesSumAggregateInputType
    _min?: Character_attributesMinAggregateInputType
    _max?: Character_attributesMaxAggregateInputType
  }

  export type Character_attributesGroupByOutputType = {
    id: string
    char_id: string
    attribute_id: string
    level: number
    _count: Character_attributesCountAggregateOutputType | null
    _avg: Character_attributesAvgAggregateOutputType | null
    _sum: Character_attributesSumAggregateOutputType | null
    _min: Character_attributesMinAggregateOutputType | null
    _max: Character_attributesMaxAggregateOutputType | null
  }

  type GetCharacter_attributesGroupByPayload<T extends character_attributesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Character_attributesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Character_attributesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Character_attributesGroupByOutputType[P]>
            : GetScalarType<T[P], Character_attributesGroupByOutputType[P]>
        }
      >
    >


  export type character_attributesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    char_id?: boolean
    attribute_id?: boolean
    level?: boolean
    attributes?: boolean | attributesDefaultArgs<ExtArgs>
    characters?: boolean | charactersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character_attributes"]>

  export type character_attributesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    char_id?: boolean
    attribute_id?: boolean
    level?: boolean
    attributes?: boolean | attributesDefaultArgs<ExtArgs>
    characters?: boolean | charactersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character_attributes"]>

  export type character_attributesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    char_id?: boolean
    attribute_id?: boolean
    level?: boolean
    attributes?: boolean | attributesDefaultArgs<ExtArgs>
    characters?: boolean | charactersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character_attributes"]>

  export type character_attributesSelectScalar = {
    id?: boolean
    char_id?: boolean
    attribute_id?: boolean
    level?: boolean
  }

  export type character_attributesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "char_id" | "attribute_id" | "level", ExtArgs["result"]["character_attributes"]>
  export type character_attributesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attributes?: boolean | attributesDefaultArgs<ExtArgs>
    characters?: boolean | charactersDefaultArgs<ExtArgs>
  }
  export type character_attributesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attributes?: boolean | attributesDefaultArgs<ExtArgs>
    characters?: boolean | charactersDefaultArgs<ExtArgs>
  }
  export type character_attributesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attributes?: boolean | attributesDefaultArgs<ExtArgs>
    characters?: boolean | charactersDefaultArgs<ExtArgs>
  }

  export type $character_attributesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "character_attributes"
    objects: {
      attributes: Prisma.$attributesPayload<ExtArgs>
      characters: Prisma.$charactersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      char_id: string
      attribute_id: string
      level: number
    }, ExtArgs["result"]["character_attributes"]>
    composites: {}
  }

  type character_attributesGetPayload<S extends boolean | null | undefined | character_attributesDefaultArgs> = $Result.GetResult<Prisma.$character_attributesPayload, S>

  type character_attributesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<character_attributesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Character_attributesCountAggregateInputType | true
    }

  export interface character_attributesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['character_attributes'], meta: { name: 'character_attributes' } }
    /**
     * Find zero or one Character_attributes that matches the filter.
     * @param {character_attributesFindUniqueArgs} args - Arguments to find a Character_attributes
     * @example
     * // Get one Character_attributes
     * const character_attributes = await prisma.character_attributes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends character_attributesFindUniqueArgs>(args: SelectSubset<T, character_attributesFindUniqueArgs<ExtArgs>>): Prisma__character_attributesClient<$Result.GetResult<Prisma.$character_attributesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Character_attributes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {character_attributesFindUniqueOrThrowArgs} args - Arguments to find a Character_attributes
     * @example
     * // Get one Character_attributes
     * const character_attributes = await prisma.character_attributes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends character_attributesFindUniqueOrThrowArgs>(args: SelectSubset<T, character_attributesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__character_attributesClient<$Result.GetResult<Prisma.$character_attributesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Character_attributes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_attributesFindFirstArgs} args - Arguments to find a Character_attributes
     * @example
     * // Get one Character_attributes
     * const character_attributes = await prisma.character_attributes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends character_attributesFindFirstArgs>(args?: SelectSubset<T, character_attributesFindFirstArgs<ExtArgs>>): Prisma__character_attributesClient<$Result.GetResult<Prisma.$character_attributesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Character_attributes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_attributesFindFirstOrThrowArgs} args - Arguments to find a Character_attributes
     * @example
     * // Get one Character_attributes
     * const character_attributes = await prisma.character_attributes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends character_attributesFindFirstOrThrowArgs>(args?: SelectSubset<T, character_attributesFindFirstOrThrowArgs<ExtArgs>>): Prisma__character_attributesClient<$Result.GetResult<Prisma.$character_attributesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Character_attributes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_attributesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Character_attributes
     * const character_attributes = await prisma.character_attributes.findMany()
     * 
     * // Get first 10 Character_attributes
     * const character_attributes = await prisma.character_attributes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const character_attributesWithIdOnly = await prisma.character_attributes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends character_attributesFindManyArgs>(args?: SelectSubset<T, character_attributesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_attributesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Character_attributes.
     * @param {character_attributesCreateArgs} args - Arguments to create a Character_attributes.
     * @example
     * // Create one Character_attributes
     * const Character_attributes = await prisma.character_attributes.create({
     *   data: {
     *     // ... data to create a Character_attributes
     *   }
     * })
     * 
     */
    create<T extends character_attributesCreateArgs>(args: SelectSubset<T, character_attributesCreateArgs<ExtArgs>>): Prisma__character_attributesClient<$Result.GetResult<Prisma.$character_attributesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Character_attributes.
     * @param {character_attributesCreateManyArgs} args - Arguments to create many Character_attributes.
     * @example
     * // Create many Character_attributes
     * const character_attributes = await prisma.character_attributes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends character_attributesCreateManyArgs>(args?: SelectSubset<T, character_attributesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Character_attributes and returns the data saved in the database.
     * @param {character_attributesCreateManyAndReturnArgs} args - Arguments to create many Character_attributes.
     * @example
     * // Create many Character_attributes
     * const character_attributes = await prisma.character_attributes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Character_attributes and only return the `id`
     * const character_attributesWithIdOnly = await prisma.character_attributes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends character_attributesCreateManyAndReturnArgs>(args?: SelectSubset<T, character_attributesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_attributesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Character_attributes.
     * @param {character_attributesDeleteArgs} args - Arguments to delete one Character_attributes.
     * @example
     * // Delete one Character_attributes
     * const Character_attributes = await prisma.character_attributes.delete({
     *   where: {
     *     // ... filter to delete one Character_attributes
     *   }
     * })
     * 
     */
    delete<T extends character_attributesDeleteArgs>(args: SelectSubset<T, character_attributesDeleteArgs<ExtArgs>>): Prisma__character_attributesClient<$Result.GetResult<Prisma.$character_attributesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Character_attributes.
     * @param {character_attributesUpdateArgs} args - Arguments to update one Character_attributes.
     * @example
     * // Update one Character_attributes
     * const character_attributes = await prisma.character_attributes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends character_attributesUpdateArgs>(args: SelectSubset<T, character_attributesUpdateArgs<ExtArgs>>): Prisma__character_attributesClient<$Result.GetResult<Prisma.$character_attributesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Character_attributes.
     * @param {character_attributesDeleteManyArgs} args - Arguments to filter Character_attributes to delete.
     * @example
     * // Delete a few Character_attributes
     * const { count } = await prisma.character_attributes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends character_attributesDeleteManyArgs>(args?: SelectSubset<T, character_attributesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Character_attributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_attributesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Character_attributes
     * const character_attributes = await prisma.character_attributes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends character_attributesUpdateManyArgs>(args: SelectSubset<T, character_attributesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Character_attributes and returns the data updated in the database.
     * @param {character_attributesUpdateManyAndReturnArgs} args - Arguments to update many Character_attributes.
     * @example
     * // Update many Character_attributes
     * const character_attributes = await prisma.character_attributes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Character_attributes and only return the `id`
     * const character_attributesWithIdOnly = await prisma.character_attributes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends character_attributesUpdateManyAndReturnArgs>(args: SelectSubset<T, character_attributesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_attributesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Character_attributes.
     * @param {character_attributesUpsertArgs} args - Arguments to update or create a Character_attributes.
     * @example
     * // Update or create a Character_attributes
     * const character_attributes = await prisma.character_attributes.upsert({
     *   create: {
     *     // ... data to create a Character_attributes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Character_attributes we want to update
     *   }
     * })
     */
    upsert<T extends character_attributesUpsertArgs>(args: SelectSubset<T, character_attributesUpsertArgs<ExtArgs>>): Prisma__character_attributesClient<$Result.GetResult<Prisma.$character_attributesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Character_attributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_attributesCountArgs} args - Arguments to filter Character_attributes to count.
     * @example
     * // Count the number of Character_attributes
     * const count = await prisma.character_attributes.count({
     *   where: {
     *     // ... the filter for the Character_attributes we want to count
     *   }
     * })
    **/
    count<T extends character_attributesCountArgs>(
      args?: Subset<T, character_attributesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Character_attributesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Character_attributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Character_attributesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Character_attributesAggregateArgs>(args: Subset<T, Character_attributesAggregateArgs>): Prisma.PrismaPromise<GetCharacter_attributesAggregateType<T>>

    /**
     * Group by Character_attributes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_attributesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends character_attributesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: character_attributesGroupByArgs['orderBy'] }
        : { orderBy?: character_attributesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, character_attributesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacter_attributesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the character_attributes model
   */
  readonly fields: character_attributesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for character_attributes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__character_attributesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attributes<T extends attributesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, attributesDefaultArgs<ExtArgs>>): Prisma__attributesClient<$Result.GetResult<Prisma.$attributesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    characters<T extends charactersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, charactersDefaultArgs<ExtArgs>>): Prisma__charactersClient<$Result.GetResult<Prisma.$charactersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the character_attributes model
   */
  interface character_attributesFieldRefs {
    readonly id: FieldRef<"character_attributes", 'String'>
    readonly char_id: FieldRef<"character_attributes", 'String'>
    readonly attribute_id: FieldRef<"character_attributes", 'String'>
    readonly level: FieldRef<"character_attributes", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * character_attributes findUnique
   */
  export type character_attributesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_attributes
     */
    select?: character_attributesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_attributes
     */
    omit?: character_attributesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_attributesInclude<ExtArgs> | null
    /**
     * Filter, which character_attributes to fetch.
     */
    where: character_attributesWhereUniqueInput
  }

  /**
   * character_attributes findUniqueOrThrow
   */
  export type character_attributesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_attributes
     */
    select?: character_attributesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_attributes
     */
    omit?: character_attributesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_attributesInclude<ExtArgs> | null
    /**
     * Filter, which character_attributes to fetch.
     */
    where: character_attributesWhereUniqueInput
  }

  /**
   * character_attributes findFirst
   */
  export type character_attributesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_attributes
     */
    select?: character_attributesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_attributes
     */
    omit?: character_attributesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_attributesInclude<ExtArgs> | null
    /**
     * Filter, which character_attributes to fetch.
     */
    where?: character_attributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_attributes to fetch.
     */
    orderBy?: character_attributesOrderByWithRelationInput | character_attributesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for character_attributes.
     */
    cursor?: character_attributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_attributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_attributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of character_attributes.
     */
    distinct?: Character_attributesScalarFieldEnum | Character_attributesScalarFieldEnum[]
  }

  /**
   * character_attributes findFirstOrThrow
   */
  export type character_attributesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_attributes
     */
    select?: character_attributesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_attributes
     */
    omit?: character_attributesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_attributesInclude<ExtArgs> | null
    /**
     * Filter, which character_attributes to fetch.
     */
    where?: character_attributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_attributes to fetch.
     */
    orderBy?: character_attributesOrderByWithRelationInput | character_attributesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for character_attributes.
     */
    cursor?: character_attributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_attributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_attributes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of character_attributes.
     */
    distinct?: Character_attributesScalarFieldEnum | Character_attributesScalarFieldEnum[]
  }

  /**
   * character_attributes findMany
   */
  export type character_attributesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_attributes
     */
    select?: character_attributesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_attributes
     */
    omit?: character_attributesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_attributesInclude<ExtArgs> | null
    /**
     * Filter, which character_attributes to fetch.
     */
    where?: character_attributesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_attributes to fetch.
     */
    orderBy?: character_attributesOrderByWithRelationInput | character_attributesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing character_attributes.
     */
    cursor?: character_attributesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_attributes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_attributes.
     */
    skip?: number
    distinct?: Character_attributesScalarFieldEnum | Character_attributesScalarFieldEnum[]
  }

  /**
   * character_attributes create
   */
  export type character_attributesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_attributes
     */
    select?: character_attributesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_attributes
     */
    omit?: character_attributesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_attributesInclude<ExtArgs> | null
    /**
     * The data needed to create a character_attributes.
     */
    data: XOR<character_attributesCreateInput, character_attributesUncheckedCreateInput>
  }

  /**
   * character_attributes createMany
   */
  export type character_attributesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many character_attributes.
     */
    data: character_attributesCreateManyInput | character_attributesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * character_attributes createManyAndReturn
   */
  export type character_attributesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_attributes
     */
    select?: character_attributesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the character_attributes
     */
    omit?: character_attributesOmit<ExtArgs> | null
    /**
     * The data used to create many character_attributes.
     */
    data: character_attributesCreateManyInput | character_attributesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_attributesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * character_attributes update
   */
  export type character_attributesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_attributes
     */
    select?: character_attributesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_attributes
     */
    omit?: character_attributesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_attributesInclude<ExtArgs> | null
    /**
     * The data needed to update a character_attributes.
     */
    data: XOR<character_attributesUpdateInput, character_attributesUncheckedUpdateInput>
    /**
     * Choose, which character_attributes to update.
     */
    where: character_attributesWhereUniqueInput
  }

  /**
   * character_attributes updateMany
   */
  export type character_attributesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update character_attributes.
     */
    data: XOR<character_attributesUpdateManyMutationInput, character_attributesUncheckedUpdateManyInput>
    /**
     * Filter which character_attributes to update
     */
    where?: character_attributesWhereInput
    /**
     * Limit how many character_attributes to update.
     */
    limit?: number
  }

  /**
   * character_attributes updateManyAndReturn
   */
  export type character_attributesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_attributes
     */
    select?: character_attributesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the character_attributes
     */
    omit?: character_attributesOmit<ExtArgs> | null
    /**
     * The data used to update character_attributes.
     */
    data: XOR<character_attributesUpdateManyMutationInput, character_attributesUncheckedUpdateManyInput>
    /**
     * Filter which character_attributes to update
     */
    where?: character_attributesWhereInput
    /**
     * Limit how many character_attributes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_attributesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * character_attributes upsert
   */
  export type character_attributesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_attributes
     */
    select?: character_attributesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_attributes
     */
    omit?: character_attributesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_attributesInclude<ExtArgs> | null
    /**
     * The filter to search for the character_attributes to update in case it exists.
     */
    where: character_attributesWhereUniqueInput
    /**
     * In case the character_attributes found by the `where` argument doesn't exist, create a new character_attributes with this data.
     */
    create: XOR<character_attributesCreateInput, character_attributesUncheckedCreateInput>
    /**
     * In case the character_attributes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<character_attributesUpdateInput, character_attributesUncheckedUpdateInput>
  }

  /**
   * character_attributes delete
   */
  export type character_attributesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_attributes
     */
    select?: character_attributesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_attributes
     */
    omit?: character_attributesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_attributesInclude<ExtArgs> | null
    /**
     * Filter which character_attributes to delete.
     */
    where: character_attributesWhereUniqueInput
  }

  /**
   * character_attributes deleteMany
   */
  export type character_attributesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which character_attributes to delete
     */
    where?: character_attributesWhereInput
    /**
     * Limit how many character_attributes to delete.
     */
    limit?: number
  }

  /**
   * character_attributes without action
   */
  export type character_attributesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_attributes
     */
    select?: character_attributesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_attributes
     */
    omit?: character_attributesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_attributesInclude<ExtArgs> | null
  }


  /**
   * Model character_bloodpotencies
   */

  export type AggregateCharacter_bloodpotencies = {
    _count: Character_bloodpotenciesCountAggregateOutputType | null
    _avg: Character_bloodpotenciesAvgAggregateOutputType | null
    _sum: Character_bloodpotenciesSumAggregateOutputType | null
    _min: Character_bloodpotenciesMinAggregateOutputType | null
    _max: Character_bloodpotenciesMaxAggregateOutputType | null
  }

  export type Character_bloodpotenciesAvgAggregateOutputType = {
    bane_severity: number | null
    mend_amount: number | null
  }

  export type Character_bloodpotenciesSumAggregateOutputType = {
    bane_severity: number | null
    mend_amount: number | null
  }

  export type Character_bloodpotenciesMinAggregateOutputType = {
    id: string | null
    char_id: string | null
    blood_potency_level: string | null
    blood_surge: string | null
    bane_severity: number | null
    power_bonus: string | null
    feeding_penalty: string | null
    mend_amount: number | null
    rc_reroll: string | null
    clane_bane: string | null
    clan_compulsion: string | null
  }

  export type Character_bloodpotenciesMaxAggregateOutputType = {
    id: string | null
    char_id: string | null
    blood_potency_level: string | null
    blood_surge: string | null
    bane_severity: number | null
    power_bonus: string | null
    feeding_penalty: string | null
    mend_amount: number | null
    rc_reroll: string | null
    clane_bane: string | null
    clan_compulsion: string | null
  }

  export type Character_bloodpotenciesCountAggregateOutputType = {
    id: number
    char_id: number
    blood_potency_level: number
    blood_surge: number
    bane_severity: number
    power_bonus: number
    feeding_penalty: number
    mend_amount: number
    rc_reroll: number
    clane_bane: number
    clan_compulsion: number
    _all: number
  }


  export type Character_bloodpotenciesAvgAggregateInputType = {
    bane_severity?: true
    mend_amount?: true
  }

  export type Character_bloodpotenciesSumAggregateInputType = {
    bane_severity?: true
    mend_amount?: true
  }

  export type Character_bloodpotenciesMinAggregateInputType = {
    id?: true
    char_id?: true
    blood_potency_level?: true
    blood_surge?: true
    bane_severity?: true
    power_bonus?: true
    feeding_penalty?: true
    mend_amount?: true
    rc_reroll?: true
    clane_bane?: true
    clan_compulsion?: true
  }

  export type Character_bloodpotenciesMaxAggregateInputType = {
    id?: true
    char_id?: true
    blood_potency_level?: true
    blood_surge?: true
    bane_severity?: true
    power_bonus?: true
    feeding_penalty?: true
    mend_amount?: true
    rc_reroll?: true
    clane_bane?: true
    clan_compulsion?: true
  }

  export type Character_bloodpotenciesCountAggregateInputType = {
    id?: true
    char_id?: true
    blood_potency_level?: true
    blood_surge?: true
    bane_severity?: true
    power_bonus?: true
    feeding_penalty?: true
    mend_amount?: true
    rc_reroll?: true
    clane_bane?: true
    clan_compulsion?: true
    _all?: true
  }

  export type Character_bloodpotenciesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which character_bloodpotencies to aggregate.
     */
    where?: character_bloodpotenciesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_bloodpotencies to fetch.
     */
    orderBy?: character_bloodpotenciesOrderByWithRelationInput | character_bloodpotenciesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: character_bloodpotenciesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_bloodpotencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_bloodpotencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned character_bloodpotencies
    **/
    _count?: true | Character_bloodpotenciesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Character_bloodpotenciesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Character_bloodpotenciesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Character_bloodpotenciesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Character_bloodpotenciesMaxAggregateInputType
  }

  export type GetCharacter_bloodpotenciesAggregateType<T extends Character_bloodpotenciesAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacter_bloodpotencies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacter_bloodpotencies[P]>
      : GetScalarType<T[P], AggregateCharacter_bloodpotencies[P]>
  }




  export type character_bloodpotenciesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: character_bloodpotenciesWhereInput
    orderBy?: character_bloodpotenciesOrderByWithAggregationInput | character_bloodpotenciesOrderByWithAggregationInput[]
    by: Character_bloodpotenciesScalarFieldEnum[] | Character_bloodpotenciesScalarFieldEnum
    having?: character_bloodpotenciesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Character_bloodpotenciesCountAggregateInputType | true
    _avg?: Character_bloodpotenciesAvgAggregateInputType
    _sum?: Character_bloodpotenciesSumAggregateInputType
    _min?: Character_bloodpotenciesMinAggregateInputType
    _max?: Character_bloodpotenciesMaxAggregateInputType
  }

  export type Character_bloodpotenciesGroupByOutputType = {
    id: string
    char_id: string
    blood_potency_level: string | null
    blood_surge: string | null
    bane_severity: number | null
    power_bonus: string | null
    feeding_penalty: string | null
    mend_amount: number | null
    rc_reroll: string | null
    clane_bane: string | null
    clan_compulsion: string | null
    _count: Character_bloodpotenciesCountAggregateOutputType | null
    _avg: Character_bloodpotenciesAvgAggregateOutputType | null
    _sum: Character_bloodpotenciesSumAggregateOutputType | null
    _min: Character_bloodpotenciesMinAggregateOutputType | null
    _max: Character_bloodpotenciesMaxAggregateOutputType | null
  }

  type GetCharacter_bloodpotenciesGroupByPayload<T extends character_bloodpotenciesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Character_bloodpotenciesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Character_bloodpotenciesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Character_bloodpotenciesGroupByOutputType[P]>
            : GetScalarType<T[P], Character_bloodpotenciesGroupByOutputType[P]>
        }
      >
    >


  export type character_bloodpotenciesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    char_id?: boolean
    blood_potency_level?: boolean
    blood_surge?: boolean
    bane_severity?: boolean
    power_bonus?: boolean
    feeding_penalty?: boolean
    mend_amount?: boolean
    rc_reroll?: boolean
    clane_bane?: boolean
    clan_compulsion?: boolean
    blood_potency?: boolean | character_bloodpotencies$blood_potencyArgs<ExtArgs>
    characters?: boolean | charactersDefaultArgs<ExtArgs>
    clan_compulsions?: boolean | character_bloodpotencies$clan_compulsionsArgs<ExtArgs>
    clan_banes?: boolean | character_bloodpotencies$clan_banesArgs<ExtArgs>
  }, ExtArgs["result"]["character_bloodpotencies"]>

  export type character_bloodpotenciesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    char_id?: boolean
    blood_potency_level?: boolean
    blood_surge?: boolean
    bane_severity?: boolean
    power_bonus?: boolean
    feeding_penalty?: boolean
    mend_amount?: boolean
    rc_reroll?: boolean
    clane_bane?: boolean
    clan_compulsion?: boolean
    blood_potency?: boolean | character_bloodpotencies$blood_potencyArgs<ExtArgs>
    characters?: boolean | charactersDefaultArgs<ExtArgs>
    clan_compulsions?: boolean | character_bloodpotencies$clan_compulsionsArgs<ExtArgs>
    clan_banes?: boolean | character_bloodpotencies$clan_banesArgs<ExtArgs>
  }, ExtArgs["result"]["character_bloodpotencies"]>

  export type character_bloodpotenciesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    char_id?: boolean
    blood_potency_level?: boolean
    blood_surge?: boolean
    bane_severity?: boolean
    power_bonus?: boolean
    feeding_penalty?: boolean
    mend_amount?: boolean
    rc_reroll?: boolean
    clane_bane?: boolean
    clan_compulsion?: boolean
    blood_potency?: boolean | character_bloodpotencies$blood_potencyArgs<ExtArgs>
    characters?: boolean | charactersDefaultArgs<ExtArgs>
    clan_compulsions?: boolean | character_bloodpotencies$clan_compulsionsArgs<ExtArgs>
    clan_banes?: boolean | character_bloodpotencies$clan_banesArgs<ExtArgs>
  }, ExtArgs["result"]["character_bloodpotencies"]>

  export type character_bloodpotenciesSelectScalar = {
    id?: boolean
    char_id?: boolean
    blood_potency_level?: boolean
    blood_surge?: boolean
    bane_severity?: boolean
    power_bonus?: boolean
    feeding_penalty?: boolean
    mend_amount?: boolean
    rc_reroll?: boolean
    clane_bane?: boolean
    clan_compulsion?: boolean
  }

  export type character_bloodpotenciesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "char_id" | "blood_potency_level" | "blood_surge" | "bane_severity" | "power_bonus" | "feeding_penalty" | "mend_amount" | "rc_reroll" | "clane_bane" | "clan_compulsion", ExtArgs["result"]["character_bloodpotencies"]>
  export type character_bloodpotenciesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blood_potency?: boolean | character_bloodpotencies$blood_potencyArgs<ExtArgs>
    characters?: boolean | charactersDefaultArgs<ExtArgs>
    clan_compulsions?: boolean | character_bloodpotencies$clan_compulsionsArgs<ExtArgs>
    clan_banes?: boolean | character_bloodpotencies$clan_banesArgs<ExtArgs>
  }
  export type character_bloodpotenciesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blood_potency?: boolean | character_bloodpotencies$blood_potencyArgs<ExtArgs>
    characters?: boolean | charactersDefaultArgs<ExtArgs>
    clan_compulsions?: boolean | character_bloodpotencies$clan_compulsionsArgs<ExtArgs>
    clan_banes?: boolean | character_bloodpotencies$clan_banesArgs<ExtArgs>
  }
  export type character_bloodpotenciesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blood_potency?: boolean | character_bloodpotencies$blood_potencyArgs<ExtArgs>
    characters?: boolean | charactersDefaultArgs<ExtArgs>
    clan_compulsions?: boolean | character_bloodpotencies$clan_compulsionsArgs<ExtArgs>
    clan_banes?: boolean | character_bloodpotencies$clan_banesArgs<ExtArgs>
  }

  export type $character_bloodpotenciesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "character_bloodpotencies"
    objects: {
      blood_potency: Prisma.$blood_potencyPayload<ExtArgs> | null
      characters: Prisma.$charactersPayload<ExtArgs>
      clan_compulsions: Prisma.$clan_compulsionsPayload<ExtArgs> | null
      clan_banes: Prisma.$clan_banesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      char_id: string
      blood_potency_level: string | null
      blood_surge: string | null
      bane_severity: number | null
      power_bonus: string | null
      feeding_penalty: string | null
      mend_amount: number | null
      rc_reroll: string | null
      clane_bane: string | null
      clan_compulsion: string | null
    }, ExtArgs["result"]["character_bloodpotencies"]>
    composites: {}
  }

  type character_bloodpotenciesGetPayload<S extends boolean | null | undefined | character_bloodpotenciesDefaultArgs> = $Result.GetResult<Prisma.$character_bloodpotenciesPayload, S>

  type character_bloodpotenciesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<character_bloodpotenciesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Character_bloodpotenciesCountAggregateInputType | true
    }

  export interface character_bloodpotenciesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['character_bloodpotencies'], meta: { name: 'character_bloodpotencies' } }
    /**
     * Find zero or one Character_bloodpotencies that matches the filter.
     * @param {character_bloodpotenciesFindUniqueArgs} args - Arguments to find a Character_bloodpotencies
     * @example
     * // Get one Character_bloodpotencies
     * const character_bloodpotencies = await prisma.character_bloodpotencies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends character_bloodpotenciesFindUniqueArgs>(args: SelectSubset<T, character_bloodpotenciesFindUniqueArgs<ExtArgs>>): Prisma__character_bloodpotenciesClient<$Result.GetResult<Prisma.$character_bloodpotenciesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Character_bloodpotencies that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {character_bloodpotenciesFindUniqueOrThrowArgs} args - Arguments to find a Character_bloodpotencies
     * @example
     * // Get one Character_bloodpotencies
     * const character_bloodpotencies = await prisma.character_bloodpotencies.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends character_bloodpotenciesFindUniqueOrThrowArgs>(args: SelectSubset<T, character_bloodpotenciesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__character_bloodpotenciesClient<$Result.GetResult<Prisma.$character_bloodpotenciesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Character_bloodpotencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_bloodpotenciesFindFirstArgs} args - Arguments to find a Character_bloodpotencies
     * @example
     * // Get one Character_bloodpotencies
     * const character_bloodpotencies = await prisma.character_bloodpotencies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends character_bloodpotenciesFindFirstArgs>(args?: SelectSubset<T, character_bloodpotenciesFindFirstArgs<ExtArgs>>): Prisma__character_bloodpotenciesClient<$Result.GetResult<Prisma.$character_bloodpotenciesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Character_bloodpotencies that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_bloodpotenciesFindFirstOrThrowArgs} args - Arguments to find a Character_bloodpotencies
     * @example
     * // Get one Character_bloodpotencies
     * const character_bloodpotencies = await prisma.character_bloodpotencies.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends character_bloodpotenciesFindFirstOrThrowArgs>(args?: SelectSubset<T, character_bloodpotenciesFindFirstOrThrowArgs<ExtArgs>>): Prisma__character_bloodpotenciesClient<$Result.GetResult<Prisma.$character_bloodpotenciesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Character_bloodpotencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_bloodpotenciesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Character_bloodpotencies
     * const character_bloodpotencies = await prisma.character_bloodpotencies.findMany()
     * 
     * // Get first 10 Character_bloodpotencies
     * const character_bloodpotencies = await prisma.character_bloodpotencies.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const character_bloodpotenciesWithIdOnly = await prisma.character_bloodpotencies.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends character_bloodpotenciesFindManyArgs>(args?: SelectSubset<T, character_bloodpotenciesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_bloodpotenciesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Character_bloodpotencies.
     * @param {character_bloodpotenciesCreateArgs} args - Arguments to create a Character_bloodpotencies.
     * @example
     * // Create one Character_bloodpotencies
     * const Character_bloodpotencies = await prisma.character_bloodpotencies.create({
     *   data: {
     *     // ... data to create a Character_bloodpotencies
     *   }
     * })
     * 
     */
    create<T extends character_bloodpotenciesCreateArgs>(args: SelectSubset<T, character_bloodpotenciesCreateArgs<ExtArgs>>): Prisma__character_bloodpotenciesClient<$Result.GetResult<Prisma.$character_bloodpotenciesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Character_bloodpotencies.
     * @param {character_bloodpotenciesCreateManyArgs} args - Arguments to create many Character_bloodpotencies.
     * @example
     * // Create many Character_bloodpotencies
     * const character_bloodpotencies = await prisma.character_bloodpotencies.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends character_bloodpotenciesCreateManyArgs>(args?: SelectSubset<T, character_bloodpotenciesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Character_bloodpotencies and returns the data saved in the database.
     * @param {character_bloodpotenciesCreateManyAndReturnArgs} args - Arguments to create many Character_bloodpotencies.
     * @example
     * // Create many Character_bloodpotencies
     * const character_bloodpotencies = await prisma.character_bloodpotencies.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Character_bloodpotencies and only return the `id`
     * const character_bloodpotenciesWithIdOnly = await prisma.character_bloodpotencies.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends character_bloodpotenciesCreateManyAndReturnArgs>(args?: SelectSubset<T, character_bloodpotenciesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_bloodpotenciesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Character_bloodpotencies.
     * @param {character_bloodpotenciesDeleteArgs} args - Arguments to delete one Character_bloodpotencies.
     * @example
     * // Delete one Character_bloodpotencies
     * const Character_bloodpotencies = await prisma.character_bloodpotencies.delete({
     *   where: {
     *     // ... filter to delete one Character_bloodpotencies
     *   }
     * })
     * 
     */
    delete<T extends character_bloodpotenciesDeleteArgs>(args: SelectSubset<T, character_bloodpotenciesDeleteArgs<ExtArgs>>): Prisma__character_bloodpotenciesClient<$Result.GetResult<Prisma.$character_bloodpotenciesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Character_bloodpotencies.
     * @param {character_bloodpotenciesUpdateArgs} args - Arguments to update one Character_bloodpotencies.
     * @example
     * // Update one Character_bloodpotencies
     * const character_bloodpotencies = await prisma.character_bloodpotencies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends character_bloodpotenciesUpdateArgs>(args: SelectSubset<T, character_bloodpotenciesUpdateArgs<ExtArgs>>): Prisma__character_bloodpotenciesClient<$Result.GetResult<Prisma.$character_bloodpotenciesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Character_bloodpotencies.
     * @param {character_bloodpotenciesDeleteManyArgs} args - Arguments to filter Character_bloodpotencies to delete.
     * @example
     * // Delete a few Character_bloodpotencies
     * const { count } = await prisma.character_bloodpotencies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends character_bloodpotenciesDeleteManyArgs>(args?: SelectSubset<T, character_bloodpotenciesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Character_bloodpotencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_bloodpotenciesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Character_bloodpotencies
     * const character_bloodpotencies = await prisma.character_bloodpotencies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends character_bloodpotenciesUpdateManyArgs>(args: SelectSubset<T, character_bloodpotenciesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Character_bloodpotencies and returns the data updated in the database.
     * @param {character_bloodpotenciesUpdateManyAndReturnArgs} args - Arguments to update many Character_bloodpotencies.
     * @example
     * // Update many Character_bloodpotencies
     * const character_bloodpotencies = await prisma.character_bloodpotencies.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Character_bloodpotencies and only return the `id`
     * const character_bloodpotenciesWithIdOnly = await prisma.character_bloodpotencies.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends character_bloodpotenciesUpdateManyAndReturnArgs>(args: SelectSubset<T, character_bloodpotenciesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_bloodpotenciesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Character_bloodpotencies.
     * @param {character_bloodpotenciesUpsertArgs} args - Arguments to update or create a Character_bloodpotencies.
     * @example
     * // Update or create a Character_bloodpotencies
     * const character_bloodpotencies = await prisma.character_bloodpotencies.upsert({
     *   create: {
     *     // ... data to create a Character_bloodpotencies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Character_bloodpotencies we want to update
     *   }
     * })
     */
    upsert<T extends character_bloodpotenciesUpsertArgs>(args: SelectSubset<T, character_bloodpotenciesUpsertArgs<ExtArgs>>): Prisma__character_bloodpotenciesClient<$Result.GetResult<Prisma.$character_bloodpotenciesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Character_bloodpotencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_bloodpotenciesCountArgs} args - Arguments to filter Character_bloodpotencies to count.
     * @example
     * // Count the number of Character_bloodpotencies
     * const count = await prisma.character_bloodpotencies.count({
     *   where: {
     *     // ... the filter for the Character_bloodpotencies we want to count
     *   }
     * })
    **/
    count<T extends character_bloodpotenciesCountArgs>(
      args?: Subset<T, character_bloodpotenciesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Character_bloodpotenciesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Character_bloodpotencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Character_bloodpotenciesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Character_bloodpotenciesAggregateArgs>(args: Subset<T, Character_bloodpotenciesAggregateArgs>): Prisma.PrismaPromise<GetCharacter_bloodpotenciesAggregateType<T>>

    /**
     * Group by Character_bloodpotencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_bloodpotenciesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends character_bloodpotenciesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: character_bloodpotenciesGroupByArgs['orderBy'] }
        : { orderBy?: character_bloodpotenciesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, character_bloodpotenciesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacter_bloodpotenciesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the character_bloodpotencies model
   */
  readonly fields: character_bloodpotenciesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for character_bloodpotencies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__character_bloodpotenciesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    blood_potency<T extends character_bloodpotencies$blood_potencyArgs<ExtArgs> = {}>(args?: Subset<T, character_bloodpotencies$blood_potencyArgs<ExtArgs>>): Prisma__blood_potencyClient<$Result.GetResult<Prisma.$blood_potencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    characters<T extends charactersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, charactersDefaultArgs<ExtArgs>>): Prisma__charactersClient<$Result.GetResult<Prisma.$charactersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    clan_compulsions<T extends character_bloodpotencies$clan_compulsionsArgs<ExtArgs> = {}>(args?: Subset<T, character_bloodpotencies$clan_compulsionsArgs<ExtArgs>>): Prisma__clan_compulsionsClient<$Result.GetResult<Prisma.$clan_compulsionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    clan_banes<T extends character_bloodpotencies$clan_banesArgs<ExtArgs> = {}>(args?: Subset<T, character_bloodpotencies$clan_banesArgs<ExtArgs>>): Prisma__clan_banesClient<$Result.GetResult<Prisma.$clan_banesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the character_bloodpotencies model
   */
  interface character_bloodpotenciesFieldRefs {
    readonly id: FieldRef<"character_bloodpotencies", 'String'>
    readonly char_id: FieldRef<"character_bloodpotencies", 'String'>
    readonly blood_potency_level: FieldRef<"character_bloodpotencies", 'String'>
    readonly blood_surge: FieldRef<"character_bloodpotencies", 'String'>
    readonly bane_severity: FieldRef<"character_bloodpotencies", 'Int'>
    readonly power_bonus: FieldRef<"character_bloodpotencies", 'String'>
    readonly feeding_penalty: FieldRef<"character_bloodpotencies", 'String'>
    readonly mend_amount: FieldRef<"character_bloodpotencies", 'Int'>
    readonly rc_reroll: FieldRef<"character_bloodpotencies", 'String'>
    readonly clane_bane: FieldRef<"character_bloodpotencies", 'String'>
    readonly clan_compulsion: FieldRef<"character_bloodpotencies", 'String'>
  }
    

  // Custom InputTypes
  /**
   * character_bloodpotencies findUnique
   */
  export type character_bloodpotenciesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_bloodpotencies
     */
    select?: character_bloodpotenciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_bloodpotencies
     */
    omit?: character_bloodpotenciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_bloodpotenciesInclude<ExtArgs> | null
    /**
     * Filter, which character_bloodpotencies to fetch.
     */
    where: character_bloodpotenciesWhereUniqueInput
  }

  /**
   * character_bloodpotencies findUniqueOrThrow
   */
  export type character_bloodpotenciesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_bloodpotencies
     */
    select?: character_bloodpotenciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_bloodpotencies
     */
    omit?: character_bloodpotenciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_bloodpotenciesInclude<ExtArgs> | null
    /**
     * Filter, which character_bloodpotencies to fetch.
     */
    where: character_bloodpotenciesWhereUniqueInput
  }

  /**
   * character_bloodpotencies findFirst
   */
  export type character_bloodpotenciesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_bloodpotencies
     */
    select?: character_bloodpotenciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_bloodpotencies
     */
    omit?: character_bloodpotenciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_bloodpotenciesInclude<ExtArgs> | null
    /**
     * Filter, which character_bloodpotencies to fetch.
     */
    where?: character_bloodpotenciesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_bloodpotencies to fetch.
     */
    orderBy?: character_bloodpotenciesOrderByWithRelationInput | character_bloodpotenciesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for character_bloodpotencies.
     */
    cursor?: character_bloodpotenciesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_bloodpotencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_bloodpotencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of character_bloodpotencies.
     */
    distinct?: Character_bloodpotenciesScalarFieldEnum | Character_bloodpotenciesScalarFieldEnum[]
  }

  /**
   * character_bloodpotencies findFirstOrThrow
   */
  export type character_bloodpotenciesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_bloodpotencies
     */
    select?: character_bloodpotenciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_bloodpotencies
     */
    omit?: character_bloodpotenciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_bloodpotenciesInclude<ExtArgs> | null
    /**
     * Filter, which character_bloodpotencies to fetch.
     */
    where?: character_bloodpotenciesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_bloodpotencies to fetch.
     */
    orderBy?: character_bloodpotenciesOrderByWithRelationInput | character_bloodpotenciesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for character_bloodpotencies.
     */
    cursor?: character_bloodpotenciesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_bloodpotencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_bloodpotencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of character_bloodpotencies.
     */
    distinct?: Character_bloodpotenciesScalarFieldEnum | Character_bloodpotenciesScalarFieldEnum[]
  }

  /**
   * character_bloodpotencies findMany
   */
  export type character_bloodpotenciesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_bloodpotencies
     */
    select?: character_bloodpotenciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_bloodpotencies
     */
    omit?: character_bloodpotenciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_bloodpotenciesInclude<ExtArgs> | null
    /**
     * Filter, which character_bloodpotencies to fetch.
     */
    where?: character_bloodpotenciesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_bloodpotencies to fetch.
     */
    orderBy?: character_bloodpotenciesOrderByWithRelationInput | character_bloodpotenciesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing character_bloodpotencies.
     */
    cursor?: character_bloodpotenciesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_bloodpotencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_bloodpotencies.
     */
    skip?: number
    distinct?: Character_bloodpotenciesScalarFieldEnum | Character_bloodpotenciesScalarFieldEnum[]
  }

  /**
   * character_bloodpotencies create
   */
  export type character_bloodpotenciesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_bloodpotencies
     */
    select?: character_bloodpotenciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_bloodpotencies
     */
    omit?: character_bloodpotenciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_bloodpotenciesInclude<ExtArgs> | null
    /**
     * The data needed to create a character_bloodpotencies.
     */
    data: XOR<character_bloodpotenciesCreateInput, character_bloodpotenciesUncheckedCreateInput>
  }

  /**
   * character_bloodpotencies createMany
   */
  export type character_bloodpotenciesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many character_bloodpotencies.
     */
    data: character_bloodpotenciesCreateManyInput | character_bloodpotenciesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * character_bloodpotencies createManyAndReturn
   */
  export type character_bloodpotenciesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_bloodpotencies
     */
    select?: character_bloodpotenciesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the character_bloodpotencies
     */
    omit?: character_bloodpotenciesOmit<ExtArgs> | null
    /**
     * The data used to create many character_bloodpotencies.
     */
    data: character_bloodpotenciesCreateManyInput | character_bloodpotenciesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_bloodpotenciesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * character_bloodpotencies update
   */
  export type character_bloodpotenciesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_bloodpotencies
     */
    select?: character_bloodpotenciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_bloodpotencies
     */
    omit?: character_bloodpotenciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_bloodpotenciesInclude<ExtArgs> | null
    /**
     * The data needed to update a character_bloodpotencies.
     */
    data: XOR<character_bloodpotenciesUpdateInput, character_bloodpotenciesUncheckedUpdateInput>
    /**
     * Choose, which character_bloodpotencies to update.
     */
    where: character_bloodpotenciesWhereUniqueInput
  }

  /**
   * character_bloodpotencies updateMany
   */
  export type character_bloodpotenciesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update character_bloodpotencies.
     */
    data: XOR<character_bloodpotenciesUpdateManyMutationInput, character_bloodpotenciesUncheckedUpdateManyInput>
    /**
     * Filter which character_bloodpotencies to update
     */
    where?: character_bloodpotenciesWhereInput
    /**
     * Limit how many character_bloodpotencies to update.
     */
    limit?: number
  }

  /**
   * character_bloodpotencies updateManyAndReturn
   */
  export type character_bloodpotenciesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_bloodpotencies
     */
    select?: character_bloodpotenciesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the character_bloodpotencies
     */
    omit?: character_bloodpotenciesOmit<ExtArgs> | null
    /**
     * The data used to update character_bloodpotencies.
     */
    data: XOR<character_bloodpotenciesUpdateManyMutationInput, character_bloodpotenciesUncheckedUpdateManyInput>
    /**
     * Filter which character_bloodpotencies to update
     */
    where?: character_bloodpotenciesWhereInput
    /**
     * Limit how many character_bloodpotencies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_bloodpotenciesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * character_bloodpotencies upsert
   */
  export type character_bloodpotenciesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_bloodpotencies
     */
    select?: character_bloodpotenciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_bloodpotencies
     */
    omit?: character_bloodpotenciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_bloodpotenciesInclude<ExtArgs> | null
    /**
     * The filter to search for the character_bloodpotencies to update in case it exists.
     */
    where: character_bloodpotenciesWhereUniqueInput
    /**
     * In case the character_bloodpotencies found by the `where` argument doesn't exist, create a new character_bloodpotencies with this data.
     */
    create: XOR<character_bloodpotenciesCreateInput, character_bloodpotenciesUncheckedCreateInput>
    /**
     * In case the character_bloodpotencies was found with the provided `where` argument, update it with this data.
     */
    update: XOR<character_bloodpotenciesUpdateInput, character_bloodpotenciesUncheckedUpdateInput>
  }

  /**
   * character_bloodpotencies delete
   */
  export type character_bloodpotenciesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_bloodpotencies
     */
    select?: character_bloodpotenciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_bloodpotencies
     */
    omit?: character_bloodpotenciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_bloodpotenciesInclude<ExtArgs> | null
    /**
     * Filter which character_bloodpotencies to delete.
     */
    where: character_bloodpotenciesWhereUniqueInput
  }

  /**
   * character_bloodpotencies deleteMany
   */
  export type character_bloodpotenciesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which character_bloodpotencies to delete
     */
    where?: character_bloodpotenciesWhereInput
    /**
     * Limit how many character_bloodpotencies to delete.
     */
    limit?: number
  }

  /**
   * character_bloodpotencies.blood_potency
   */
  export type character_bloodpotencies$blood_potencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blood_potency
     */
    select?: blood_potencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the blood_potency
     */
    omit?: blood_potencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blood_potencyInclude<ExtArgs> | null
    where?: blood_potencyWhereInput
  }

  /**
   * character_bloodpotencies.clan_compulsions
   */
  export type character_bloodpotencies$clan_compulsionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clan_compulsions
     */
    select?: clan_compulsionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clan_compulsions
     */
    omit?: clan_compulsionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clan_compulsionsInclude<ExtArgs> | null
    where?: clan_compulsionsWhereInput
  }

  /**
   * character_bloodpotencies.clan_banes
   */
  export type character_bloodpotencies$clan_banesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clan_banes
     */
    select?: clan_banesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clan_banes
     */
    omit?: clan_banesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clan_banesInclude<ExtArgs> | null
    where?: clan_banesWhereInput
  }

  /**
   * character_bloodpotencies without action
   */
  export type character_bloodpotenciesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_bloodpotencies
     */
    select?: character_bloodpotenciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_bloodpotencies
     */
    omit?: character_bloodpotenciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_bloodpotenciesInclude<ExtArgs> | null
  }


  /**
   * Model character_discipline_powers
   */

  export type AggregateCharacter_discipline_powers = {
    _count: Character_discipline_powersCountAggregateOutputType | null
    _min: Character_discipline_powersMinAggregateOutputType | null
    _max: Character_discipline_powersMaxAggregateOutputType | null
  }

  export type Character_discipline_powersMinAggregateOutputType = {
    id: string | null
    char_id: string | null
    discipline_power_id: string | null
  }

  export type Character_discipline_powersMaxAggregateOutputType = {
    id: string | null
    char_id: string | null
    discipline_power_id: string | null
  }

  export type Character_discipline_powersCountAggregateOutputType = {
    id: number
    char_id: number
    discipline_power_id: number
    _all: number
  }


  export type Character_discipline_powersMinAggregateInputType = {
    id?: true
    char_id?: true
    discipline_power_id?: true
  }

  export type Character_discipline_powersMaxAggregateInputType = {
    id?: true
    char_id?: true
    discipline_power_id?: true
  }

  export type Character_discipline_powersCountAggregateInputType = {
    id?: true
    char_id?: true
    discipline_power_id?: true
    _all?: true
  }

  export type Character_discipline_powersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which character_discipline_powers to aggregate.
     */
    where?: character_discipline_powersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_discipline_powers to fetch.
     */
    orderBy?: character_discipline_powersOrderByWithRelationInput | character_discipline_powersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: character_discipline_powersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_discipline_powers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_discipline_powers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned character_discipline_powers
    **/
    _count?: true | Character_discipline_powersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Character_discipline_powersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Character_discipline_powersMaxAggregateInputType
  }

  export type GetCharacter_discipline_powersAggregateType<T extends Character_discipline_powersAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacter_discipline_powers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacter_discipline_powers[P]>
      : GetScalarType<T[P], AggregateCharacter_discipline_powers[P]>
  }




  export type character_discipline_powersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: character_discipline_powersWhereInput
    orderBy?: character_discipline_powersOrderByWithAggregationInput | character_discipline_powersOrderByWithAggregationInput[]
    by: Character_discipline_powersScalarFieldEnum[] | Character_discipline_powersScalarFieldEnum
    having?: character_discipline_powersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Character_discipline_powersCountAggregateInputType | true
    _min?: Character_discipline_powersMinAggregateInputType
    _max?: Character_discipline_powersMaxAggregateInputType
  }

  export type Character_discipline_powersGroupByOutputType = {
    id: string
    char_id: string
    discipline_power_id: string
    _count: Character_discipline_powersCountAggregateOutputType | null
    _min: Character_discipline_powersMinAggregateOutputType | null
    _max: Character_discipline_powersMaxAggregateOutputType | null
  }

  type GetCharacter_discipline_powersGroupByPayload<T extends character_discipline_powersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Character_discipline_powersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Character_discipline_powersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Character_discipline_powersGroupByOutputType[P]>
            : GetScalarType<T[P], Character_discipline_powersGroupByOutputType[P]>
        }
      >
    >


  export type character_discipline_powersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    char_id?: boolean
    discipline_power_id?: boolean
    characters?: boolean | charactersDefaultArgs<ExtArgs>
    discipline_powers?: boolean | discipline_powersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character_discipline_powers"]>

  export type character_discipline_powersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    char_id?: boolean
    discipline_power_id?: boolean
    characters?: boolean | charactersDefaultArgs<ExtArgs>
    discipline_powers?: boolean | discipline_powersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character_discipline_powers"]>

  export type character_discipline_powersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    char_id?: boolean
    discipline_power_id?: boolean
    characters?: boolean | charactersDefaultArgs<ExtArgs>
    discipline_powers?: boolean | discipline_powersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character_discipline_powers"]>

  export type character_discipline_powersSelectScalar = {
    id?: boolean
    char_id?: boolean
    discipline_power_id?: boolean
  }

  export type character_discipline_powersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "char_id" | "discipline_power_id", ExtArgs["result"]["character_discipline_powers"]>
  export type character_discipline_powersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | charactersDefaultArgs<ExtArgs>
    discipline_powers?: boolean | discipline_powersDefaultArgs<ExtArgs>
  }
  export type character_discipline_powersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | charactersDefaultArgs<ExtArgs>
    discipline_powers?: boolean | discipline_powersDefaultArgs<ExtArgs>
  }
  export type character_discipline_powersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | charactersDefaultArgs<ExtArgs>
    discipline_powers?: boolean | discipline_powersDefaultArgs<ExtArgs>
  }

  export type $character_discipline_powersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "character_discipline_powers"
    objects: {
      characters: Prisma.$charactersPayload<ExtArgs>
      discipline_powers: Prisma.$discipline_powersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      char_id: string
      discipline_power_id: string
    }, ExtArgs["result"]["character_discipline_powers"]>
    composites: {}
  }

  type character_discipline_powersGetPayload<S extends boolean | null | undefined | character_discipline_powersDefaultArgs> = $Result.GetResult<Prisma.$character_discipline_powersPayload, S>

  type character_discipline_powersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<character_discipline_powersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Character_discipline_powersCountAggregateInputType | true
    }

  export interface character_discipline_powersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['character_discipline_powers'], meta: { name: 'character_discipline_powers' } }
    /**
     * Find zero or one Character_discipline_powers that matches the filter.
     * @param {character_discipline_powersFindUniqueArgs} args - Arguments to find a Character_discipline_powers
     * @example
     * // Get one Character_discipline_powers
     * const character_discipline_powers = await prisma.character_discipline_powers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends character_discipline_powersFindUniqueArgs>(args: SelectSubset<T, character_discipline_powersFindUniqueArgs<ExtArgs>>): Prisma__character_discipline_powersClient<$Result.GetResult<Prisma.$character_discipline_powersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Character_discipline_powers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {character_discipline_powersFindUniqueOrThrowArgs} args - Arguments to find a Character_discipline_powers
     * @example
     * // Get one Character_discipline_powers
     * const character_discipline_powers = await prisma.character_discipline_powers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends character_discipline_powersFindUniqueOrThrowArgs>(args: SelectSubset<T, character_discipline_powersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__character_discipline_powersClient<$Result.GetResult<Prisma.$character_discipline_powersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Character_discipline_powers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_discipline_powersFindFirstArgs} args - Arguments to find a Character_discipline_powers
     * @example
     * // Get one Character_discipline_powers
     * const character_discipline_powers = await prisma.character_discipline_powers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends character_discipline_powersFindFirstArgs>(args?: SelectSubset<T, character_discipline_powersFindFirstArgs<ExtArgs>>): Prisma__character_discipline_powersClient<$Result.GetResult<Prisma.$character_discipline_powersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Character_discipline_powers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_discipline_powersFindFirstOrThrowArgs} args - Arguments to find a Character_discipline_powers
     * @example
     * // Get one Character_discipline_powers
     * const character_discipline_powers = await prisma.character_discipline_powers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends character_discipline_powersFindFirstOrThrowArgs>(args?: SelectSubset<T, character_discipline_powersFindFirstOrThrowArgs<ExtArgs>>): Prisma__character_discipline_powersClient<$Result.GetResult<Prisma.$character_discipline_powersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Character_discipline_powers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_discipline_powersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Character_discipline_powers
     * const character_discipline_powers = await prisma.character_discipline_powers.findMany()
     * 
     * // Get first 10 Character_discipline_powers
     * const character_discipline_powers = await prisma.character_discipline_powers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const character_discipline_powersWithIdOnly = await prisma.character_discipline_powers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends character_discipline_powersFindManyArgs>(args?: SelectSubset<T, character_discipline_powersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_discipline_powersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Character_discipline_powers.
     * @param {character_discipline_powersCreateArgs} args - Arguments to create a Character_discipline_powers.
     * @example
     * // Create one Character_discipline_powers
     * const Character_discipline_powers = await prisma.character_discipline_powers.create({
     *   data: {
     *     // ... data to create a Character_discipline_powers
     *   }
     * })
     * 
     */
    create<T extends character_discipline_powersCreateArgs>(args: SelectSubset<T, character_discipline_powersCreateArgs<ExtArgs>>): Prisma__character_discipline_powersClient<$Result.GetResult<Prisma.$character_discipline_powersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Character_discipline_powers.
     * @param {character_discipline_powersCreateManyArgs} args - Arguments to create many Character_discipline_powers.
     * @example
     * // Create many Character_discipline_powers
     * const character_discipline_powers = await prisma.character_discipline_powers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends character_discipline_powersCreateManyArgs>(args?: SelectSubset<T, character_discipline_powersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Character_discipline_powers and returns the data saved in the database.
     * @param {character_discipline_powersCreateManyAndReturnArgs} args - Arguments to create many Character_discipline_powers.
     * @example
     * // Create many Character_discipline_powers
     * const character_discipline_powers = await prisma.character_discipline_powers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Character_discipline_powers and only return the `id`
     * const character_discipline_powersWithIdOnly = await prisma.character_discipline_powers.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends character_discipline_powersCreateManyAndReturnArgs>(args?: SelectSubset<T, character_discipline_powersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_discipline_powersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Character_discipline_powers.
     * @param {character_discipline_powersDeleteArgs} args - Arguments to delete one Character_discipline_powers.
     * @example
     * // Delete one Character_discipline_powers
     * const Character_discipline_powers = await prisma.character_discipline_powers.delete({
     *   where: {
     *     // ... filter to delete one Character_discipline_powers
     *   }
     * })
     * 
     */
    delete<T extends character_discipline_powersDeleteArgs>(args: SelectSubset<T, character_discipline_powersDeleteArgs<ExtArgs>>): Prisma__character_discipline_powersClient<$Result.GetResult<Prisma.$character_discipline_powersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Character_discipline_powers.
     * @param {character_discipline_powersUpdateArgs} args - Arguments to update one Character_discipline_powers.
     * @example
     * // Update one Character_discipline_powers
     * const character_discipline_powers = await prisma.character_discipline_powers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends character_discipline_powersUpdateArgs>(args: SelectSubset<T, character_discipline_powersUpdateArgs<ExtArgs>>): Prisma__character_discipline_powersClient<$Result.GetResult<Prisma.$character_discipline_powersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Character_discipline_powers.
     * @param {character_discipline_powersDeleteManyArgs} args - Arguments to filter Character_discipline_powers to delete.
     * @example
     * // Delete a few Character_discipline_powers
     * const { count } = await prisma.character_discipline_powers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends character_discipline_powersDeleteManyArgs>(args?: SelectSubset<T, character_discipline_powersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Character_discipline_powers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_discipline_powersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Character_discipline_powers
     * const character_discipline_powers = await prisma.character_discipline_powers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends character_discipline_powersUpdateManyArgs>(args: SelectSubset<T, character_discipline_powersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Character_discipline_powers and returns the data updated in the database.
     * @param {character_discipline_powersUpdateManyAndReturnArgs} args - Arguments to update many Character_discipline_powers.
     * @example
     * // Update many Character_discipline_powers
     * const character_discipline_powers = await prisma.character_discipline_powers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Character_discipline_powers and only return the `id`
     * const character_discipline_powersWithIdOnly = await prisma.character_discipline_powers.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends character_discipline_powersUpdateManyAndReturnArgs>(args: SelectSubset<T, character_discipline_powersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_discipline_powersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Character_discipline_powers.
     * @param {character_discipline_powersUpsertArgs} args - Arguments to update or create a Character_discipline_powers.
     * @example
     * // Update or create a Character_discipline_powers
     * const character_discipline_powers = await prisma.character_discipline_powers.upsert({
     *   create: {
     *     // ... data to create a Character_discipline_powers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Character_discipline_powers we want to update
     *   }
     * })
     */
    upsert<T extends character_discipline_powersUpsertArgs>(args: SelectSubset<T, character_discipline_powersUpsertArgs<ExtArgs>>): Prisma__character_discipline_powersClient<$Result.GetResult<Prisma.$character_discipline_powersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Character_discipline_powers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_discipline_powersCountArgs} args - Arguments to filter Character_discipline_powers to count.
     * @example
     * // Count the number of Character_discipline_powers
     * const count = await prisma.character_discipline_powers.count({
     *   where: {
     *     // ... the filter for the Character_discipline_powers we want to count
     *   }
     * })
    **/
    count<T extends character_discipline_powersCountArgs>(
      args?: Subset<T, character_discipline_powersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Character_discipline_powersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Character_discipline_powers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Character_discipline_powersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Character_discipline_powersAggregateArgs>(args: Subset<T, Character_discipline_powersAggregateArgs>): Prisma.PrismaPromise<GetCharacter_discipline_powersAggregateType<T>>

    /**
     * Group by Character_discipline_powers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_discipline_powersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends character_discipline_powersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: character_discipline_powersGroupByArgs['orderBy'] }
        : { orderBy?: character_discipline_powersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, character_discipline_powersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacter_discipline_powersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the character_discipline_powers model
   */
  readonly fields: character_discipline_powersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for character_discipline_powers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__character_discipline_powersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    characters<T extends charactersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, charactersDefaultArgs<ExtArgs>>): Prisma__charactersClient<$Result.GetResult<Prisma.$charactersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    discipline_powers<T extends discipline_powersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, discipline_powersDefaultArgs<ExtArgs>>): Prisma__discipline_powersClient<$Result.GetResult<Prisma.$discipline_powersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the character_discipline_powers model
   */
  interface character_discipline_powersFieldRefs {
    readonly id: FieldRef<"character_discipline_powers", 'String'>
    readonly char_id: FieldRef<"character_discipline_powers", 'String'>
    readonly discipline_power_id: FieldRef<"character_discipline_powers", 'String'>
  }
    

  // Custom InputTypes
  /**
   * character_discipline_powers findUnique
   */
  export type character_discipline_powersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_discipline_powers
     */
    select?: character_discipline_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_discipline_powers
     */
    omit?: character_discipline_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_discipline_powersInclude<ExtArgs> | null
    /**
     * Filter, which character_discipline_powers to fetch.
     */
    where: character_discipline_powersWhereUniqueInput
  }

  /**
   * character_discipline_powers findUniqueOrThrow
   */
  export type character_discipline_powersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_discipline_powers
     */
    select?: character_discipline_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_discipline_powers
     */
    omit?: character_discipline_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_discipline_powersInclude<ExtArgs> | null
    /**
     * Filter, which character_discipline_powers to fetch.
     */
    where: character_discipline_powersWhereUniqueInput
  }

  /**
   * character_discipline_powers findFirst
   */
  export type character_discipline_powersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_discipline_powers
     */
    select?: character_discipline_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_discipline_powers
     */
    omit?: character_discipline_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_discipline_powersInclude<ExtArgs> | null
    /**
     * Filter, which character_discipline_powers to fetch.
     */
    where?: character_discipline_powersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_discipline_powers to fetch.
     */
    orderBy?: character_discipline_powersOrderByWithRelationInput | character_discipline_powersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for character_discipline_powers.
     */
    cursor?: character_discipline_powersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_discipline_powers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_discipline_powers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of character_discipline_powers.
     */
    distinct?: Character_discipline_powersScalarFieldEnum | Character_discipline_powersScalarFieldEnum[]
  }

  /**
   * character_discipline_powers findFirstOrThrow
   */
  export type character_discipline_powersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_discipline_powers
     */
    select?: character_discipline_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_discipline_powers
     */
    omit?: character_discipline_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_discipline_powersInclude<ExtArgs> | null
    /**
     * Filter, which character_discipline_powers to fetch.
     */
    where?: character_discipline_powersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_discipline_powers to fetch.
     */
    orderBy?: character_discipline_powersOrderByWithRelationInput | character_discipline_powersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for character_discipline_powers.
     */
    cursor?: character_discipline_powersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_discipline_powers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_discipline_powers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of character_discipline_powers.
     */
    distinct?: Character_discipline_powersScalarFieldEnum | Character_discipline_powersScalarFieldEnum[]
  }

  /**
   * character_discipline_powers findMany
   */
  export type character_discipline_powersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_discipline_powers
     */
    select?: character_discipline_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_discipline_powers
     */
    omit?: character_discipline_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_discipline_powersInclude<ExtArgs> | null
    /**
     * Filter, which character_discipline_powers to fetch.
     */
    where?: character_discipline_powersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_discipline_powers to fetch.
     */
    orderBy?: character_discipline_powersOrderByWithRelationInput | character_discipline_powersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing character_discipline_powers.
     */
    cursor?: character_discipline_powersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_discipline_powers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_discipline_powers.
     */
    skip?: number
    distinct?: Character_discipline_powersScalarFieldEnum | Character_discipline_powersScalarFieldEnum[]
  }

  /**
   * character_discipline_powers create
   */
  export type character_discipline_powersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_discipline_powers
     */
    select?: character_discipline_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_discipline_powers
     */
    omit?: character_discipline_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_discipline_powersInclude<ExtArgs> | null
    /**
     * The data needed to create a character_discipline_powers.
     */
    data: XOR<character_discipline_powersCreateInput, character_discipline_powersUncheckedCreateInput>
  }

  /**
   * character_discipline_powers createMany
   */
  export type character_discipline_powersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many character_discipline_powers.
     */
    data: character_discipline_powersCreateManyInput | character_discipline_powersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * character_discipline_powers createManyAndReturn
   */
  export type character_discipline_powersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_discipline_powers
     */
    select?: character_discipline_powersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the character_discipline_powers
     */
    omit?: character_discipline_powersOmit<ExtArgs> | null
    /**
     * The data used to create many character_discipline_powers.
     */
    data: character_discipline_powersCreateManyInput | character_discipline_powersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_discipline_powersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * character_discipline_powers update
   */
  export type character_discipline_powersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_discipline_powers
     */
    select?: character_discipline_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_discipline_powers
     */
    omit?: character_discipline_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_discipline_powersInclude<ExtArgs> | null
    /**
     * The data needed to update a character_discipline_powers.
     */
    data: XOR<character_discipline_powersUpdateInput, character_discipline_powersUncheckedUpdateInput>
    /**
     * Choose, which character_discipline_powers to update.
     */
    where: character_discipline_powersWhereUniqueInput
  }

  /**
   * character_discipline_powers updateMany
   */
  export type character_discipline_powersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update character_discipline_powers.
     */
    data: XOR<character_discipline_powersUpdateManyMutationInput, character_discipline_powersUncheckedUpdateManyInput>
    /**
     * Filter which character_discipline_powers to update
     */
    where?: character_discipline_powersWhereInput
    /**
     * Limit how many character_discipline_powers to update.
     */
    limit?: number
  }

  /**
   * character_discipline_powers updateManyAndReturn
   */
  export type character_discipline_powersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_discipline_powers
     */
    select?: character_discipline_powersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the character_discipline_powers
     */
    omit?: character_discipline_powersOmit<ExtArgs> | null
    /**
     * The data used to update character_discipline_powers.
     */
    data: XOR<character_discipline_powersUpdateManyMutationInput, character_discipline_powersUncheckedUpdateManyInput>
    /**
     * Filter which character_discipline_powers to update
     */
    where?: character_discipline_powersWhereInput
    /**
     * Limit how many character_discipline_powers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_discipline_powersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * character_discipline_powers upsert
   */
  export type character_discipline_powersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_discipline_powers
     */
    select?: character_discipline_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_discipline_powers
     */
    omit?: character_discipline_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_discipline_powersInclude<ExtArgs> | null
    /**
     * The filter to search for the character_discipline_powers to update in case it exists.
     */
    where: character_discipline_powersWhereUniqueInput
    /**
     * In case the character_discipline_powers found by the `where` argument doesn't exist, create a new character_discipline_powers with this data.
     */
    create: XOR<character_discipline_powersCreateInput, character_discipline_powersUncheckedCreateInput>
    /**
     * In case the character_discipline_powers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<character_discipline_powersUpdateInput, character_discipline_powersUncheckedUpdateInput>
  }

  /**
   * character_discipline_powers delete
   */
  export type character_discipline_powersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_discipline_powers
     */
    select?: character_discipline_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_discipline_powers
     */
    omit?: character_discipline_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_discipline_powersInclude<ExtArgs> | null
    /**
     * Filter which character_discipline_powers to delete.
     */
    where: character_discipline_powersWhereUniqueInput
  }

  /**
   * character_discipline_powers deleteMany
   */
  export type character_discipline_powersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which character_discipline_powers to delete
     */
    where?: character_discipline_powersWhereInput
    /**
     * Limit how many character_discipline_powers to delete.
     */
    limit?: number
  }

  /**
   * character_discipline_powers without action
   */
  export type character_discipline_powersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_discipline_powers
     */
    select?: character_discipline_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_discipline_powers
     */
    omit?: character_discipline_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_discipline_powersInclude<ExtArgs> | null
  }


  /**
   * Model character_disciplines
   */

  export type AggregateCharacter_disciplines = {
    _count: Character_disciplinesCountAggregateOutputType | null
    _min: Character_disciplinesMinAggregateOutputType | null
    _max: Character_disciplinesMaxAggregateOutputType | null
  }

  export type Character_disciplinesMinAggregateOutputType = {
    id: string | null
    char_id: string | null
    discipline_id: string | null
  }

  export type Character_disciplinesMaxAggregateOutputType = {
    id: string | null
    char_id: string | null
    discipline_id: string | null
  }

  export type Character_disciplinesCountAggregateOutputType = {
    id: number
    char_id: number
    discipline_id: number
    _all: number
  }


  export type Character_disciplinesMinAggregateInputType = {
    id?: true
    char_id?: true
    discipline_id?: true
  }

  export type Character_disciplinesMaxAggregateInputType = {
    id?: true
    char_id?: true
    discipline_id?: true
  }

  export type Character_disciplinesCountAggregateInputType = {
    id?: true
    char_id?: true
    discipline_id?: true
    _all?: true
  }

  export type Character_disciplinesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which character_disciplines to aggregate.
     */
    where?: character_disciplinesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_disciplines to fetch.
     */
    orderBy?: character_disciplinesOrderByWithRelationInput | character_disciplinesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: character_disciplinesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_disciplines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_disciplines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned character_disciplines
    **/
    _count?: true | Character_disciplinesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Character_disciplinesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Character_disciplinesMaxAggregateInputType
  }

  export type GetCharacter_disciplinesAggregateType<T extends Character_disciplinesAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacter_disciplines]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacter_disciplines[P]>
      : GetScalarType<T[P], AggregateCharacter_disciplines[P]>
  }




  export type character_disciplinesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: character_disciplinesWhereInput
    orderBy?: character_disciplinesOrderByWithAggregationInput | character_disciplinesOrderByWithAggregationInput[]
    by: Character_disciplinesScalarFieldEnum[] | Character_disciplinesScalarFieldEnum
    having?: character_disciplinesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Character_disciplinesCountAggregateInputType | true
    _min?: Character_disciplinesMinAggregateInputType
    _max?: Character_disciplinesMaxAggregateInputType
  }

  export type Character_disciplinesGroupByOutputType = {
    id: string
    char_id: string
    discipline_id: string
    _count: Character_disciplinesCountAggregateOutputType | null
    _min: Character_disciplinesMinAggregateOutputType | null
    _max: Character_disciplinesMaxAggregateOutputType | null
  }

  type GetCharacter_disciplinesGroupByPayload<T extends character_disciplinesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Character_disciplinesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Character_disciplinesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Character_disciplinesGroupByOutputType[P]>
            : GetScalarType<T[P], Character_disciplinesGroupByOutputType[P]>
        }
      >
    >


  export type character_disciplinesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    char_id?: boolean
    discipline_id?: boolean
    characters?: boolean | charactersDefaultArgs<ExtArgs>
    disciplines?: boolean | disciplinesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character_disciplines"]>

  export type character_disciplinesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    char_id?: boolean
    discipline_id?: boolean
    characters?: boolean | charactersDefaultArgs<ExtArgs>
    disciplines?: boolean | disciplinesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character_disciplines"]>

  export type character_disciplinesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    char_id?: boolean
    discipline_id?: boolean
    characters?: boolean | charactersDefaultArgs<ExtArgs>
    disciplines?: boolean | disciplinesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character_disciplines"]>

  export type character_disciplinesSelectScalar = {
    id?: boolean
    char_id?: boolean
    discipline_id?: boolean
  }

  export type character_disciplinesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "char_id" | "discipline_id", ExtArgs["result"]["character_disciplines"]>
  export type character_disciplinesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | charactersDefaultArgs<ExtArgs>
    disciplines?: boolean | disciplinesDefaultArgs<ExtArgs>
  }
  export type character_disciplinesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | charactersDefaultArgs<ExtArgs>
    disciplines?: boolean | disciplinesDefaultArgs<ExtArgs>
  }
  export type character_disciplinesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | charactersDefaultArgs<ExtArgs>
    disciplines?: boolean | disciplinesDefaultArgs<ExtArgs>
  }

  export type $character_disciplinesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "character_disciplines"
    objects: {
      characters: Prisma.$charactersPayload<ExtArgs>
      disciplines: Prisma.$disciplinesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      char_id: string
      discipline_id: string
    }, ExtArgs["result"]["character_disciplines"]>
    composites: {}
  }

  type character_disciplinesGetPayload<S extends boolean | null | undefined | character_disciplinesDefaultArgs> = $Result.GetResult<Prisma.$character_disciplinesPayload, S>

  type character_disciplinesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<character_disciplinesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Character_disciplinesCountAggregateInputType | true
    }

  export interface character_disciplinesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['character_disciplines'], meta: { name: 'character_disciplines' } }
    /**
     * Find zero or one Character_disciplines that matches the filter.
     * @param {character_disciplinesFindUniqueArgs} args - Arguments to find a Character_disciplines
     * @example
     * // Get one Character_disciplines
     * const character_disciplines = await prisma.character_disciplines.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends character_disciplinesFindUniqueArgs>(args: SelectSubset<T, character_disciplinesFindUniqueArgs<ExtArgs>>): Prisma__character_disciplinesClient<$Result.GetResult<Prisma.$character_disciplinesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Character_disciplines that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {character_disciplinesFindUniqueOrThrowArgs} args - Arguments to find a Character_disciplines
     * @example
     * // Get one Character_disciplines
     * const character_disciplines = await prisma.character_disciplines.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends character_disciplinesFindUniqueOrThrowArgs>(args: SelectSubset<T, character_disciplinesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__character_disciplinesClient<$Result.GetResult<Prisma.$character_disciplinesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Character_disciplines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_disciplinesFindFirstArgs} args - Arguments to find a Character_disciplines
     * @example
     * // Get one Character_disciplines
     * const character_disciplines = await prisma.character_disciplines.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends character_disciplinesFindFirstArgs>(args?: SelectSubset<T, character_disciplinesFindFirstArgs<ExtArgs>>): Prisma__character_disciplinesClient<$Result.GetResult<Prisma.$character_disciplinesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Character_disciplines that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_disciplinesFindFirstOrThrowArgs} args - Arguments to find a Character_disciplines
     * @example
     * // Get one Character_disciplines
     * const character_disciplines = await prisma.character_disciplines.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends character_disciplinesFindFirstOrThrowArgs>(args?: SelectSubset<T, character_disciplinesFindFirstOrThrowArgs<ExtArgs>>): Prisma__character_disciplinesClient<$Result.GetResult<Prisma.$character_disciplinesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Character_disciplines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_disciplinesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Character_disciplines
     * const character_disciplines = await prisma.character_disciplines.findMany()
     * 
     * // Get first 10 Character_disciplines
     * const character_disciplines = await prisma.character_disciplines.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const character_disciplinesWithIdOnly = await prisma.character_disciplines.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends character_disciplinesFindManyArgs>(args?: SelectSubset<T, character_disciplinesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_disciplinesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Character_disciplines.
     * @param {character_disciplinesCreateArgs} args - Arguments to create a Character_disciplines.
     * @example
     * // Create one Character_disciplines
     * const Character_disciplines = await prisma.character_disciplines.create({
     *   data: {
     *     // ... data to create a Character_disciplines
     *   }
     * })
     * 
     */
    create<T extends character_disciplinesCreateArgs>(args: SelectSubset<T, character_disciplinesCreateArgs<ExtArgs>>): Prisma__character_disciplinesClient<$Result.GetResult<Prisma.$character_disciplinesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Character_disciplines.
     * @param {character_disciplinesCreateManyArgs} args - Arguments to create many Character_disciplines.
     * @example
     * // Create many Character_disciplines
     * const character_disciplines = await prisma.character_disciplines.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends character_disciplinesCreateManyArgs>(args?: SelectSubset<T, character_disciplinesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Character_disciplines and returns the data saved in the database.
     * @param {character_disciplinesCreateManyAndReturnArgs} args - Arguments to create many Character_disciplines.
     * @example
     * // Create many Character_disciplines
     * const character_disciplines = await prisma.character_disciplines.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Character_disciplines and only return the `id`
     * const character_disciplinesWithIdOnly = await prisma.character_disciplines.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends character_disciplinesCreateManyAndReturnArgs>(args?: SelectSubset<T, character_disciplinesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_disciplinesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Character_disciplines.
     * @param {character_disciplinesDeleteArgs} args - Arguments to delete one Character_disciplines.
     * @example
     * // Delete one Character_disciplines
     * const Character_disciplines = await prisma.character_disciplines.delete({
     *   where: {
     *     // ... filter to delete one Character_disciplines
     *   }
     * })
     * 
     */
    delete<T extends character_disciplinesDeleteArgs>(args: SelectSubset<T, character_disciplinesDeleteArgs<ExtArgs>>): Prisma__character_disciplinesClient<$Result.GetResult<Prisma.$character_disciplinesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Character_disciplines.
     * @param {character_disciplinesUpdateArgs} args - Arguments to update one Character_disciplines.
     * @example
     * // Update one Character_disciplines
     * const character_disciplines = await prisma.character_disciplines.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends character_disciplinesUpdateArgs>(args: SelectSubset<T, character_disciplinesUpdateArgs<ExtArgs>>): Prisma__character_disciplinesClient<$Result.GetResult<Prisma.$character_disciplinesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Character_disciplines.
     * @param {character_disciplinesDeleteManyArgs} args - Arguments to filter Character_disciplines to delete.
     * @example
     * // Delete a few Character_disciplines
     * const { count } = await prisma.character_disciplines.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends character_disciplinesDeleteManyArgs>(args?: SelectSubset<T, character_disciplinesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Character_disciplines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_disciplinesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Character_disciplines
     * const character_disciplines = await prisma.character_disciplines.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends character_disciplinesUpdateManyArgs>(args: SelectSubset<T, character_disciplinesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Character_disciplines and returns the data updated in the database.
     * @param {character_disciplinesUpdateManyAndReturnArgs} args - Arguments to update many Character_disciplines.
     * @example
     * // Update many Character_disciplines
     * const character_disciplines = await prisma.character_disciplines.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Character_disciplines and only return the `id`
     * const character_disciplinesWithIdOnly = await prisma.character_disciplines.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends character_disciplinesUpdateManyAndReturnArgs>(args: SelectSubset<T, character_disciplinesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_disciplinesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Character_disciplines.
     * @param {character_disciplinesUpsertArgs} args - Arguments to update or create a Character_disciplines.
     * @example
     * // Update or create a Character_disciplines
     * const character_disciplines = await prisma.character_disciplines.upsert({
     *   create: {
     *     // ... data to create a Character_disciplines
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Character_disciplines we want to update
     *   }
     * })
     */
    upsert<T extends character_disciplinesUpsertArgs>(args: SelectSubset<T, character_disciplinesUpsertArgs<ExtArgs>>): Prisma__character_disciplinesClient<$Result.GetResult<Prisma.$character_disciplinesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Character_disciplines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_disciplinesCountArgs} args - Arguments to filter Character_disciplines to count.
     * @example
     * // Count the number of Character_disciplines
     * const count = await prisma.character_disciplines.count({
     *   where: {
     *     // ... the filter for the Character_disciplines we want to count
     *   }
     * })
    **/
    count<T extends character_disciplinesCountArgs>(
      args?: Subset<T, character_disciplinesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Character_disciplinesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Character_disciplines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Character_disciplinesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Character_disciplinesAggregateArgs>(args: Subset<T, Character_disciplinesAggregateArgs>): Prisma.PrismaPromise<GetCharacter_disciplinesAggregateType<T>>

    /**
     * Group by Character_disciplines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_disciplinesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends character_disciplinesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: character_disciplinesGroupByArgs['orderBy'] }
        : { orderBy?: character_disciplinesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, character_disciplinesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacter_disciplinesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the character_disciplines model
   */
  readonly fields: character_disciplinesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for character_disciplines.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__character_disciplinesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    characters<T extends charactersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, charactersDefaultArgs<ExtArgs>>): Prisma__charactersClient<$Result.GetResult<Prisma.$charactersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    disciplines<T extends disciplinesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, disciplinesDefaultArgs<ExtArgs>>): Prisma__disciplinesClient<$Result.GetResult<Prisma.$disciplinesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the character_disciplines model
   */
  interface character_disciplinesFieldRefs {
    readonly id: FieldRef<"character_disciplines", 'String'>
    readonly char_id: FieldRef<"character_disciplines", 'String'>
    readonly discipline_id: FieldRef<"character_disciplines", 'String'>
  }
    

  // Custom InputTypes
  /**
   * character_disciplines findUnique
   */
  export type character_disciplinesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_disciplines
     */
    select?: character_disciplinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_disciplines
     */
    omit?: character_disciplinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_disciplinesInclude<ExtArgs> | null
    /**
     * Filter, which character_disciplines to fetch.
     */
    where: character_disciplinesWhereUniqueInput
  }

  /**
   * character_disciplines findUniqueOrThrow
   */
  export type character_disciplinesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_disciplines
     */
    select?: character_disciplinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_disciplines
     */
    omit?: character_disciplinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_disciplinesInclude<ExtArgs> | null
    /**
     * Filter, which character_disciplines to fetch.
     */
    where: character_disciplinesWhereUniqueInput
  }

  /**
   * character_disciplines findFirst
   */
  export type character_disciplinesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_disciplines
     */
    select?: character_disciplinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_disciplines
     */
    omit?: character_disciplinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_disciplinesInclude<ExtArgs> | null
    /**
     * Filter, which character_disciplines to fetch.
     */
    where?: character_disciplinesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_disciplines to fetch.
     */
    orderBy?: character_disciplinesOrderByWithRelationInput | character_disciplinesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for character_disciplines.
     */
    cursor?: character_disciplinesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_disciplines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_disciplines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of character_disciplines.
     */
    distinct?: Character_disciplinesScalarFieldEnum | Character_disciplinesScalarFieldEnum[]
  }

  /**
   * character_disciplines findFirstOrThrow
   */
  export type character_disciplinesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_disciplines
     */
    select?: character_disciplinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_disciplines
     */
    omit?: character_disciplinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_disciplinesInclude<ExtArgs> | null
    /**
     * Filter, which character_disciplines to fetch.
     */
    where?: character_disciplinesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_disciplines to fetch.
     */
    orderBy?: character_disciplinesOrderByWithRelationInput | character_disciplinesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for character_disciplines.
     */
    cursor?: character_disciplinesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_disciplines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_disciplines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of character_disciplines.
     */
    distinct?: Character_disciplinesScalarFieldEnum | Character_disciplinesScalarFieldEnum[]
  }

  /**
   * character_disciplines findMany
   */
  export type character_disciplinesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_disciplines
     */
    select?: character_disciplinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_disciplines
     */
    omit?: character_disciplinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_disciplinesInclude<ExtArgs> | null
    /**
     * Filter, which character_disciplines to fetch.
     */
    where?: character_disciplinesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_disciplines to fetch.
     */
    orderBy?: character_disciplinesOrderByWithRelationInput | character_disciplinesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing character_disciplines.
     */
    cursor?: character_disciplinesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_disciplines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_disciplines.
     */
    skip?: number
    distinct?: Character_disciplinesScalarFieldEnum | Character_disciplinesScalarFieldEnum[]
  }

  /**
   * character_disciplines create
   */
  export type character_disciplinesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_disciplines
     */
    select?: character_disciplinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_disciplines
     */
    omit?: character_disciplinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_disciplinesInclude<ExtArgs> | null
    /**
     * The data needed to create a character_disciplines.
     */
    data: XOR<character_disciplinesCreateInput, character_disciplinesUncheckedCreateInput>
  }

  /**
   * character_disciplines createMany
   */
  export type character_disciplinesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many character_disciplines.
     */
    data: character_disciplinesCreateManyInput | character_disciplinesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * character_disciplines createManyAndReturn
   */
  export type character_disciplinesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_disciplines
     */
    select?: character_disciplinesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the character_disciplines
     */
    omit?: character_disciplinesOmit<ExtArgs> | null
    /**
     * The data used to create many character_disciplines.
     */
    data: character_disciplinesCreateManyInput | character_disciplinesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_disciplinesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * character_disciplines update
   */
  export type character_disciplinesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_disciplines
     */
    select?: character_disciplinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_disciplines
     */
    omit?: character_disciplinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_disciplinesInclude<ExtArgs> | null
    /**
     * The data needed to update a character_disciplines.
     */
    data: XOR<character_disciplinesUpdateInput, character_disciplinesUncheckedUpdateInput>
    /**
     * Choose, which character_disciplines to update.
     */
    where: character_disciplinesWhereUniqueInput
  }

  /**
   * character_disciplines updateMany
   */
  export type character_disciplinesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update character_disciplines.
     */
    data: XOR<character_disciplinesUpdateManyMutationInput, character_disciplinesUncheckedUpdateManyInput>
    /**
     * Filter which character_disciplines to update
     */
    where?: character_disciplinesWhereInput
    /**
     * Limit how many character_disciplines to update.
     */
    limit?: number
  }

  /**
   * character_disciplines updateManyAndReturn
   */
  export type character_disciplinesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_disciplines
     */
    select?: character_disciplinesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the character_disciplines
     */
    omit?: character_disciplinesOmit<ExtArgs> | null
    /**
     * The data used to update character_disciplines.
     */
    data: XOR<character_disciplinesUpdateManyMutationInput, character_disciplinesUncheckedUpdateManyInput>
    /**
     * Filter which character_disciplines to update
     */
    where?: character_disciplinesWhereInput
    /**
     * Limit how many character_disciplines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_disciplinesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * character_disciplines upsert
   */
  export type character_disciplinesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_disciplines
     */
    select?: character_disciplinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_disciplines
     */
    omit?: character_disciplinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_disciplinesInclude<ExtArgs> | null
    /**
     * The filter to search for the character_disciplines to update in case it exists.
     */
    where: character_disciplinesWhereUniqueInput
    /**
     * In case the character_disciplines found by the `where` argument doesn't exist, create a new character_disciplines with this data.
     */
    create: XOR<character_disciplinesCreateInput, character_disciplinesUncheckedCreateInput>
    /**
     * In case the character_disciplines was found with the provided `where` argument, update it with this data.
     */
    update: XOR<character_disciplinesUpdateInput, character_disciplinesUncheckedUpdateInput>
  }

  /**
   * character_disciplines delete
   */
  export type character_disciplinesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_disciplines
     */
    select?: character_disciplinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_disciplines
     */
    omit?: character_disciplinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_disciplinesInclude<ExtArgs> | null
    /**
     * Filter which character_disciplines to delete.
     */
    where: character_disciplinesWhereUniqueInput
  }

  /**
   * character_disciplines deleteMany
   */
  export type character_disciplinesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which character_disciplines to delete
     */
    where?: character_disciplinesWhereInput
    /**
     * Limit how many character_disciplines to delete.
     */
    limit?: number
  }

  /**
   * character_disciplines without action
   */
  export type character_disciplinesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_disciplines
     */
    select?: character_disciplinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_disciplines
     */
    omit?: character_disciplinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_disciplinesInclude<ExtArgs> | null
  }


  /**
   * Model character_healths
   */

  export type AggregateCharacter_healths = {
    _count: Character_healthsCountAggregateOutputType | null
    _avg: Character_healthsAvgAggregateOutputType | null
    _sum: Character_healthsSumAggregateOutputType | null
    _min: Character_healthsMinAggregateOutputType | null
    _max: Character_healthsMaxAggregateOutputType | null
  }

  export type Character_healthsAvgAggregateOutputType = {
    max_health: number | null
    current_aggravated: number | null
    current_superficial: number | null
  }

  export type Character_healthsSumAggregateOutputType = {
    max_health: number | null
    current_aggravated: number | null
    current_superficial: number | null
  }

  export type Character_healthsMinAggregateOutputType = {
    id: string | null
    char_id: string | null
    max_health: number | null
    current_aggravated: number | null
    current_superficial: number | null
  }

  export type Character_healthsMaxAggregateOutputType = {
    id: string | null
    char_id: string | null
    max_health: number | null
    current_aggravated: number | null
    current_superficial: number | null
  }

  export type Character_healthsCountAggregateOutputType = {
    id: number
    char_id: number
    max_health: number
    current_aggravated: number
    current_superficial: number
    _all: number
  }


  export type Character_healthsAvgAggregateInputType = {
    max_health?: true
    current_aggravated?: true
    current_superficial?: true
  }

  export type Character_healthsSumAggregateInputType = {
    max_health?: true
    current_aggravated?: true
    current_superficial?: true
  }

  export type Character_healthsMinAggregateInputType = {
    id?: true
    char_id?: true
    max_health?: true
    current_aggravated?: true
    current_superficial?: true
  }

  export type Character_healthsMaxAggregateInputType = {
    id?: true
    char_id?: true
    max_health?: true
    current_aggravated?: true
    current_superficial?: true
  }

  export type Character_healthsCountAggregateInputType = {
    id?: true
    char_id?: true
    max_health?: true
    current_aggravated?: true
    current_superficial?: true
    _all?: true
  }

  export type Character_healthsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which character_healths to aggregate.
     */
    where?: character_healthsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_healths to fetch.
     */
    orderBy?: character_healthsOrderByWithRelationInput | character_healthsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: character_healthsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_healths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_healths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned character_healths
    **/
    _count?: true | Character_healthsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Character_healthsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Character_healthsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Character_healthsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Character_healthsMaxAggregateInputType
  }

  export type GetCharacter_healthsAggregateType<T extends Character_healthsAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacter_healths]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacter_healths[P]>
      : GetScalarType<T[P], AggregateCharacter_healths[P]>
  }




  export type character_healthsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: character_healthsWhereInput
    orderBy?: character_healthsOrderByWithAggregationInput | character_healthsOrderByWithAggregationInput[]
    by: Character_healthsScalarFieldEnum[] | Character_healthsScalarFieldEnum
    having?: character_healthsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Character_healthsCountAggregateInputType | true
    _avg?: Character_healthsAvgAggregateInputType
    _sum?: Character_healthsSumAggregateInputType
    _min?: Character_healthsMinAggregateInputType
    _max?: Character_healthsMaxAggregateInputType
  }

  export type Character_healthsGroupByOutputType = {
    id: string
    char_id: string
    max_health: number
    current_aggravated: number
    current_superficial: number
    _count: Character_healthsCountAggregateOutputType | null
    _avg: Character_healthsAvgAggregateOutputType | null
    _sum: Character_healthsSumAggregateOutputType | null
    _min: Character_healthsMinAggregateOutputType | null
    _max: Character_healthsMaxAggregateOutputType | null
  }

  type GetCharacter_healthsGroupByPayload<T extends character_healthsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Character_healthsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Character_healthsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Character_healthsGroupByOutputType[P]>
            : GetScalarType<T[P], Character_healthsGroupByOutputType[P]>
        }
      >
    >


  export type character_healthsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    char_id?: boolean
    max_health?: boolean
    current_aggravated?: boolean
    current_superficial?: boolean
    characters?: boolean | charactersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character_healths"]>

  export type character_healthsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    char_id?: boolean
    max_health?: boolean
    current_aggravated?: boolean
    current_superficial?: boolean
    characters?: boolean | charactersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character_healths"]>

  export type character_healthsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    char_id?: boolean
    max_health?: boolean
    current_aggravated?: boolean
    current_superficial?: boolean
    characters?: boolean | charactersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character_healths"]>

  export type character_healthsSelectScalar = {
    id?: boolean
    char_id?: boolean
    max_health?: boolean
    current_aggravated?: boolean
    current_superficial?: boolean
  }

  export type character_healthsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "char_id" | "max_health" | "current_aggravated" | "current_superficial", ExtArgs["result"]["character_healths"]>
  export type character_healthsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | charactersDefaultArgs<ExtArgs>
  }
  export type character_healthsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | charactersDefaultArgs<ExtArgs>
  }
  export type character_healthsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | charactersDefaultArgs<ExtArgs>
  }

  export type $character_healthsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "character_healths"
    objects: {
      characters: Prisma.$charactersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      char_id: string
      max_health: number
      current_aggravated: number
      current_superficial: number
    }, ExtArgs["result"]["character_healths"]>
    composites: {}
  }

  type character_healthsGetPayload<S extends boolean | null | undefined | character_healthsDefaultArgs> = $Result.GetResult<Prisma.$character_healthsPayload, S>

  type character_healthsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<character_healthsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Character_healthsCountAggregateInputType | true
    }

  export interface character_healthsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['character_healths'], meta: { name: 'character_healths' } }
    /**
     * Find zero or one Character_healths that matches the filter.
     * @param {character_healthsFindUniqueArgs} args - Arguments to find a Character_healths
     * @example
     * // Get one Character_healths
     * const character_healths = await prisma.character_healths.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends character_healthsFindUniqueArgs>(args: SelectSubset<T, character_healthsFindUniqueArgs<ExtArgs>>): Prisma__character_healthsClient<$Result.GetResult<Prisma.$character_healthsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Character_healths that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {character_healthsFindUniqueOrThrowArgs} args - Arguments to find a Character_healths
     * @example
     * // Get one Character_healths
     * const character_healths = await prisma.character_healths.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends character_healthsFindUniqueOrThrowArgs>(args: SelectSubset<T, character_healthsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__character_healthsClient<$Result.GetResult<Prisma.$character_healthsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Character_healths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_healthsFindFirstArgs} args - Arguments to find a Character_healths
     * @example
     * // Get one Character_healths
     * const character_healths = await prisma.character_healths.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends character_healthsFindFirstArgs>(args?: SelectSubset<T, character_healthsFindFirstArgs<ExtArgs>>): Prisma__character_healthsClient<$Result.GetResult<Prisma.$character_healthsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Character_healths that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_healthsFindFirstOrThrowArgs} args - Arguments to find a Character_healths
     * @example
     * // Get one Character_healths
     * const character_healths = await prisma.character_healths.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends character_healthsFindFirstOrThrowArgs>(args?: SelectSubset<T, character_healthsFindFirstOrThrowArgs<ExtArgs>>): Prisma__character_healthsClient<$Result.GetResult<Prisma.$character_healthsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Character_healths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_healthsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Character_healths
     * const character_healths = await prisma.character_healths.findMany()
     * 
     * // Get first 10 Character_healths
     * const character_healths = await prisma.character_healths.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const character_healthsWithIdOnly = await prisma.character_healths.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends character_healthsFindManyArgs>(args?: SelectSubset<T, character_healthsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_healthsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Character_healths.
     * @param {character_healthsCreateArgs} args - Arguments to create a Character_healths.
     * @example
     * // Create one Character_healths
     * const Character_healths = await prisma.character_healths.create({
     *   data: {
     *     // ... data to create a Character_healths
     *   }
     * })
     * 
     */
    create<T extends character_healthsCreateArgs>(args: SelectSubset<T, character_healthsCreateArgs<ExtArgs>>): Prisma__character_healthsClient<$Result.GetResult<Prisma.$character_healthsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Character_healths.
     * @param {character_healthsCreateManyArgs} args - Arguments to create many Character_healths.
     * @example
     * // Create many Character_healths
     * const character_healths = await prisma.character_healths.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends character_healthsCreateManyArgs>(args?: SelectSubset<T, character_healthsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Character_healths and returns the data saved in the database.
     * @param {character_healthsCreateManyAndReturnArgs} args - Arguments to create many Character_healths.
     * @example
     * // Create many Character_healths
     * const character_healths = await prisma.character_healths.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Character_healths and only return the `id`
     * const character_healthsWithIdOnly = await prisma.character_healths.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends character_healthsCreateManyAndReturnArgs>(args?: SelectSubset<T, character_healthsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_healthsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Character_healths.
     * @param {character_healthsDeleteArgs} args - Arguments to delete one Character_healths.
     * @example
     * // Delete one Character_healths
     * const Character_healths = await prisma.character_healths.delete({
     *   where: {
     *     // ... filter to delete one Character_healths
     *   }
     * })
     * 
     */
    delete<T extends character_healthsDeleteArgs>(args: SelectSubset<T, character_healthsDeleteArgs<ExtArgs>>): Prisma__character_healthsClient<$Result.GetResult<Prisma.$character_healthsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Character_healths.
     * @param {character_healthsUpdateArgs} args - Arguments to update one Character_healths.
     * @example
     * // Update one Character_healths
     * const character_healths = await prisma.character_healths.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends character_healthsUpdateArgs>(args: SelectSubset<T, character_healthsUpdateArgs<ExtArgs>>): Prisma__character_healthsClient<$Result.GetResult<Prisma.$character_healthsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Character_healths.
     * @param {character_healthsDeleteManyArgs} args - Arguments to filter Character_healths to delete.
     * @example
     * // Delete a few Character_healths
     * const { count } = await prisma.character_healths.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends character_healthsDeleteManyArgs>(args?: SelectSubset<T, character_healthsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Character_healths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_healthsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Character_healths
     * const character_healths = await prisma.character_healths.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends character_healthsUpdateManyArgs>(args: SelectSubset<T, character_healthsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Character_healths and returns the data updated in the database.
     * @param {character_healthsUpdateManyAndReturnArgs} args - Arguments to update many Character_healths.
     * @example
     * // Update many Character_healths
     * const character_healths = await prisma.character_healths.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Character_healths and only return the `id`
     * const character_healthsWithIdOnly = await prisma.character_healths.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends character_healthsUpdateManyAndReturnArgs>(args: SelectSubset<T, character_healthsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_healthsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Character_healths.
     * @param {character_healthsUpsertArgs} args - Arguments to update or create a Character_healths.
     * @example
     * // Update or create a Character_healths
     * const character_healths = await prisma.character_healths.upsert({
     *   create: {
     *     // ... data to create a Character_healths
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Character_healths we want to update
     *   }
     * })
     */
    upsert<T extends character_healthsUpsertArgs>(args: SelectSubset<T, character_healthsUpsertArgs<ExtArgs>>): Prisma__character_healthsClient<$Result.GetResult<Prisma.$character_healthsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Character_healths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_healthsCountArgs} args - Arguments to filter Character_healths to count.
     * @example
     * // Count the number of Character_healths
     * const count = await prisma.character_healths.count({
     *   where: {
     *     // ... the filter for the Character_healths we want to count
     *   }
     * })
    **/
    count<T extends character_healthsCountArgs>(
      args?: Subset<T, character_healthsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Character_healthsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Character_healths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Character_healthsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Character_healthsAggregateArgs>(args: Subset<T, Character_healthsAggregateArgs>): Prisma.PrismaPromise<GetCharacter_healthsAggregateType<T>>

    /**
     * Group by Character_healths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_healthsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends character_healthsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: character_healthsGroupByArgs['orderBy'] }
        : { orderBy?: character_healthsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, character_healthsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacter_healthsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the character_healths model
   */
  readonly fields: character_healthsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for character_healths.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__character_healthsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    characters<T extends charactersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, charactersDefaultArgs<ExtArgs>>): Prisma__charactersClient<$Result.GetResult<Prisma.$charactersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the character_healths model
   */
  interface character_healthsFieldRefs {
    readonly id: FieldRef<"character_healths", 'String'>
    readonly char_id: FieldRef<"character_healths", 'String'>
    readonly max_health: FieldRef<"character_healths", 'Int'>
    readonly current_aggravated: FieldRef<"character_healths", 'Int'>
    readonly current_superficial: FieldRef<"character_healths", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * character_healths findUnique
   */
  export type character_healthsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_healths
     */
    select?: character_healthsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_healths
     */
    omit?: character_healthsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_healthsInclude<ExtArgs> | null
    /**
     * Filter, which character_healths to fetch.
     */
    where: character_healthsWhereUniqueInput
  }

  /**
   * character_healths findUniqueOrThrow
   */
  export type character_healthsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_healths
     */
    select?: character_healthsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_healths
     */
    omit?: character_healthsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_healthsInclude<ExtArgs> | null
    /**
     * Filter, which character_healths to fetch.
     */
    where: character_healthsWhereUniqueInput
  }

  /**
   * character_healths findFirst
   */
  export type character_healthsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_healths
     */
    select?: character_healthsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_healths
     */
    omit?: character_healthsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_healthsInclude<ExtArgs> | null
    /**
     * Filter, which character_healths to fetch.
     */
    where?: character_healthsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_healths to fetch.
     */
    orderBy?: character_healthsOrderByWithRelationInput | character_healthsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for character_healths.
     */
    cursor?: character_healthsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_healths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_healths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of character_healths.
     */
    distinct?: Character_healthsScalarFieldEnum | Character_healthsScalarFieldEnum[]
  }

  /**
   * character_healths findFirstOrThrow
   */
  export type character_healthsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_healths
     */
    select?: character_healthsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_healths
     */
    omit?: character_healthsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_healthsInclude<ExtArgs> | null
    /**
     * Filter, which character_healths to fetch.
     */
    where?: character_healthsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_healths to fetch.
     */
    orderBy?: character_healthsOrderByWithRelationInput | character_healthsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for character_healths.
     */
    cursor?: character_healthsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_healths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_healths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of character_healths.
     */
    distinct?: Character_healthsScalarFieldEnum | Character_healthsScalarFieldEnum[]
  }

  /**
   * character_healths findMany
   */
  export type character_healthsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_healths
     */
    select?: character_healthsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_healths
     */
    omit?: character_healthsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_healthsInclude<ExtArgs> | null
    /**
     * Filter, which character_healths to fetch.
     */
    where?: character_healthsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_healths to fetch.
     */
    orderBy?: character_healthsOrderByWithRelationInput | character_healthsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing character_healths.
     */
    cursor?: character_healthsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_healths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_healths.
     */
    skip?: number
    distinct?: Character_healthsScalarFieldEnum | Character_healthsScalarFieldEnum[]
  }

  /**
   * character_healths create
   */
  export type character_healthsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_healths
     */
    select?: character_healthsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_healths
     */
    omit?: character_healthsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_healthsInclude<ExtArgs> | null
    /**
     * The data needed to create a character_healths.
     */
    data: XOR<character_healthsCreateInput, character_healthsUncheckedCreateInput>
  }

  /**
   * character_healths createMany
   */
  export type character_healthsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many character_healths.
     */
    data: character_healthsCreateManyInput | character_healthsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * character_healths createManyAndReturn
   */
  export type character_healthsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_healths
     */
    select?: character_healthsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the character_healths
     */
    omit?: character_healthsOmit<ExtArgs> | null
    /**
     * The data used to create many character_healths.
     */
    data: character_healthsCreateManyInput | character_healthsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_healthsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * character_healths update
   */
  export type character_healthsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_healths
     */
    select?: character_healthsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_healths
     */
    omit?: character_healthsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_healthsInclude<ExtArgs> | null
    /**
     * The data needed to update a character_healths.
     */
    data: XOR<character_healthsUpdateInput, character_healthsUncheckedUpdateInput>
    /**
     * Choose, which character_healths to update.
     */
    where: character_healthsWhereUniqueInput
  }

  /**
   * character_healths updateMany
   */
  export type character_healthsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update character_healths.
     */
    data: XOR<character_healthsUpdateManyMutationInput, character_healthsUncheckedUpdateManyInput>
    /**
     * Filter which character_healths to update
     */
    where?: character_healthsWhereInput
    /**
     * Limit how many character_healths to update.
     */
    limit?: number
  }

  /**
   * character_healths updateManyAndReturn
   */
  export type character_healthsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_healths
     */
    select?: character_healthsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the character_healths
     */
    omit?: character_healthsOmit<ExtArgs> | null
    /**
     * The data used to update character_healths.
     */
    data: XOR<character_healthsUpdateManyMutationInput, character_healthsUncheckedUpdateManyInput>
    /**
     * Filter which character_healths to update
     */
    where?: character_healthsWhereInput
    /**
     * Limit how many character_healths to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_healthsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * character_healths upsert
   */
  export type character_healthsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_healths
     */
    select?: character_healthsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_healths
     */
    omit?: character_healthsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_healthsInclude<ExtArgs> | null
    /**
     * The filter to search for the character_healths to update in case it exists.
     */
    where: character_healthsWhereUniqueInput
    /**
     * In case the character_healths found by the `where` argument doesn't exist, create a new character_healths with this data.
     */
    create: XOR<character_healthsCreateInput, character_healthsUncheckedCreateInput>
    /**
     * In case the character_healths was found with the provided `where` argument, update it with this data.
     */
    update: XOR<character_healthsUpdateInput, character_healthsUncheckedUpdateInput>
  }

  /**
   * character_healths delete
   */
  export type character_healthsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_healths
     */
    select?: character_healthsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_healths
     */
    omit?: character_healthsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_healthsInclude<ExtArgs> | null
    /**
     * Filter which character_healths to delete.
     */
    where: character_healthsWhereUniqueInput
  }

  /**
   * character_healths deleteMany
   */
  export type character_healthsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which character_healths to delete
     */
    where?: character_healthsWhereInput
    /**
     * Limit how many character_healths to delete.
     */
    limit?: number
  }

  /**
   * character_healths without action
   */
  export type character_healthsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_healths
     */
    select?: character_healthsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_healths
     */
    omit?: character_healthsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_healthsInclude<ExtArgs> | null
  }


  /**
   * Model character_humanity
   */

  export type AggregateCharacter_humanity = {
    _count: Character_humanityCountAggregateOutputType | null
    _avg: Character_humanityAvgAggregateOutputType | null
    _sum: Character_humanitySumAggregateOutputType | null
    _min: Character_humanityMinAggregateOutputType | null
    _max: Character_humanityMaxAggregateOutputType | null
  }

  export type Character_humanityAvgAggregateOutputType = {
    level: number | null
    stain_count: number | null
  }

  export type Character_humanitySumAggregateOutputType = {
    level: number | null
    stain_count: number | null
  }

  export type Character_humanityMinAggregateOutputType = {
    id: string | null
    char_id: string | null
    level: number | null
    stain_count: number | null
  }

  export type Character_humanityMaxAggregateOutputType = {
    id: string | null
    char_id: string | null
    level: number | null
    stain_count: number | null
  }

  export type Character_humanityCountAggregateOutputType = {
    id: number
    char_id: number
    level: number
    stain_count: number
    _all: number
  }


  export type Character_humanityAvgAggregateInputType = {
    level?: true
    stain_count?: true
  }

  export type Character_humanitySumAggregateInputType = {
    level?: true
    stain_count?: true
  }

  export type Character_humanityMinAggregateInputType = {
    id?: true
    char_id?: true
    level?: true
    stain_count?: true
  }

  export type Character_humanityMaxAggregateInputType = {
    id?: true
    char_id?: true
    level?: true
    stain_count?: true
  }

  export type Character_humanityCountAggregateInputType = {
    id?: true
    char_id?: true
    level?: true
    stain_count?: true
    _all?: true
  }

  export type Character_humanityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which character_humanity to aggregate.
     */
    where?: character_humanityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_humanities to fetch.
     */
    orderBy?: character_humanityOrderByWithRelationInput | character_humanityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: character_humanityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_humanities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_humanities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned character_humanities
    **/
    _count?: true | Character_humanityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Character_humanityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Character_humanitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Character_humanityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Character_humanityMaxAggregateInputType
  }

  export type GetCharacter_humanityAggregateType<T extends Character_humanityAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacter_humanity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacter_humanity[P]>
      : GetScalarType<T[P], AggregateCharacter_humanity[P]>
  }




  export type character_humanityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: character_humanityWhereInput
    orderBy?: character_humanityOrderByWithAggregationInput | character_humanityOrderByWithAggregationInput[]
    by: Character_humanityScalarFieldEnum[] | Character_humanityScalarFieldEnum
    having?: character_humanityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Character_humanityCountAggregateInputType | true
    _avg?: Character_humanityAvgAggregateInputType
    _sum?: Character_humanitySumAggregateInputType
    _min?: Character_humanityMinAggregateInputType
    _max?: Character_humanityMaxAggregateInputType
  }

  export type Character_humanityGroupByOutputType = {
    id: string
    char_id: string
    level: number
    stain_count: number
    _count: Character_humanityCountAggregateOutputType | null
    _avg: Character_humanityAvgAggregateOutputType | null
    _sum: Character_humanitySumAggregateOutputType | null
    _min: Character_humanityMinAggregateOutputType | null
    _max: Character_humanityMaxAggregateOutputType | null
  }

  type GetCharacter_humanityGroupByPayload<T extends character_humanityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Character_humanityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Character_humanityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Character_humanityGroupByOutputType[P]>
            : GetScalarType<T[P], Character_humanityGroupByOutputType[P]>
        }
      >
    >


  export type character_humanitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    char_id?: boolean
    level?: boolean
    stain_count?: boolean
    characters?: boolean | charactersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character_humanity"]>

  export type character_humanitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    char_id?: boolean
    level?: boolean
    stain_count?: boolean
    characters?: boolean | charactersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character_humanity"]>

  export type character_humanitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    char_id?: boolean
    level?: boolean
    stain_count?: boolean
    characters?: boolean | charactersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character_humanity"]>

  export type character_humanitySelectScalar = {
    id?: boolean
    char_id?: boolean
    level?: boolean
    stain_count?: boolean
  }

  export type character_humanityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "char_id" | "level" | "stain_count", ExtArgs["result"]["character_humanity"]>
  export type character_humanityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | charactersDefaultArgs<ExtArgs>
  }
  export type character_humanityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | charactersDefaultArgs<ExtArgs>
  }
  export type character_humanityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | charactersDefaultArgs<ExtArgs>
  }

  export type $character_humanityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "character_humanity"
    objects: {
      characters: Prisma.$charactersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      char_id: string
      level: number
      stain_count: number
    }, ExtArgs["result"]["character_humanity"]>
    composites: {}
  }

  type character_humanityGetPayload<S extends boolean | null | undefined | character_humanityDefaultArgs> = $Result.GetResult<Prisma.$character_humanityPayload, S>

  type character_humanityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<character_humanityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Character_humanityCountAggregateInputType | true
    }

  export interface character_humanityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['character_humanity'], meta: { name: 'character_humanity' } }
    /**
     * Find zero or one Character_humanity that matches the filter.
     * @param {character_humanityFindUniqueArgs} args - Arguments to find a Character_humanity
     * @example
     * // Get one Character_humanity
     * const character_humanity = await prisma.character_humanity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends character_humanityFindUniqueArgs>(args: SelectSubset<T, character_humanityFindUniqueArgs<ExtArgs>>): Prisma__character_humanityClient<$Result.GetResult<Prisma.$character_humanityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Character_humanity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {character_humanityFindUniqueOrThrowArgs} args - Arguments to find a Character_humanity
     * @example
     * // Get one Character_humanity
     * const character_humanity = await prisma.character_humanity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends character_humanityFindUniqueOrThrowArgs>(args: SelectSubset<T, character_humanityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__character_humanityClient<$Result.GetResult<Prisma.$character_humanityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Character_humanity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_humanityFindFirstArgs} args - Arguments to find a Character_humanity
     * @example
     * // Get one Character_humanity
     * const character_humanity = await prisma.character_humanity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends character_humanityFindFirstArgs>(args?: SelectSubset<T, character_humanityFindFirstArgs<ExtArgs>>): Prisma__character_humanityClient<$Result.GetResult<Prisma.$character_humanityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Character_humanity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_humanityFindFirstOrThrowArgs} args - Arguments to find a Character_humanity
     * @example
     * // Get one Character_humanity
     * const character_humanity = await prisma.character_humanity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends character_humanityFindFirstOrThrowArgs>(args?: SelectSubset<T, character_humanityFindFirstOrThrowArgs<ExtArgs>>): Prisma__character_humanityClient<$Result.GetResult<Prisma.$character_humanityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Character_humanities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_humanityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Character_humanities
     * const character_humanities = await prisma.character_humanity.findMany()
     * 
     * // Get first 10 Character_humanities
     * const character_humanities = await prisma.character_humanity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const character_humanityWithIdOnly = await prisma.character_humanity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends character_humanityFindManyArgs>(args?: SelectSubset<T, character_humanityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_humanityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Character_humanity.
     * @param {character_humanityCreateArgs} args - Arguments to create a Character_humanity.
     * @example
     * // Create one Character_humanity
     * const Character_humanity = await prisma.character_humanity.create({
     *   data: {
     *     // ... data to create a Character_humanity
     *   }
     * })
     * 
     */
    create<T extends character_humanityCreateArgs>(args: SelectSubset<T, character_humanityCreateArgs<ExtArgs>>): Prisma__character_humanityClient<$Result.GetResult<Prisma.$character_humanityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Character_humanities.
     * @param {character_humanityCreateManyArgs} args - Arguments to create many Character_humanities.
     * @example
     * // Create many Character_humanities
     * const character_humanity = await prisma.character_humanity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends character_humanityCreateManyArgs>(args?: SelectSubset<T, character_humanityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Character_humanities and returns the data saved in the database.
     * @param {character_humanityCreateManyAndReturnArgs} args - Arguments to create many Character_humanities.
     * @example
     * // Create many Character_humanities
     * const character_humanity = await prisma.character_humanity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Character_humanities and only return the `id`
     * const character_humanityWithIdOnly = await prisma.character_humanity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends character_humanityCreateManyAndReturnArgs>(args?: SelectSubset<T, character_humanityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_humanityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Character_humanity.
     * @param {character_humanityDeleteArgs} args - Arguments to delete one Character_humanity.
     * @example
     * // Delete one Character_humanity
     * const Character_humanity = await prisma.character_humanity.delete({
     *   where: {
     *     // ... filter to delete one Character_humanity
     *   }
     * })
     * 
     */
    delete<T extends character_humanityDeleteArgs>(args: SelectSubset<T, character_humanityDeleteArgs<ExtArgs>>): Prisma__character_humanityClient<$Result.GetResult<Prisma.$character_humanityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Character_humanity.
     * @param {character_humanityUpdateArgs} args - Arguments to update one Character_humanity.
     * @example
     * // Update one Character_humanity
     * const character_humanity = await prisma.character_humanity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends character_humanityUpdateArgs>(args: SelectSubset<T, character_humanityUpdateArgs<ExtArgs>>): Prisma__character_humanityClient<$Result.GetResult<Prisma.$character_humanityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Character_humanities.
     * @param {character_humanityDeleteManyArgs} args - Arguments to filter Character_humanities to delete.
     * @example
     * // Delete a few Character_humanities
     * const { count } = await prisma.character_humanity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends character_humanityDeleteManyArgs>(args?: SelectSubset<T, character_humanityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Character_humanities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_humanityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Character_humanities
     * const character_humanity = await prisma.character_humanity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends character_humanityUpdateManyArgs>(args: SelectSubset<T, character_humanityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Character_humanities and returns the data updated in the database.
     * @param {character_humanityUpdateManyAndReturnArgs} args - Arguments to update many Character_humanities.
     * @example
     * // Update many Character_humanities
     * const character_humanity = await prisma.character_humanity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Character_humanities and only return the `id`
     * const character_humanityWithIdOnly = await prisma.character_humanity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends character_humanityUpdateManyAndReturnArgs>(args: SelectSubset<T, character_humanityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_humanityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Character_humanity.
     * @param {character_humanityUpsertArgs} args - Arguments to update or create a Character_humanity.
     * @example
     * // Update or create a Character_humanity
     * const character_humanity = await prisma.character_humanity.upsert({
     *   create: {
     *     // ... data to create a Character_humanity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Character_humanity we want to update
     *   }
     * })
     */
    upsert<T extends character_humanityUpsertArgs>(args: SelectSubset<T, character_humanityUpsertArgs<ExtArgs>>): Prisma__character_humanityClient<$Result.GetResult<Prisma.$character_humanityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Character_humanities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_humanityCountArgs} args - Arguments to filter Character_humanities to count.
     * @example
     * // Count the number of Character_humanities
     * const count = await prisma.character_humanity.count({
     *   where: {
     *     // ... the filter for the Character_humanities we want to count
     *   }
     * })
    **/
    count<T extends character_humanityCountArgs>(
      args?: Subset<T, character_humanityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Character_humanityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Character_humanity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Character_humanityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Character_humanityAggregateArgs>(args: Subset<T, Character_humanityAggregateArgs>): Prisma.PrismaPromise<GetCharacter_humanityAggregateType<T>>

    /**
     * Group by Character_humanity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_humanityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends character_humanityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: character_humanityGroupByArgs['orderBy'] }
        : { orderBy?: character_humanityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, character_humanityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacter_humanityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the character_humanity model
   */
  readonly fields: character_humanityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for character_humanity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__character_humanityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    characters<T extends charactersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, charactersDefaultArgs<ExtArgs>>): Prisma__charactersClient<$Result.GetResult<Prisma.$charactersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the character_humanity model
   */
  interface character_humanityFieldRefs {
    readonly id: FieldRef<"character_humanity", 'String'>
    readonly char_id: FieldRef<"character_humanity", 'String'>
    readonly level: FieldRef<"character_humanity", 'Int'>
    readonly stain_count: FieldRef<"character_humanity", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * character_humanity findUnique
   */
  export type character_humanityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_humanity
     */
    select?: character_humanitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_humanity
     */
    omit?: character_humanityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_humanityInclude<ExtArgs> | null
    /**
     * Filter, which character_humanity to fetch.
     */
    where: character_humanityWhereUniqueInput
  }

  /**
   * character_humanity findUniqueOrThrow
   */
  export type character_humanityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_humanity
     */
    select?: character_humanitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_humanity
     */
    omit?: character_humanityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_humanityInclude<ExtArgs> | null
    /**
     * Filter, which character_humanity to fetch.
     */
    where: character_humanityWhereUniqueInput
  }

  /**
   * character_humanity findFirst
   */
  export type character_humanityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_humanity
     */
    select?: character_humanitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_humanity
     */
    omit?: character_humanityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_humanityInclude<ExtArgs> | null
    /**
     * Filter, which character_humanity to fetch.
     */
    where?: character_humanityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_humanities to fetch.
     */
    orderBy?: character_humanityOrderByWithRelationInput | character_humanityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for character_humanities.
     */
    cursor?: character_humanityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_humanities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_humanities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of character_humanities.
     */
    distinct?: Character_humanityScalarFieldEnum | Character_humanityScalarFieldEnum[]
  }

  /**
   * character_humanity findFirstOrThrow
   */
  export type character_humanityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_humanity
     */
    select?: character_humanitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_humanity
     */
    omit?: character_humanityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_humanityInclude<ExtArgs> | null
    /**
     * Filter, which character_humanity to fetch.
     */
    where?: character_humanityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_humanities to fetch.
     */
    orderBy?: character_humanityOrderByWithRelationInput | character_humanityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for character_humanities.
     */
    cursor?: character_humanityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_humanities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_humanities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of character_humanities.
     */
    distinct?: Character_humanityScalarFieldEnum | Character_humanityScalarFieldEnum[]
  }

  /**
   * character_humanity findMany
   */
  export type character_humanityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_humanity
     */
    select?: character_humanitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_humanity
     */
    omit?: character_humanityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_humanityInclude<ExtArgs> | null
    /**
     * Filter, which character_humanities to fetch.
     */
    where?: character_humanityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_humanities to fetch.
     */
    orderBy?: character_humanityOrderByWithRelationInput | character_humanityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing character_humanities.
     */
    cursor?: character_humanityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_humanities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_humanities.
     */
    skip?: number
    distinct?: Character_humanityScalarFieldEnum | Character_humanityScalarFieldEnum[]
  }

  /**
   * character_humanity create
   */
  export type character_humanityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_humanity
     */
    select?: character_humanitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_humanity
     */
    omit?: character_humanityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_humanityInclude<ExtArgs> | null
    /**
     * The data needed to create a character_humanity.
     */
    data: XOR<character_humanityCreateInput, character_humanityUncheckedCreateInput>
  }

  /**
   * character_humanity createMany
   */
  export type character_humanityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many character_humanities.
     */
    data: character_humanityCreateManyInput | character_humanityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * character_humanity createManyAndReturn
   */
  export type character_humanityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_humanity
     */
    select?: character_humanitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the character_humanity
     */
    omit?: character_humanityOmit<ExtArgs> | null
    /**
     * The data used to create many character_humanities.
     */
    data: character_humanityCreateManyInput | character_humanityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_humanityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * character_humanity update
   */
  export type character_humanityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_humanity
     */
    select?: character_humanitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_humanity
     */
    omit?: character_humanityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_humanityInclude<ExtArgs> | null
    /**
     * The data needed to update a character_humanity.
     */
    data: XOR<character_humanityUpdateInput, character_humanityUncheckedUpdateInput>
    /**
     * Choose, which character_humanity to update.
     */
    where: character_humanityWhereUniqueInput
  }

  /**
   * character_humanity updateMany
   */
  export type character_humanityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update character_humanities.
     */
    data: XOR<character_humanityUpdateManyMutationInput, character_humanityUncheckedUpdateManyInput>
    /**
     * Filter which character_humanities to update
     */
    where?: character_humanityWhereInput
    /**
     * Limit how many character_humanities to update.
     */
    limit?: number
  }

  /**
   * character_humanity updateManyAndReturn
   */
  export type character_humanityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_humanity
     */
    select?: character_humanitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the character_humanity
     */
    omit?: character_humanityOmit<ExtArgs> | null
    /**
     * The data used to update character_humanities.
     */
    data: XOR<character_humanityUpdateManyMutationInput, character_humanityUncheckedUpdateManyInput>
    /**
     * Filter which character_humanities to update
     */
    where?: character_humanityWhereInput
    /**
     * Limit how many character_humanities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_humanityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * character_humanity upsert
   */
  export type character_humanityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_humanity
     */
    select?: character_humanitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_humanity
     */
    omit?: character_humanityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_humanityInclude<ExtArgs> | null
    /**
     * The filter to search for the character_humanity to update in case it exists.
     */
    where: character_humanityWhereUniqueInput
    /**
     * In case the character_humanity found by the `where` argument doesn't exist, create a new character_humanity with this data.
     */
    create: XOR<character_humanityCreateInput, character_humanityUncheckedCreateInput>
    /**
     * In case the character_humanity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<character_humanityUpdateInput, character_humanityUncheckedUpdateInput>
  }

  /**
   * character_humanity delete
   */
  export type character_humanityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_humanity
     */
    select?: character_humanitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_humanity
     */
    omit?: character_humanityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_humanityInclude<ExtArgs> | null
    /**
     * Filter which character_humanity to delete.
     */
    where: character_humanityWhereUniqueInput
  }

  /**
   * character_humanity deleteMany
   */
  export type character_humanityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which character_humanities to delete
     */
    where?: character_humanityWhereInput
    /**
     * Limit how many character_humanities to delete.
     */
    limit?: number
  }

  /**
   * character_humanity without action
   */
  export type character_humanityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_humanity
     */
    select?: character_humanitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_humanity
     */
    omit?: character_humanityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_humanityInclude<ExtArgs> | null
  }


  /**
   * Model character_profile
   */

  export type AggregateCharacter_profile = {
    _count: Character_profileCountAggregateOutputType | null
    _avg: Character_profileAvgAggregateOutputType | null
    _sum: Character_profileSumAggregateOutputType | null
    _min: Character_profileMinAggregateOutputType | null
    _max: Character_profileMaxAggregateOutputType | null
  }

  export type Character_profileAvgAggregateOutputType = {
    age: number | null
    apparent_age: number | null
  }

  export type Character_profileSumAggregateOutputType = {
    age: number | null
    apparent_age: number | null
  }

  export type Character_profileMinAggregateOutputType = {
    id: string | null
    char_id: string | null
    description: string | null
    birthday: Date | null
    notes: string | null
    age: number | null
    embraced_at: Date | null
    apparent_age: number | null
    concept: string | null
  }

  export type Character_profileMaxAggregateOutputType = {
    id: string | null
    char_id: string | null
    description: string | null
    birthday: Date | null
    notes: string | null
    age: number | null
    embraced_at: Date | null
    apparent_age: number | null
    concept: string | null
  }

  export type Character_profileCountAggregateOutputType = {
    id: number
    char_id: number
    description: number
    birthday: number
    notes: number
    age: number
    embraced_at: number
    apparent_age: number
    concept: number
    _all: number
  }


  export type Character_profileAvgAggregateInputType = {
    age?: true
    apparent_age?: true
  }

  export type Character_profileSumAggregateInputType = {
    age?: true
    apparent_age?: true
  }

  export type Character_profileMinAggregateInputType = {
    id?: true
    char_id?: true
    description?: true
    birthday?: true
    notes?: true
    age?: true
    embraced_at?: true
    apparent_age?: true
    concept?: true
  }

  export type Character_profileMaxAggregateInputType = {
    id?: true
    char_id?: true
    description?: true
    birthday?: true
    notes?: true
    age?: true
    embraced_at?: true
    apparent_age?: true
    concept?: true
  }

  export type Character_profileCountAggregateInputType = {
    id?: true
    char_id?: true
    description?: true
    birthday?: true
    notes?: true
    age?: true
    embraced_at?: true
    apparent_age?: true
    concept?: true
    _all?: true
  }

  export type Character_profileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which character_profile to aggregate.
     */
    where?: character_profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_profiles to fetch.
     */
    orderBy?: character_profileOrderByWithRelationInput | character_profileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: character_profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned character_profiles
    **/
    _count?: true | Character_profileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Character_profileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Character_profileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Character_profileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Character_profileMaxAggregateInputType
  }

  export type GetCharacter_profileAggregateType<T extends Character_profileAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacter_profile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacter_profile[P]>
      : GetScalarType<T[P], AggregateCharacter_profile[P]>
  }




  export type character_profileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: character_profileWhereInput
    orderBy?: character_profileOrderByWithAggregationInput | character_profileOrderByWithAggregationInput[]
    by: Character_profileScalarFieldEnum[] | Character_profileScalarFieldEnum
    having?: character_profileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Character_profileCountAggregateInputType | true
    _avg?: Character_profileAvgAggregateInputType
    _sum?: Character_profileSumAggregateInputType
    _min?: Character_profileMinAggregateInputType
    _max?: Character_profileMaxAggregateInputType
  }

  export type Character_profileGroupByOutputType = {
    id: string
    char_id: string
    description: string
    birthday: Date
    notes: string | null
    age: number
    embraced_at: Date
    apparent_age: number
    concept: string | null
    _count: Character_profileCountAggregateOutputType | null
    _avg: Character_profileAvgAggregateOutputType | null
    _sum: Character_profileSumAggregateOutputType | null
    _min: Character_profileMinAggregateOutputType | null
    _max: Character_profileMaxAggregateOutputType | null
  }

  type GetCharacter_profileGroupByPayload<T extends character_profileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Character_profileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Character_profileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Character_profileGroupByOutputType[P]>
            : GetScalarType<T[P], Character_profileGroupByOutputType[P]>
        }
      >
    >


  export type character_profileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    char_id?: boolean
    description?: boolean
    birthday?: boolean
    notes?: boolean
    age?: boolean
    embraced_at?: boolean
    apparent_age?: boolean
    concept?: boolean
    characters?: boolean | charactersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character_profile"]>

  export type character_profileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    char_id?: boolean
    description?: boolean
    birthday?: boolean
    notes?: boolean
    age?: boolean
    embraced_at?: boolean
    apparent_age?: boolean
    concept?: boolean
    characters?: boolean | charactersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character_profile"]>

  export type character_profileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    char_id?: boolean
    description?: boolean
    birthday?: boolean
    notes?: boolean
    age?: boolean
    embraced_at?: boolean
    apparent_age?: boolean
    concept?: boolean
    characters?: boolean | charactersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character_profile"]>

  export type character_profileSelectScalar = {
    id?: boolean
    char_id?: boolean
    description?: boolean
    birthday?: boolean
    notes?: boolean
    age?: boolean
    embraced_at?: boolean
    apparent_age?: boolean
    concept?: boolean
  }

  export type character_profileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "char_id" | "description" | "birthday" | "notes" | "age" | "embraced_at" | "apparent_age" | "concept", ExtArgs["result"]["character_profile"]>
  export type character_profileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | charactersDefaultArgs<ExtArgs>
  }
  export type character_profileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | charactersDefaultArgs<ExtArgs>
  }
  export type character_profileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | charactersDefaultArgs<ExtArgs>
  }

  export type $character_profilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "character_profile"
    objects: {
      characters: Prisma.$charactersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      char_id: string
      description: string
      birthday: Date
      notes: string | null
      age: number
      embraced_at: Date
      apparent_age: number
      concept: string | null
    }, ExtArgs["result"]["character_profile"]>
    composites: {}
  }

  type character_profileGetPayload<S extends boolean | null | undefined | character_profileDefaultArgs> = $Result.GetResult<Prisma.$character_profilePayload, S>

  type character_profileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<character_profileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Character_profileCountAggregateInputType | true
    }

  export interface character_profileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['character_profile'], meta: { name: 'character_profile' } }
    /**
     * Find zero or one Character_profile that matches the filter.
     * @param {character_profileFindUniqueArgs} args - Arguments to find a Character_profile
     * @example
     * // Get one Character_profile
     * const character_profile = await prisma.character_profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends character_profileFindUniqueArgs>(args: SelectSubset<T, character_profileFindUniqueArgs<ExtArgs>>): Prisma__character_profileClient<$Result.GetResult<Prisma.$character_profilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Character_profile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {character_profileFindUniqueOrThrowArgs} args - Arguments to find a Character_profile
     * @example
     * // Get one Character_profile
     * const character_profile = await prisma.character_profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends character_profileFindUniqueOrThrowArgs>(args: SelectSubset<T, character_profileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__character_profileClient<$Result.GetResult<Prisma.$character_profilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Character_profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_profileFindFirstArgs} args - Arguments to find a Character_profile
     * @example
     * // Get one Character_profile
     * const character_profile = await prisma.character_profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends character_profileFindFirstArgs>(args?: SelectSubset<T, character_profileFindFirstArgs<ExtArgs>>): Prisma__character_profileClient<$Result.GetResult<Prisma.$character_profilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Character_profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_profileFindFirstOrThrowArgs} args - Arguments to find a Character_profile
     * @example
     * // Get one Character_profile
     * const character_profile = await prisma.character_profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends character_profileFindFirstOrThrowArgs>(args?: SelectSubset<T, character_profileFindFirstOrThrowArgs<ExtArgs>>): Prisma__character_profileClient<$Result.GetResult<Prisma.$character_profilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Character_profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_profileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Character_profiles
     * const character_profiles = await prisma.character_profile.findMany()
     * 
     * // Get first 10 Character_profiles
     * const character_profiles = await prisma.character_profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const character_profileWithIdOnly = await prisma.character_profile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends character_profileFindManyArgs>(args?: SelectSubset<T, character_profileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_profilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Character_profile.
     * @param {character_profileCreateArgs} args - Arguments to create a Character_profile.
     * @example
     * // Create one Character_profile
     * const Character_profile = await prisma.character_profile.create({
     *   data: {
     *     // ... data to create a Character_profile
     *   }
     * })
     * 
     */
    create<T extends character_profileCreateArgs>(args: SelectSubset<T, character_profileCreateArgs<ExtArgs>>): Prisma__character_profileClient<$Result.GetResult<Prisma.$character_profilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Character_profiles.
     * @param {character_profileCreateManyArgs} args - Arguments to create many Character_profiles.
     * @example
     * // Create many Character_profiles
     * const character_profile = await prisma.character_profile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends character_profileCreateManyArgs>(args?: SelectSubset<T, character_profileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Character_profiles and returns the data saved in the database.
     * @param {character_profileCreateManyAndReturnArgs} args - Arguments to create many Character_profiles.
     * @example
     * // Create many Character_profiles
     * const character_profile = await prisma.character_profile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Character_profiles and only return the `id`
     * const character_profileWithIdOnly = await prisma.character_profile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends character_profileCreateManyAndReturnArgs>(args?: SelectSubset<T, character_profileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_profilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Character_profile.
     * @param {character_profileDeleteArgs} args - Arguments to delete one Character_profile.
     * @example
     * // Delete one Character_profile
     * const Character_profile = await prisma.character_profile.delete({
     *   where: {
     *     // ... filter to delete one Character_profile
     *   }
     * })
     * 
     */
    delete<T extends character_profileDeleteArgs>(args: SelectSubset<T, character_profileDeleteArgs<ExtArgs>>): Prisma__character_profileClient<$Result.GetResult<Prisma.$character_profilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Character_profile.
     * @param {character_profileUpdateArgs} args - Arguments to update one Character_profile.
     * @example
     * // Update one Character_profile
     * const character_profile = await prisma.character_profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends character_profileUpdateArgs>(args: SelectSubset<T, character_profileUpdateArgs<ExtArgs>>): Prisma__character_profileClient<$Result.GetResult<Prisma.$character_profilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Character_profiles.
     * @param {character_profileDeleteManyArgs} args - Arguments to filter Character_profiles to delete.
     * @example
     * // Delete a few Character_profiles
     * const { count } = await prisma.character_profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends character_profileDeleteManyArgs>(args?: SelectSubset<T, character_profileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Character_profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_profileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Character_profiles
     * const character_profile = await prisma.character_profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends character_profileUpdateManyArgs>(args: SelectSubset<T, character_profileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Character_profiles and returns the data updated in the database.
     * @param {character_profileUpdateManyAndReturnArgs} args - Arguments to update many Character_profiles.
     * @example
     * // Update many Character_profiles
     * const character_profile = await prisma.character_profile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Character_profiles and only return the `id`
     * const character_profileWithIdOnly = await prisma.character_profile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends character_profileUpdateManyAndReturnArgs>(args: SelectSubset<T, character_profileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_profilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Character_profile.
     * @param {character_profileUpsertArgs} args - Arguments to update or create a Character_profile.
     * @example
     * // Update or create a Character_profile
     * const character_profile = await prisma.character_profile.upsert({
     *   create: {
     *     // ... data to create a Character_profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Character_profile we want to update
     *   }
     * })
     */
    upsert<T extends character_profileUpsertArgs>(args: SelectSubset<T, character_profileUpsertArgs<ExtArgs>>): Prisma__character_profileClient<$Result.GetResult<Prisma.$character_profilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Character_profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_profileCountArgs} args - Arguments to filter Character_profiles to count.
     * @example
     * // Count the number of Character_profiles
     * const count = await prisma.character_profile.count({
     *   where: {
     *     // ... the filter for the Character_profiles we want to count
     *   }
     * })
    **/
    count<T extends character_profileCountArgs>(
      args?: Subset<T, character_profileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Character_profileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Character_profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Character_profileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Character_profileAggregateArgs>(args: Subset<T, Character_profileAggregateArgs>): Prisma.PrismaPromise<GetCharacter_profileAggregateType<T>>

    /**
     * Group by Character_profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_profileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends character_profileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: character_profileGroupByArgs['orderBy'] }
        : { orderBy?: character_profileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, character_profileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacter_profileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the character_profile model
   */
  readonly fields: character_profileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for character_profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__character_profileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    characters<T extends charactersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, charactersDefaultArgs<ExtArgs>>): Prisma__charactersClient<$Result.GetResult<Prisma.$charactersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the character_profile model
   */
  interface character_profileFieldRefs {
    readonly id: FieldRef<"character_profile", 'String'>
    readonly char_id: FieldRef<"character_profile", 'String'>
    readonly description: FieldRef<"character_profile", 'String'>
    readonly birthday: FieldRef<"character_profile", 'DateTime'>
    readonly notes: FieldRef<"character_profile", 'String'>
    readonly age: FieldRef<"character_profile", 'Int'>
    readonly embraced_at: FieldRef<"character_profile", 'DateTime'>
    readonly apparent_age: FieldRef<"character_profile", 'Int'>
    readonly concept: FieldRef<"character_profile", 'String'>
  }
    

  // Custom InputTypes
  /**
   * character_profile findUnique
   */
  export type character_profileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_profile
     */
    select?: character_profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_profile
     */
    omit?: character_profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_profileInclude<ExtArgs> | null
    /**
     * Filter, which character_profile to fetch.
     */
    where: character_profileWhereUniqueInput
  }

  /**
   * character_profile findUniqueOrThrow
   */
  export type character_profileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_profile
     */
    select?: character_profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_profile
     */
    omit?: character_profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_profileInclude<ExtArgs> | null
    /**
     * Filter, which character_profile to fetch.
     */
    where: character_profileWhereUniqueInput
  }

  /**
   * character_profile findFirst
   */
  export type character_profileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_profile
     */
    select?: character_profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_profile
     */
    omit?: character_profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_profileInclude<ExtArgs> | null
    /**
     * Filter, which character_profile to fetch.
     */
    where?: character_profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_profiles to fetch.
     */
    orderBy?: character_profileOrderByWithRelationInput | character_profileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for character_profiles.
     */
    cursor?: character_profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of character_profiles.
     */
    distinct?: Character_profileScalarFieldEnum | Character_profileScalarFieldEnum[]
  }

  /**
   * character_profile findFirstOrThrow
   */
  export type character_profileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_profile
     */
    select?: character_profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_profile
     */
    omit?: character_profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_profileInclude<ExtArgs> | null
    /**
     * Filter, which character_profile to fetch.
     */
    where?: character_profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_profiles to fetch.
     */
    orderBy?: character_profileOrderByWithRelationInput | character_profileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for character_profiles.
     */
    cursor?: character_profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of character_profiles.
     */
    distinct?: Character_profileScalarFieldEnum | Character_profileScalarFieldEnum[]
  }

  /**
   * character_profile findMany
   */
  export type character_profileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_profile
     */
    select?: character_profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_profile
     */
    omit?: character_profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_profileInclude<ExtArgs> | null
    /**
     * Filter, which character_profiles to fetch.
     */
    where?: character_profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_profiles to fetch.
     */
    orderBy?: character_profileOrderByWithRelationInput | character_profileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing character_profiles.
     */
    cursor?: character_profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_profiles.
     */
    skip?: number
    distinct?: Character_profileScalarFieldEnum | Character_profileScalarFieldEnum[]
  }

  /**
   * character_profile create
   */
  export type character_profileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_profile
     */
    select?: character_profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_profile
     */
    omit?: character_profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_profileInclude<ExtArgs> | null
    /**
     * The data needed to create a character_profile.
     */
    data: XOR<character_profileCreateInput, character_profileUncheckedCreateInput>
  }

  /**
   * character_profile createMany
   */
  export type character_profileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many character_profiles.
     */
    data: character_profileCreateManyInput | character_profileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * character_profile createManyAndReturn
   */
  export type character_profileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_profile
     */
    select?: character_profileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the character_profile
     */
    omit?: character_profileOmit<ExtArgs> | null
    /**
     * The data used to create many character_profiles.
     */
    data: character_profileCreateManyInput | character_profileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_profileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * character_profile update
   */
  export type character_profileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_profile
     */
    select?: character_profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_profile
     */
    omit?: character_profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_profileInclude<ExtArgs> | null
    /**
     * The data needed to update a character_profile.
     */
    data: XOR<character_profileUpdateInput, character_profileUncheckedUpdateInput>
    /**
     * Choose, which character_profile to update.
     */
    where: character_profileWhereUniqueInput
  }

  /**
   * character_profile updateMany
   */
  export type character_profileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update character_profiles.
     */
    data: XOR<character_profileUpdateManyMutationInput, character_profileUncheckedUpdateManyInput>
    /**
     * Filter which character_profiles to update
     */
    where?: character_profileWhereInput
    /**
     * Limit how many character_profiles to update.
     */
    limit?: number
  }

  /**
   * character_profile updateManyAndReturn
   */
  export type character_profileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_profile
     */
    select?: character_profileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the character_profile
     */
    omit?: character_profileOmit<ExtArgs> | null
    /**
     * The data used to update character_profiles.
     */
    data: XOR<character_profileUpdateManyMutationInput, character_profileUncheckedUpdateManyInput>
    /**
     * Filter which character_profiles to update
     */
    where?: character_profileWhereInput
    /**
     * Limit how many character_profiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_profileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * character_profile upsert
   */
  export type character_profileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_profile
     */
    select?: character_profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_profile
     */
    omit?: character_profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_profileInclude<ExtArgs> | null
    /**
     * The filter to search for the character_profile to update in case it exists.
     */
    where: character_profileWhereUniqueInput
    /**
     * In case the character_profile found by the `where` argument doesn't exist, create a new character_profile with this data.
     */
    create: XOR<character_profileCreateInput, character_profileUncheckedCreateInput>
    /**
     * In case the character_profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<character_profileUpdateInput, character_profileUncheckedUpdateInput>
  }

  /**
   * character_profile delete
   */
  export type character_profileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_profile
     */
    select?: character_profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_profile
     */
    omit?: character_profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_profileInclude<ExtArgs> | null
    /**
     * Filter which character_profile to delete.
     */
    where: character_profileWhereUniqueInput
  }

  /**
   * character_profile deleteMany
   */
  export type character_profileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which character_profiles to delete
     */
    where?: character_profileWhereInput
    /**
     * Limit how many character_profiles to delete.
     */
    limit?: number
  }

  /**
   * character_profile without action
   */
  export type character_profileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_profile
     */
    select?: character_profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_profile
     */
    omit?: character_profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_profileInclude<ExtArgs> | null
  }


  /**
   * Model character_rituals
   */

  export type AggregateCharacter_rituals = {
    _count: Character_ritualsCountAggregateOutputType | null
    _min: Character_ritualsMinAggregateOutputType | null
    _max: Character_ritualsMaxAggregateOutputType | null
  }

  export type Character_ritualsMinAggregateOutputType = {
    id: string | null
    char_id: string | null
    ritual_id: string | null
  }

  export type Character_ritualsMaxAggregateOutputType = {
    id: string | null
    char_id: string | null
    ritual_id: string | null
  }

  export type Character_ritualsCountAggregateOutputType = {
    id: number
    char_id: number
    ritual_id: number
    _all: number
  }


  export type Character_ritualsMinAggregateInputType = {
    id?: true
    char_id?: true
    ritual_id?: true
  }

  export type Character_ritualsMaxAggregateInputType = {
    id?: true
    char_id?: true
    ritual_id?: true
  }

  export type Character_ritualsCountAggregateInputType = {
    id?: true
    char_id?: true
    ritual_id?: true
    _all?: true
  }

  export type Character_ritualsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which character_rituals to aggregate.
     */
    where?: character_ritualsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_rituals to fetch.
     */
    orderBy?: character_ritualsOrderByWithRelationInput | character_ritualsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: character_ritualsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_rituals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_rituals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned character_rituals
    **/
    _count?: true | Character_ritualsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Character_ritualsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Character_ritualsMaxAggregateInputType
  }

  export type GetCharacter_ritualsAggregateType<T extends Character_ritualsAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacter_rituals]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacter_rituals[P]>
      : GetScalarType<T[P], AggregateCharacter_rituals[P]>
  }




  export type character_ritualsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: character_ritualsWhereInput
    orderBy?: character_ritualsOrderByWithAggregationInput | character_ritualsOrderByWithAggregationInput[]
    by: Character_ritualsScalarFieldEnum[] | Character_ritualsScalarFieldEnum
    having?: character_ritualsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Character_ritualsCountAggregateInputType | true
    _min?: Character_ritualsMinAggregateInputType
    _max?: Character_ritualsMaxAggregateInputType
  }

  export type Character_ritualsGroupByOutputType = {
    id: string
    char_id: string
    ritual_id: string
    _count: Character_ritualsCountAggregateOutputType | null
    _min: Character_ritualsMinAggregateOutputType | null
    _max: Character_ritualsMaxAggregateOutputType | null
  }

  type GetCharacter_ritualsGroupByPayload<T extends character_ritualsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Character_ritualsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Character_ritualsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Character_ritualsGroupByOutputType[P]>
            : GetScalarType<T[P], Character_ritualsGroupByOutputType[P]>
        }
      >
    >


  export type character_ritualsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    char_id?: boolean
    ritual_id?: boolean
    characters?: boolean | charactersDefaultArgs<ExtArgs>
    rituals?: boolean | ritualsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character_rituals"]>

  export type character_ritualsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    char_id?: boolean
    ritual_id?: boolean
    characters?: boolean | charactersDefaultArgs<ExtArgs>
    rituals?: boolean | ritualsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character_rituals"]>

  export type character_ritualsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    char_id?: boolean
    ritual_id?: boolean
    characters?: boolean | charactersDefaultArgs<ExtArgs>
    rituals?: boolean | ritualsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character_rituals"]>

  export type character_ritualsSelectScalar = {
    id?: boolean
    char_id?: boolean
    ritual_id?: boolean
  }

  export type character_ritualsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "char_id" | "ritual_id", ExtArgs["result"]["character_rituals"]>
  export type character_ritualsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | charactersDefaultArgs<ExtArgs>
    rituals?: boolean | ritualsDefaultArgs<ExtArgs>
  }
  export type character_ritualsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | charactersDefaultArgs<ExtArgs>
    rituals?: boolean | ritualsDefaultArgs<ExtArgs>
  }
  export type character_ritualsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | charactersDefaultArgs<ExtArgs>
    rituals?: boolean | ritualsDefaultArgs<ExtArgs>
  }

  export type $character_ritualsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "character_rituals"
    objects: {
      characters: Prisma.$charactersPayload<ExtArgs>
      rituals: Prisma.$ritualsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      char_id: string
      ritual_id: string
    }, ExtArgs["result"]["character_rituals"]>
    composites: {}
  }

  type character_ritualsGetPayload<S extends boolean | null | undefined | character_ritualsDefaultArgs> = $Result.GetResult<Prisma.$character_ritualsPayload, S>

  type character_ritualsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<character_ritualsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Character_ritualsCountAggregateInputType | true
    }

  export interface character_ritualsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['character_rituals'], meta: { name: 'character_rituals' } }
    /**
     * Find zero or one Character_rituals that matches the filter.
     * @param {character_ritualsFindUniqueArgs} args - Arguments to find a Character_rituals
     * @example
     * // Get one Character_rituals
     * const character_rituals = await prisma.character_rituals.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends character_ritualsFindUniqueArgs>(args: SelectSubset<T, character_ritualsFindUniqueArgs<ExtArgs>>): Prisma__character_ritualsClient<$Result.GetResult<Prisma.$character_ritualsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Character_rituals that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {character_ritualsFindUniqueOrThrowArgs} args - Arguments to find a Character_rituals
     * @example
     * // Get one Character_rituals
     * const character_rituals = await prisma.character_rituals.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends character_ritualsFindUniqueOrThrowArgs>(args: SelectSubset<T, character_ritualsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__character_ritualsClient<$Result.GetResult<Prisma.$character_ritualsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Character_rituals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_ritualsFindFirstArgs} args - Arguments to find a Character_rituals
     * @example
     * // Get one Character_rituals
     * const character_rituals = await prisma.character_rituals.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends character_ritualsFindFirstArgs>(args?: SelectSubset<T, character_ritualsFindFirstArgs<ExtArgs>>): Prisma__character_ritualsClient<$Result.GetResult<Prisma.$character_ritualsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Character_rituals that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_ritualsFindFirstOrThrowArgs} args - Arguments to find a Character_rituals
     * @example
     * // Get one Character_rituals
     * const character_rituals = await prisma.character_rituals.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends character_ritualsFindFirstOrThrowArgs>(args?: SelectSubset<T, character_ritualsFindFirstOrThrowArgs<ExtArgs>>): Prisma__character_ritualsClient<$Result.GetResult<Prisma.$character_ritualsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Character_rituals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_ritualsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Character_rituals
     * const character_rituals = await prisma.character_rituals.findMany()
     * 
     * // Get first 10 Character_rituals
     * const character_rituals = await prisma.character_rituals.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const character_ritualsWithIdOnly = await prisma.character_rituals.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends character_ritualsFindManyArgs>(args?: SelectSubset<T, character_ritualsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_ritualsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Character_rituals.
     * @param {character_ritualsCreateArgs} args - Arguments to create a Character_rituals.
     * @example
     * // Create one Character_rituals
     * const Character_rituals = await prisma.character_rituals.create({
     *   data: {
     *     // ... data to create a Character_rituals
     *   }
     * })
     * 
     */
    create<T extends character_ritualsCreateArgs>(args: SelectSubset<T, character_ritualsCreateArgs<ExtArgs>>): Prisma__character_ritualsClient<$Result.GetResult<Prisma.$character_ritualsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Character_rituals.
     * @param {character_ritualsCreateManyArgs} args - Arguments to create many Character_rituals.
     * @example
     * // Create many Character_rituals
     * const character_rituals = await prisma.character_rituals.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends character_ritualsCreateManyArgs>(args?: SelectSubset<T, character_ritualsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Character_rituals and returns the data saved in the database.
     * @param {character_ritualsCreateManyAndReturnArgs} args - Arguments to create many Character_rituals.
     * @example
     * // Create many Character_rituals
     * const character_rituals = await prisma.character_rituals.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Character_rituals and only return the `id`
     * const character_ritualsWithIdOnly = await prisma.character_rituals.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends character_ritualsCreateManyAndReturnArgs>(args?: SelectSubset<T, character_ritualsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_ritualsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Character_rituals.
     * @param {character_ritualsDeleteArgs} args - Arguments to delete one Character_rituals.
     * @example
     * // Delete one Character_rituals
     * const Character_rituals = await prisma.character_rituals.delete({
     *   where: {
     *     // ... filter to delete one Character_rituals
     *   }
     * })
     * 
     */
    delete<T extends character_ritualsDeleteArgs>(args: SelectSubset<T, character_ritualsDeleteArgs<ExtArgs>>): Prisma__character_ritualsClient<$Result.GetResult<Prisma.$character_ritualsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Character_rituals.
     * @param {character_ritualsUpdateArgs} args - Arguments to update one Character_rituals.
     * @example
     * // Update one Character_rituals
     * const character_rituals = await prisma.character_rituals.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends character_ritualsUpdateArgs>(args: SelectSubset<T, character_ritualsUpdateArgs<ExtArgs>>): Prisma__character_ritualsClient<$Result.GetResult<Prisma.$character_ritualsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Character_rituals.
     * @param {character_ritualsDeleteManyArgs} args - Arguments to filter Character_rituals to delete.
     * @example
     * // Delete a few Character_rituals
     * const { count } = await prisma.character_rituals.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends character_ritualsDeleteManyArgs>(args?: SelectSubset<T, character_ritualsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Character_rituals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_ritualsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Character_rituals
     * const character_rituals = await prisma.character_rituals.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends character_ritualsUpdateManyArgs>(args: SelectSubset<T, character_ritualsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Character_rituals and returns the data updated in the database.
     * @param {character_ritualsUpdateManyAndReturnArgs} args - Arguments to update many Character_rituals.
     * @example
     * // Update many Character_rituals
     * const character_rituals = await prisma.character_rituals.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Character_rituals and only return the `id`
     * const character_ritualsWithIdOnly = await prisma.character_rituals.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends character_ritualsUpdateManyAndReturnArgs>(args: SelectSubset<T, character_ritualsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_ritualsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Character_rituals.
     * @param {character_ritualsUpsertArgs} args - Arguments to update or create a Character_rituals.
     * @example
     * // Update or create a Character_rituals
     * const character_rituals = await prisma.character_rituals.upsert({
     *   create: {
     *     // ... data to create a Character_rituals
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Character_rituals we want to update
     *   }
     * })
     */
    upsert<T extends character_ritualsUpsertArgs>(args: SelectSubset<T, character_ritualsUpsertArgs<ExtArgs>>): Prisma__character_ritualsClient<$Result.GetResult<Prisma.$character_ritualsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Character_rituals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_ritualsCountArgs} args - Arguments to filter Character_rituals to count.
     * @example
     * // Count the number of Character_rituals
     * const count = await prisma.character_rituals.count({
     *   where: {
     *     // ... the filter for the Character_rituals we want to count
     *   }
     * })
    **/
    count<T extends character_ritualsCountArgs>(
      args?: Subset<T, character_ritualsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Character_ritualsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Character_rituals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Character_ritualsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Character_ritualsAggregateArgs>(args: Subset<T, Character_ritualsAggregateArgs>): Prisma.PrismaPromise<GetCharacter_ritualsAggregateType<T>>

    /**
     * Group by Character_rituals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_ritualsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends character_ritualsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: character_ritualsGroupByArgs['orderBy'] }
        : { orderBy?: character_ritualsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, character_ritualsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacter_ritualsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the character_rituals model
   */
  readonly fields: character_ritualsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for character_rituals.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__character_ritualsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    characters<T extends charactersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, charactersDefaultArgs<ExtArgs>>): Prisma__charactersClient<$Result.GetResult<Prisma.$charactersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    rituals<T extends ritualsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ritualsDefaultArgs<ExtArgs>>): Prisma__ritualsClient<$Result.GetResult<Prisma.$ritualsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the character_rituals model
   */
  interface character_ritualsFieldRefs {
    readonly id: FieldRef<"character_rituals", 'String'>
    readonly char_id: FieldRef<"character_rituals", 'String'>
    readonly ritual_id: FieldRef<"character_rituals", 'String'>
  }
    

  // Custom InputTypes
  /**
   * character_rituals findUnique
   */
  export type character_ritualsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_rituals
     */
    select?: character_ritualsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_rituals
     */
    omit?: character_ritualsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_ritualsInclude<ExtArgs> | null
    /**
     * Filter, which character_rituals to fetch.
     */
    where: character_ritualsWhereUniqueInput
  }

  /**
   * character_rituals findUniqueOrThrow
   */
  export type character_ritualsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_rituals
     */
    select?: character_ritualsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_rituals
     */
    omit?: character_ritualsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_ritualsInclude<ExtArgs> | null
    /**
     * Filter, which character_rituals to fetch.
     */
    where: character_ritualsWhereUniqueInput
  }

  /**
   * character_rituals findFirst
   */
  export type character_ritualsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_rituals
     */
    select?: character_ritualsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_rituals
     */
    omit?: character_ritualsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_ritualsInclude<ExtArgs> | null
    /**
     * Filter, which character_rituals to fetch.
     */
    where?: character_ritualsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_rituals to fetch.
     */
    orderBy?: character_ritualsOrderByWithRelationInput | character_ritualsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for character_rituals.
     */
    cursor?: character_ritualsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_rituals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_rituals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of character_rituals.
     */
    distinct?: Character_ritualsScalarFieldEnum | Character_ritualsScalarFieldEnum[]
  }

  /**
   * character_rituals findFirstOrThrow
   */
  export type character_ritualsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_rituals
     */
    select?: character_ritualsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_rituals
     */
    omit?: character_ritualsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_ritualsInclude<ExtArgs> | null
    /**
     * Filter, which character_rituals to fetch.
     */
    where?: character_ritualsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_rituals to fetch.
     */
    orderBy?: character_ritualsOrderByWithRelationInput | character_ritualsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for character_rituals.
     */
    cursor?: character_ritualsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_rituals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_rituals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of character_rituals.
     */
    distinct?: Character_ritualsScalarFieldEnum | Character_ritualsScalarFieldEnum[]
  }

  /**
   * character_rituals findMany
   */
  export type character_ritualsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_rituals
     */
    select?: character_ritualsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_rituals
     */
    omit?: character_ritualsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_ritualsInclude<ExtArgs> | null
    /**
     * Filter, which character_rituals to fetch.
     */
    where?: character_ritualsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_rituals to fetch.
     */
    orderBy?: character_ritualsOrderByWithRelationInput | character_ritualsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing character_rituals.
     */
    cursor?: character_ritualsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_rituals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_rituals.
     */
    skip?: number
    distinct?: Character_ritualsScalarFieldEnum | Character_ritualsScalarFieldEnum[]
  }

  /**
   * character_rituals create
   */
  export type character_ritualsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_rituals
     */
    select?: character_ritualsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_rituals
     */
    omit?: character_ritualsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_ritualsInclude<ExtArgs> | null
    /**
     * The data needed to create a character_rituals.
     */
    data: XOR<character_ritualsCreateInput, character_ritualsUncheckedCreateInput>
  }

  /**
   * character_rituals createMany
   */
  export type character_ritualsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many character_rituals.
     */
    data: character_ritualsCreateManyInput | character_ritualsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * character_rituals createManyAndReturn
   */
  export type character_ritualsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_rituals
     */
    select?: character_ritualsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the character_rituals
     */
    omit?: character_ritualsOmit<ExtArgs> | null
    /**
     * The data used to create many character_rituals.
     */
    data: character_ritualsCreateManyInput | character_ritualsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_ritualsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * character_rituals update
   */
  export type character_ritualsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_rituals
     */
    select?: character_ritualsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_rituals
     */
    omit?: character_ritualsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_ritualsInclude<ExtArgs> | null
    /**
     * The data needed to update a character_rituals.
     */
    data: XOR<character_ritualsUpdateInput, character_ritualsUncheckedUpdateInput>
    /**
     * Choose, which character_rituals to update.
     */
    where: character_ritualsWhereUniqueInput
  }

  /**
   * character_rituals updateMany
   */
  export type character_ritualsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update character_rituals.
     */
    data: XOR<character_ritualsUpdateManyMutationInput, character_ritualsUncheckedUpdateManyInput>
    /**
     * Filter which character_rituals to update
     */
    where?: character_ritualsWhereInput
    /**
     * Limit how many character_rituals to update.
     */
    limit?: number
  }

  /**
   * character_rituals updateManyAndReturn
   */
  export type character_ritualsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_rituals
     */
    select?: character_ritualsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the character_rituals
     */
    omit?: character_ritualsOmit<ExtArgs> | null
    /**
     * The data used to update character_rituals.
     */
    data: XOR<character_ritualsUpdateManyMutationInput, character_ritualsUncheckedUpdateManyInput>
    /**
     * Filter which character_rituals to update
     */
    where?: character_ritualsWhereInput
    /**
     * Limit how many character_rituals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_ritualsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * character_rituals upsert
   */
  export type character_ritualsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_rituals
     */
    select?: character_ritualsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_rituals
     */
    omit?: character_ritualsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_ritualsInclude<ExtArgs> | null
    /**
     * The filter to search for the character_rituals to update in case it exists.
     */
    where: character_ritualsWhereUniqueInput
    /**
     * In case the character_rituals found by the `where` argument doesn't exist, create a new character_rituals with this data.
     */
    create: XOR<character_ritualsCreateInput, character_ritualsUncheckedCreateInput>
    /**
     * In case the character_rituals was found with the provided `where` argument, update it with this data.
     */
    update: XOR<character_ritualsUpdateInput, character_ritualsUncheckedUpdateInput>
  }

  /**
   * character_rituals delete
   */
  export type character_ritualsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_rituals
     */
    select?: character_ritualsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_rituals
     */
    omit?: character_ritualsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_ritualsInclude<ExtArgs> | null
    /**
     * Filter which character_rituals to delete.
     */
    where: character_ritualsWhereUniqueInput
  }

  /**
   * character_rituals deleteMany
   */
  export type character_ritualsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which character_rituals to delete
     */
    where?: character_ritualsWhereInput
    /**
     * Limit how many character_rituals to delete.
     */
    limit?: number
  }

  /**
   * character_rituals without action
   */
  export type character_ritualsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_rituals
     */
    select?: character_ritualsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_rituals
     */
    omit?: character_ritualsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_ritualsInclude<ExtArgs> | null
  }


  /**
   * Model character_skills
   */

  export type AggregateCharacter_skills = {
    _count: Character_skillsCountAggregateOutputType | null
    _avg: Character_skillsAvgAggregateOutputType | null
    _sum: Character_skillsSumAggregateOutputType | null
    _min: Character_skillsMinAggregateOutputType | null
    _max: Character_skillsMaxAggregateOutputType | null
  }

  export type Character_skillsAvgAggregateOutputType = {
    level: number | null
  }

  export type Character_skillsSumAggregateOutputType = {
    level: number | null
  }

  export type Character_skillsMinAggregateOutputType = {
    id: string | null
    char_id: string | null
    skill_id: string | null
    level: number | null
  }

  export type Character_skillsMaxAggregateOutputType = {
    id: string | null
    char_id: string | null
    skill_id: string | null
    level: number | null
  }

  export type Character_skillsCountAggregateOutputType = {
    id: number
    char_id: number
    skill_id: number
    level: number
    _all: number
  }


  export type Character_skillsAvgAggregateInputType = {
    level?: true
  }

  export type Character_skillsSumAggregateInputType = {
    level?: true
  }

  export type Character_skillsMinAggregateInputType = {
    id?: true
    char_id?: true
    skill_id?: true
    level?: true
  }

  export type Character_skillsMaxAggregateInputType = {
    id?: true
    char_id?: true
    skill_id?: true
    level?: true
  }

  export type Character_skillsCountAggregateInputType = {
    id?: true
    char_id?: true
    skill_id?: true
    level?: true
    _all?: true
  }

  export type Character_skillsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which character_skills to aggregate.
     */
    where?: character_skillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_skills to fetch.
     */
    orderBy?: character_skillsOrderByWithRelationInput | character_skillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: character_skillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned character_skills
    **/
    _count?: true | Character_skillsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Character_skillsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Character_skillsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Character_skillsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Character_skillsMaxAggregateInputType
  }

  export type GetCharacter_skillsAggregateType<T extends Character_skillsAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacter_skills]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacter_skills[P]>
      : GetScalarType<T[P], AggregateCharacter_skills[P]>
  }




  export type character_skillsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: character_skillsWhereInput
    orderBy?: character_skillsOrderByWithAggregationInput | character_skillsOrderByWithAggregationInput[]
    by: Character_skillsScalarFieldEnum[] | Character_skillsScalarFieldEnum
    having?: character_skillsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Character_skillsCountAggregateInputType | true
    _avg?: Character_skillsAvgAggregateInputType
    _sum?: Character_skillsSumAggregateInputType
    _min?: Character_skillsMinAggregateInputType
    _max?: Character_skillsMaxAggregateInputType
  }

  export type Character_skillsGroupByOutputType = {
    id: string
    char_id: string
    skill_id: string
    level: number
    _count: Character_skillsCountAggregateOutputType | null
    _avg: Character_skillsAvgAggregateOutputType | null
    _sum: Character_skillsSumAggregateOutputType | null
    _min: Character_skillsMinAggregateOutputType | null
    _max: Character_skillsMaxAggregateOutputType | null
  }

  type GetCharacter_skillsGroupByPayload<T extends character_skillsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Character_skillsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Character_skillsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Character_skillsGroupByOutputType[P]>
            : GetScalarType<T[P], Character_skillsGroupByOutputType[P]>
        }
      >
    >


  export type character_skillsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    char_id?: boolean
    skill_id?: boolean
    level?: boolean
    characters?: boolean | charactersDefaultArgs<ExtArgs>
    skills?: boolean | skillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character_skills"]>

  export type character_skillsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    char_id?: boolean
    skill_id?: boolean
    level?: boolean
    characters?: boolean | charactersDefaultArgs<ExtArgs>
    skills?: boolean | skillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character_skills"]>

  export type character_skillsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    char_id?: boolean
    skill_id?: boolean
    level?: boolean
    characters?: boolean | charactersDefaultArgs<ExtArgs>
    skills?: boolean | skillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character_skills"]>

  export type character_skillsSelectScalar = {
    id?: boolean
    char_id?: boolean
    skill_id?: boolean
    level?: boolean
  }

  export type character_skillsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "char_id" | "skill_id" | "level", ExtArgs["result"]["character_skills"]>
  export type character_skillsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | charactersDefaultArgs<ExtArgs>
    skills?: boolean | skillsDefaultArgs<ExtArgs>
  }
  export type character_skillsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | charactersDefaultArgs<ExtArgs>
    skills?: boolean | skillsDefaultArgs<ExtArgs>
  }
  export type character_skillsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | charactersDefaultArgs<ExtArgs>
    skills?: boolean | skillsDefaultArgs<ExtArgs>
  }

  export type $character_skillsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "character_skills"
    objects: {
      characters: Prisma.$charactersPayload<ExtArgs>
      skills: Prisma.$skillsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      char_id: string
      skill_id: string
      level: number
    }, ExtArgs["result"]["character_skills"]>
    composites: {}
  }

  type character_skillsGetPayload<S extends boolean | null | undefined | character_skillsDefaultArgs> = $Result.GetResult<Prisma.$character_skillsPayload, S>

  type character_skillsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<character_skillsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Character_skillsCountAggregateInputType | true
    }

  export interface character_skillsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['character_skills'], meta: { name: 'character_skills' } }
    /**
     * Find zero or one Character_skills that matches the filter.
     * @param {character_skillsFindUniqueArgs} args - Arguments to find a Character_skills
     * @example
     * // Get one Character_skills
     * const character_skills = await prisma.character_skills.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends character_skillsFindUniqueArgs>(args: SelectSubset<T, character_skillsFindUniqueArgs<ExtArgs>>): Prisma__character_skillsClient<$Result.GetResult<Prisma.$character_skillsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Character_skills that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {character_skillsFindUniqueOrThrowArgs} args - Arguments to find a Character_skills
     * @example
     * // Get one Character_skills
     * const character_skills = await prisma.character_skills.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends character_skillsFindUniqueOrThrowArgs>(args: SelectSubset<T, character_skillsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__character_skillsClient<$Result.GetResult<Prisma.$character_skillsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Character_skills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_skillsFindFirstArgs} args - Arguments to find a Character_skills
     * @example
     * // Get one Character_skills
     * const character_skills = await prisma.character_skills.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends character_skillsFindFirstArgs>(args?: SelectSubset<T, character_skillsFindFirstArgs<ExtArgs>>): Prisma__character_skillsClient<$Result.GetResult<Prisma.$character_skillsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Character_skills that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_skillsFindFirstOrThrowArgs} args - Arguments to find a Character_skills
     * @example
     * // Get one Character_skills
     * const character_skills = await prisma.character_skills.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends character_skillsFindFirstOrThrowArgs>(args?: SelectSubset<T, character_skillsFindFirstOrThrowArgs<ExtArgs>>): Prisma__character_skillsClient<$Result.GetResult<Prisma.$character_skillsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Character_skills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_skillsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Character_skills
     * const character_skills = await prisma.character_skills.findMany()
     * 
     * // Get first 10 Character_skills
     * const character_skills = await prisma.character_skills.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const character_skillsWithIdOnly = await prisma.character_skills.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends character_skillsFindManyArgs>(args?: SelectSubset<T, character_skillsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_skillsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Character_skills.
     * @param {character_skillsCreateArgs} args - Arguments to create a Character_skills.
     * @example
     * // Create one Character_skills
     * const Character_skills = await prisma.character_skills.create({
     *   data: {
     *     // ... data to create a Character_skills
     *   }
     * })
     * 
     */
    create<T extends character_skillsCreateArgs>(args: SelectSubset<T, character_skillsCreateArgs<ExtArgs>>): Prisma__character_skillsClient<$Result.GetResult<Prisma.$character_skillsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Character_skills.
     * @param {character_skillsCreateManyArgs} args - Arguments to create many Character_skills.
     * @example
     * // Create many Character_skills
     * const character_skills = await prisma.character_skills.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends character_skillsCreateManyArgs>(args?: SelectSubset<T, character_skillsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Character_skills and returns the data saved in the database.
     * @param {character_skillsCreateManyAndReturnArgs} args - Arguments to create many Character_skills.
     * @example
     * // Create many Character_skills
     * const character_skills = await prisma.character_skills.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Character_skills and only return the `id`
     * const character_skillsWithIdOnly = await prisma.character_skills.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends character_skillsCreateManyAndReturnArgs>(args?: SelectSubset<T, character_skillsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_skillsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Character_skills.
     * @param {character_skillsDeleteArgs} args - Arguments to delete one Character_skills.
     * @example
     * // Delete one Character_skills
     * const Character_skills = await prisma.character_skills.delete({
     *   where: {
     *     // ... filter to delete one Character_skills
     *   }
     * })
     * 
     */
    delete<T extends character_skillsDeleteArgs>(args: SelectSubset<T, character_skillsDeleteArgs<ExtArgs>>): Prisma__character_skillsClient<$Result.GetResult<Prisma.$character_skillsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Character_skills.
     * @param {character_skillsUpdateArgs} args - Arguments to update one Character_skills.
     * @example
     * // Update one Character_skills
     * const character_skills = await prisma.character_skills.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends character_skillsUpdateArgs>(args: SelectSubset<T, character_skillsUpdateArgs<ExtArgs>>): Prisma__character_skillsClient<$Result.GetResult<Prisma.$character_skillsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Character_skills.
     * @param {character_skillsDeleteManyArgs} args - Arguments to filter Character_skills to delete.
     * @example
     * // Delete a few Character_skills
     * const { count } = await prisma.character_skills.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends character_skillsDeleteManyArgs>(args?: SelectSubset<T, character_skillsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Character_skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_skillsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Character_skills
     * const character_skills = await prisma.character_skills.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends character_skillsUpdateManyArgs>(args: SelectSubset<T, character_skillsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Character_skills and returns the data updated in the database.
     * @param {character_skillsUpdateManyAndReturnArgs} args - Arguments to update many Character_skills.
     * @example
     * // Update many Character_skills
     * const character_skills = await prisma.character_skills.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Character_skills and only return the `id`
     * const character_skillsWithIdOnly = await prisma.character_skills.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends character_skillsUpdateManyAndReturnArgs>(args: SelectSubset<T, character_skillsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_skillsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Character_skills.
     * @param {character_skillsUpsertArgs} args - Arguments to update or create a Character_skills.
     * @example
     * // Update or create a Character_skills
     * const character_skills = await prisma.character_skills.upsert({
     *   create: {
     *     // ... data to create a Character_skills
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Character_skills we want to update
     *   }
     * })
     */
    upsert<T extends character_skillsUpsertArgs>(args: SelectSubset<T, character_skillsUpsertArgs<ExtArgs>>): Prisma__character_skillsClient<$Result.GetResult<Prisma.$character_skillsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Character_skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_skillsCountArgs} args - Arguments to filter Character_skills to count.
     * @example
     * // Count the number of Character_skills
     * const count = await prisma.character_skills.count({
     *   where: {
     *     // ... the filter for the Character_skills we want to count
     *   }
     * })
    **/
    count<T extends character_skillsCountArgs>(
      args?: Subset<T, character_skillsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Character_skillsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Character_skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Character_skillsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Character_skillsAggregateArgs>(args: Subset<T, Character_skillsAggregateArgs>): Prisma.PrismaPromise<GetCharacter_skillsAggregateType<T>>

    /**
     * Group by Character_skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_skillsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends character_skillsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: character_skillsGroupByArgs['orderBy'] }
        : { orderBy?: character_skillsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, character_skillsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacter_skillsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the character_skills model
   */
  readonly fields: character_skillsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for character_skills.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__character_skillsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    characters<T extends charactersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, charactersDefaultArgs<ExtArgs>>): Prisma__charactersClient<$Result.GetResult<Prisma.$charactersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    skills<T extends skillsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, skillsDefaultArgs<ExtArgs>>): Prisma__skillsClient<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the character_skills model
   */
  interface character_skillsFieldRefs {
    readonly id: FieldRef<"character_skills", 'String'>
    readonly char_id: FieldRef<"character_skills", 'String'>
    readonly skill_id: FieldRef<"character_skills", 'String'>
    readonly level: FieldRef<"character_skills", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * character_skills findUnique
   */
  export type character_skillsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_skills
     */
    select?: character_skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_skills
     */
    omit?: character_skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_skillsInclude<ExtArgs> | null
    /**
     * Filter, which character_skills to fetch.
     */
    where: character_skillsWhereUniqueInput
  }

  /**
   * character_skills findUniqueOrThrow
   */
  export type character_skillsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_skills
     */
    select?: character_skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_skills
     */
    omit?: character_skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_skillsInclude<ExtArgs> | null
    /**
     * Filter, which character_skills to fetch.
     */
    where: character_skillsWhereUniqueInput
  }

  /**
   * character_skills findFirst
   */
  export type character_skillsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_skills
     */
    select?: character_skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_skills
     */
    omit?: character_skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_skillsInclude<ExtArgs> | null
    /**
     * Filter, which character_skills to fetch.
     */
    where?: character_skillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_skills to fetch.
     */
    orderBy?: character_skillsOrderByWithRelationInput | character_skillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for character_skills.
     */
    cursor?: character_skillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of character_skills.
     */
    distinct?: Character_skillsScalarFieldEnum | Character_skillsScalarFieldEnum[]
  }

  /**
   * character_skills findFirstOrThrow
   */
  export type character_skillsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_skills
     */
    select?: character_skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_skills
     */
    omit?: character_skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_skillsInclude<ExtArgs> | null
    /**
     * Filter, which character_skills to fetch.
     */
    where?: character_skillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_skills to fetch.
     */
    orderBy?: character_skillsOrderByWithRelationInput | character_skillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for character_skills.
     */
    cursor?: character_skillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of character_skills.
     */
    distinct?: Character_skillsScalarFieldEnum | Character_skillsScalarFieldEnum[]
  }

  /**
   * character_skills findMany
   */
  export type character_skillsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_skills
     */
    select?: character_skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_skills
     */
    omit?: character_skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_skillsInclude<ExtArgs> | null
    /**
     * Filter, which character_skills to fetch.
     */
    where?: character_skillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_skills to fetch.
     */
    orderBy?: character_skillsOrderByWithRelationInput | character_skillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing character_skills.
     */
    cursor?: character_skillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_skills.
     */
    skip?: number
    distinct?: Character_skillsScalarFieldEnum | Character_skillsScalarFieldEnum[]
  }

  /**
   * character_skills create
   */
  export type character_skillsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_skills
     */
    select?: character_skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_skills
     */
    omit?: character_skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_skillsInclude<ExtArgs> | null
    /**
     * The data needed to create a character_skills.
     */
    data: XOR<character_skillsCreateInput, character_skillsUncheckedCreateInput>
  }

  /**
   * character_skills createMany
   */
  export type character_skillsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many character_skills.
     */
    data: character_skillsCreateManyInput | character_skillsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * character_skills createManyAndReturn
   */
  export type character_skillsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_skills
     */
    select?: character_skillsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the character_skills
     */
    omit?: character_skillsOmit<ExtArgs> | null
    /**
     * The data used to create many character_skills.
     */
    data: character_skillsCreateManyInput | character_skillsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_skillsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * character_skills update
   */
  export type character_skillsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_skills
     */
    select?: character_skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_skills
     */
    omit?: character_skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_skillsInclude<ExtArgs> | null
    /**
     * The data needed to update a character_skills.
     */
    data: XOR<character_skillsUpdateInput, character_skillsUncheckedUpdateInput>
    /**
     * Choose, which character_skills to update.
     */
    where: character_skillsWhereUniqueInput
  }

  /**
   * character_skills updateMany
   */
  export type character_skillsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update character_skills.
     */
    data: XOR<character_skillsUpdateManyMutationInput, character_skillsUncheckedUpdateManyInput>
    /**
     * Filter which character_skills to update
     */
    where?: character_skillsWhereInput
    /**
     * Limit how many character_skills to update.
     */
    limit?: number
  }

  /**
   * character_skills updateManyAndReturn
   */
  export type character_skillsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_skills
     */
    select?: character_skillsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the character_skills
     */
    omit?: character_skillsOmit<ExtArgs> | null
    /**
     * The data used to update character_skills.
     */
    data: XOR<character_skillsUpdateManyMutationInput, character_skillsUncheckedUpdateManyInput>
    /**
     * Filter which character_skills to update
     */
    where?: character_skillsWhereInput
    /**
     * Limit how many character_skills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_skillsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * character_skills upsert
   */
  export type character_skillsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_skills
     */
    select?: character_skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_skills
     */
    omit?: character_skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_skillsInclude<ExtArgs> | null
    /**
     * The filter to search for the character_skills to update in case it exists.
     */
    where: character_skillsWhereUniqueInput
    /**
     * In case the character_skills found by the `where` argument doesn't exist, create a new character_skills with this data.
     */
    create: XOR<character_skillsCreateInput, character_skillsUncheckedCreateInput>
    /**
     * In case the character_skills was found with the provided `where` argument, update it with this data.
     */
    update: XOR<character_skillsUpdateInput, character_skillsUncheckedUpdateInput>
  }

  /**
   * character_skills delete
   */
  export type character_skillsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_skills
     */
    select?: character_skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_skills
     */
    omit?: character_skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_skillsInclude<ExtArgs> | null
    /**
     * Filter which character_skills to delete.
     */
    where: character_skillsWhereUniqueInput
  }

  /**
   * character_skills deleteMany
   */
  export type character_skillsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which character_skills to delete
     */
    where?: character_skillsWhereInput
    /**
     * Limit how many character_skills to delete.
     */
    limit?: number
  }

  /**
   * character_skills without action
   */
  export type character_skillsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_skills
     */
    select?: character_skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_skills
     */
    omit?: character_skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_skillsInclude<ExtArgs> | null
  }


  /**
   * Model character_specialties
   */

  export type AggregateCharacter_specialties = {
    _count: Character_specialtiesCountAggregateOutputType | null
    _min: Character_specialtiesMinAggregateOutputType | null
    _max: Character_specialtiesMaxAggregateOutputType | null
  }

  export type Character_specialtiesMinAggregateOutputType = {
    id: string | null
    char_id: string | null
    skill_id: string | null
    specialty_name: string | null
  }

  export type Character_specialtiesMaxAggregateOutputType = {
    id: string | null
    char_id: string | null
    skill_id: string | null
    specialty_name: string | null
  }

  export type Character_specialtiesCountAggregateOutputType = {
    id: number
    char_id: number
    skill_id: number
    specialty_name: number
    _all: number
  }


  export type Character_specialtiesMinAggregateInputType = {
    id?: true
    char_id?: true
    skill_id?: true
    specialty_name?: true
  }

  export type Character_specialtiesMaxAggregateInputType = {
    id?: true
    char_id?: true
    skill_id?: true
    specialty_name?: true
  }

  export type Character_specialtiesCountAggregateInputType = {
    id?: true
    char_id?: true
    skill_id?: true
    specialty_name?: true
    _all?: true
  }

  export type Character_specialtiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which character_specialties to aggregate.
     */
    where?: character_specialtiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_specialties to fetch.
     */
    orderBy?: character_specialtiesOrderByWithRelationInput | character_specialtiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: character_specialtiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_specialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_specialties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned character_specialties
    **/
    _count?: true | Character_specialtiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Character_specialtiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Character_specialtiesMaxAggregateInputType
  }

  export type GetCharacter_specialtiesAggregateType<T extends Character_specialtiesAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacter_specialties]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacter_specialties[P]>
      : GetScalarType<T[P], AggregateCharacter_specialties[P]>
  }




  export type character_specialtiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: character_specialtiesWhereInput
    orderBy?: character_specialtiesOrderByWithAggregationInput | character_specialtiesOrderByWithAggregationInput[]
    by: Character_specialtiesScalarFieldEnum[] | Character_specialtiesScalarFieldEnum
    having?: character_specialtiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Character_specialtiesCountAggregateInputType | true
    _min?: Character_specialtiesMinAggregateInputType
    _max?: Character_specialtiesMaxAggregateInputType
  }

  export type Character_specialtiesGroupByOutputType = {
    id: string
    char_id: string
    skill_id: string
    specialty_name: string
    _count: Character_specialtiesCountAggregateOutputType | null
    _min: Character_specialtiesMinAggregateOutputType | null
    _max: Character_specialtiesMaxAggregateOutputType | null
  }

  type GetCharacter_specialtiesGroupByPayload<T extends character_specialtiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Character_specialtiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Character_specialtiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Character_specialtiesGroupByOutputType[P]>
            : GetScalarType<T[P], Character_specialtiesGroupByOutputType[P]>
        }
      >
    >


  export type character_specialtiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    char_id?: boolean
    skill_id?: boolean
    specialty_name?: boolean
    characters?: boolean | charactersDefaultArgs<ExtArgs>
    skills?: boolean | skillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character_specialties"]>

  export type character_specialtiesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    char_id?: boolean
    skill_id?: boolean
    specialty_name?: boolean
    characters?: boolean | charactersDefaultArgs<ExtArgs>
    skills?: boolean | skillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character_specialties"]>

  export type character_specialtiesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    char_id?: boolean
    skill_id?: boolean
    specialty_name?: boolean
    characters?: boolean | charactersDefaultArgs<ExtArgs>
    skills?: boolean | skillsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character_specialties"]>

  export type character_specialtiesSelectScalar = {
    id?: boolean
    char_id?: boolean
    skill_id?: boolean
    specialty_name?: boolean
  }

  export type character_specialtiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "char_id" | "skill_id" | "specialty_name", ExtArgs["result"]["character_specialties"]>
  export type character_specialtiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | charactersDefaultArgs<ExtArgs>
    skills?: boolean | skillsDefaultArgs<ExtArgs>
  }
  export type character_specialtiesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | charactersDefaultArgs<ExtArgs>
    skills?: boolean | skillsDefaultArgs<ExtArgs>
  }
  export type character_specialtiesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | charactersDefaultArgs<ExtArgs>
    skills?: boolean | skillsDefaultArgs<ExtArgs>
  }

  export type $character_specialtiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "character_specialties"
    objects: {
      characters: Prisma.$charactersPayload<ExtArgs>
      skills: Prisma.$skillsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      char_id: string
      skill_id: string
      specialty_name: string
    }, ExtArgs["result"]["character_specialties"]>
    composites: {}
  }

  type character_specialtiesGetPayload<S extends boolean | null | undefined | character_specialtiesDefaultArgs> = $Result.GetResult<Prisma.$character_specialtiesPayload, S>

  type character_specialtiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<character_specialtiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Character_specialtiesCountAggregateInputType | true
    }

  export interface character_specialtiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['character_specialties'], meta: { name: 'character_specialties' } }
    /**
     * Find zero or one Character_specialties that matches the filter.
     * @param {character_specialtiesFindUniqueArgs} args - Arguments to find a Character_specialties
     * @example
     * // Get one Character_specialties
     * const character_specialties = await prisma.character_specialties.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends character_specialtiesFindUniqueArgs>(args: SelectSubset<T, character_specialtiesFindUniqueArgs<ExtArgs>>): Prisma__character_specialtiesClient<$Result.GetResult<Prisma.$character_specialtiesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Character_specialties that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {character_specialtiesFindUniqueOrThrowArgs} args - Arguments to find a Character_specialties
     * @example
     * // Get one Character_specialties
     * const character_specialties = await prisma.character_specialties.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends character_specialtiesFindUniqueOrThrowArgs>(args: SelectSubset<T, character_specialtiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__character_specialtiesClient<$Result.GetResult<Prisma.$character_specialtiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Character_specialties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_specialtiesFindFirstArgs} args - Arguments to find a Character_specialties
     * @example
     * // Get one Character_specialties
     * const character_specialties = await prisma.character_specialties.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends character_specialtiesFindFirstArgs>(args?: SelectSubset<T, character_specialtiesFindFirstArgs<ExtArgs>>): Prisma__character_specialtiesClient<$Result.GetResult<Prisma.$character_specialtiesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Character_specialties that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_specialtiesFindFirstOrThrowArgs} args - Arguments to find a Character_specialties
     * @example
     * // Get one Character_specialties
     * const character_specialties = await prisma.character_specialties.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends character_specialtiesFindFirstOrThrowArgs>(args?: SelectSubset<T, character_specialtiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__character_specialtiesClient<$Result.GetResult<Prisma.$character_specialtiesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Character_specialties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_specialtiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Character_specialties
     * const character_specialties = await prisma.character_specialties.findMany()
     * 
     * // Get first 10 Character_specialties
     * const character_specialties = await prisma.character_specialties.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const character_specialtiesWithIdOnly = await prisma.character_specialties.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends character_specialtiesFindManyArgs>(args?: SelectSubset<T, character_specialtiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_specialtiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Character_specialties.
     * @param {character_specialtiesCreateArgs} args - Arguments to create a Character_specialties.
     * @example
     * // Create one Character_specialties
     * const Character_specialties = await prisma.character_specialties.create({
     *   data: {
     *     // ... data to create a Character_specialties
     *   }
     * })
     * 
     */
    create<T extends character_specialtiesCreateArgs>(args: SelectSubset<T, character_specialtiesCreateArgs<ExtArgs>>): Prisma__character_specialtiesClient<$Result.GetResult<Prisma.$character_specialtiesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Character_specialties.
     * @param {character_specialtiesCreateManyArgs} args - Arguments to create many Character_specialties.
     * @example
     * // Create many Character_specialties
     * const character_specialties = await prisma.character_specialties.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends character_specialtiesCreateManyArgs>(args?: SelectSubset<T, character_specialtiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Character_specialties and returns the data saved in the database.
     * @param {character_specialtiesCreateManyAndReturnArgs} args - Arguments to create many Character_specialties.
     * @example
     * // Create many Character_specialties
     * const character_specialties = await prisma.character_specialties.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Character_specialties and only return the `id`
     * const character_specialtiesWithIdOnly = await prisma.character_specialties.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends character_specialtiesCreateManyAndReturnArgs>(args?: SelectSubset<T, character_specialtiesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_specialtiesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Character_specialties.
     * @param {character_specialtiesDeleteArgs} args - Arguments to delete one Character_specialties.
     * @example
     * // Delete one Character_specialties
     * const Character_specialties = await prisma.character_specialties.delete({
     *   where: {
     *     // ... filter to delete one Character_specialties
     *   }
     * })
     * 
     */
    delete<T extends character_specialtiesDeleteArgs>(args: SelectSubset<T, character_specialtiesDeleteArgs<ExtArgs>>): Prisma__character_specialtiesClient<$Result.GetResult<Prisma.$character_specialtiesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Character_specialties.
     * @param {character_specialtiesUpdateArgs} args - Arguments to update one Character_specialties.
     * @example
     * // Update one Character_specialties
     * const character_specialties = await prisma.character_specialties.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends character_specialtiesUpdateArgs>(args: SelectSubset<T, character_specialtiesUpdateArgs<ExtArgs>>): Prisma__character_specialtiesClient<$Result.GetResult<Prisma.$character_specialtiesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Character_specialties.
     * @param {character_specialtiesDeleteManyArgs} args - Arguments to filter Character_specialties to delete.
     * @example
     * // Delete a few Character_specialties
     * const { count } = await prisma.character_specialties.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends character_specialtiesDeleteManyArgs>(args?: SelectSubset<T, character_specialtiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Character_specialties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_specialtiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Character_specialties
     * const character_specialties = await prisma.character_specialties.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends character_specialtiesUpdateManyArgs>(args: SelectSubset<T, character_specialtiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Character_specialties and returns the data updated in the database.
     * @param {character_specialtiesUpdateManyAndReturnArgs} args - Arguments to update many Character_specialties.
     * @example
     * // Update many Character_specialties
     * const character_specialties = await prisma.character_specialties.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Character_specialties and only return the `id`
     * const character_specialtiesWithIdOnly = await prisma.character_specialties.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends character_specialtiesUpdateManyAndReturnArgs>(args: SelectSubset<T, character_specialtiesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_specialtiesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Character_specialties.
     * @param {character_specialtiesUpsertArgs} args - Arguments to update or create a Character_specialties.
     * @example
     * // Update or create a Character_specialties
     * const character_specialties = await prisma.character_specialties.upsert({
     *   create: {
     *     // ... data to create a Character_specialties
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Character_specialties we want to update
     *   }
     * })
     */
    upsert<T extends character_specialtiesUpsertArgs>(args: SelectSubset<T, character_specialtiesUpsertArgs<ExtArgs>>): Prisma__character_specialtiesClient<$Result.GetResult<Prisma.$character_specialtiesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Character_specialties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_specialtiesCountArgs} args - Arguments to filter Character_specialties to count.
     * @example
     * // Count the number of Character_specialties
     * const count = await prisma.character_specialties.count({
     *   where: {
     *     // ... the filter for the Character_specialties we want to count
     *   }
     * })
    **/
    count<T extends character_specialtiesCountArgs>(
      args?: Subset<T, character_specialtiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Character_specialtiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Character_specialties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Character_specialtiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Character_specialtiesAggregateArgs>(args: Subset<T, Character_specialtiesAggregateArgs>): Prisma.PrismaPromise<GetCharacter_specialtiesAggregateType<T>>

    /**
     * Group by Character_specialties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_specialtiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends character_specialtiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: character_specialtiesGroupByArgs['orderBy'] }
        : { orderBy?: character_specialtiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, character_specialtiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacter_specialtiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the character_specialties model
   */
  readonly fields: character_specialtiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for character_specialties.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__character_specialtiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    characters<T extends charactersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, charactersDefaultArgs<ExtArgs>>): Prisma__charactersClient<$Result.GetResult<Prisma.$charactersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    skills<T extends skillsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, skillsDefaultArgs<ExtArgs>>): Prisma__skillsClient<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the character_specialties model
   */
  interface character_specialtiesFieldRefs {
    readonly id: FieldRef<"character_specialties", 'String'>
    readonly char_id: FieldRef<"character_specialties", 'String'>
    readonly skill_id: FieldRef<"character_specialties", 'String'>
    readonly specialty_name: FieldRef<"character_specialties", 'String'>
  }
    

  // Custom InputTypes
  /**
   * character_specialties findUnique
   */
  export type character_specialtiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_specialties
     */
    select?: character_specialtiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_specialties
     */
    omit?: character_specialtiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_specialtiesInclude<ExtArgs> | null
    /**
     * Filter, which character_specialties to fetch.
     */
    where: character_specialtiesWhereUniqueInput
  }

  /**
   * character_specialties findUniqueOrThrow
   */
  export type character_specialtiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_specialties
     */
    select?: character_specialtiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_specialties
     */
    omit?: character_specialtiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_specialtiesInclude<ExtArgs> | null
    /**
     * Filter, which character_specialties to fetch.
     */
    where: character_specialtiesWhereUniqueInput
  }

  /**
   * character_specialties findFirst
   */
  export type character_specialtiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_specialties
     */
    select?: character_specialtiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_specialties
     */
    omit?: character_specialtiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_specialtiesInclude<ExtArgs> | null
    /**
     * Filter, which character_specialties to fetch.
     */
    where?: character_specialtiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_specialties to fetch.
     */
    orderBy?: character_specialtiesOrderByWithRelationInput | character_specialtiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for character_specialties.
     */
    cursor?: character_specialtiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_specialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_specialties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of character_specialties.
     */
    distinct?: Character_specialtiesScalarFieldEnum | Character_specialtiesScalarFieldEnum[]
  }

  /**
   * character_specialties findFirstOrThrow
   */
  export type character_specialtiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_specialties
     */
    select?: character_specialtiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_specialties
     */
    omit?: character_specialtiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_specialtiesInclude<ExtArgs> | null
    /**
     * Filter, which character_specialties to fetch.
     */
    where?: character_specialtiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_specialties to fetch.
     */
    orderBy?: character_specialtiesOrderByWithRelationInput | character_specialtiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for character_specialties.
     */
    cursor?: character_specialtiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_specialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_specialties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of character_specialties.
     */
    distinct?: Character_specialtiesScalarFieldEnum | Character_specialtiesScalarFieldEnum[]
  }

  /**
   * character_specialties findMany
   */
  export type character_specialtiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_specialties
     */
    select?: character_specialtiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_specialties
     */
    omit?: character_specialtiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_specialtiesInclude<ExtArgs> | null
    /**
     * Filter, which character_specialties to fetch.
     */
    where?: character_specialtiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_specialties to fetch.
     */
    orderBy?: character_specialtiesOrderByWithRelationInput | character_specialtiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing character_specialties.
     */
    cursor?: character_specialtiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_specialties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_specialties.
     */
    skip?: number
    distinct?: Character_specialtiesScalarFieldEnum | Character_specialtiesScalarFieldEnum[]
  }

  /**
   * character_specialties create
   */
  export type character_specialtiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_specialties
     */
    select?: character_specialtiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_specialties
     */
    omit?: character_specialtiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_specialtiesInclude<ExtArgs> | null
    /**
     * The data needed to create a character_specialties.
     */
    data: XOR<character_specialtiesCreateInput, character_specialtiesUncheckedCreateInput>
  }

  /**
   * character_specialties createMany
   */
  export type character_specialtiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many character_specialties.
     */
    data: character_specialtiesCreateManyInput | character_specialtiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * character_specialties createManyAndReturn
   */
  export type character_specialtiesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_specialties
     */
    select?: character_specialtiesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the character_specialties
     */
    omit?: character_specialtiesOmit<ExtArgs> | null
    /**
     * The data used to create many character_specialties.
     */
    data: character_specialtiesCreateManyInput | character_specialtiesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_specialtiesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * character_specialties update
   */
  export type character_specialtiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_specialties
     */
    select?: character_specialtiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_specialties
     */
    omit?: character_specialtiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_specialtiesInclude<ExtArgs> | null
    /**
     * The data needed to update a character_specialties.
     */
    data: XOR<character_specialtiesUpdateInput, character_specialtiesUncheckedUpdateInput>
    /**
     * Choose, which character_specialties to update.
     */
    where: character_specialtiesWhereUniqueInput
  }

  /**
   * character_specialties updateMany
   */
  export type character_specialtiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update character_specialties.
     */
    data: XOR<character_specialtiesUpdateManyMutationInput, character_specialtiesUncheckedUpdateManyInput>
    /**
     * Filter which character_specialties to update
     */
    where?: character_specialtiesWhereInput
    /**
     * Limit how many character_specialties to update.
     */
    limit?: number
  }

  /**
   * character_specialties updateManyAndReturn
   */
  export type character_specialtiesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_specialties
     */
    select?: character_specialtiesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the character_specialties
     */
    omit?: character_specialtiesOmit<ExtArgs> | null
    /**
     * The data used to update character_specialties.
     */
    data: XOR<character_specialtiesUpdateManyMutationInput, character_specialtiesUncheckedUpdateManyInput>
    /**
     * Filter which character_specialties to update
     */
    where?: character_specialtiesWhereInput
    /**
     * Limit how many character_specialties to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_specialtiesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * character_specialties upsert
   */
  export type character_specialtiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_specialties
     */
    select?: character_specialtiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_specialties
     */
    omit?: character_specialtiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_specialtiesInclude<ExtArgs> | null
    /**
     * The filter to search for the character_specialties to update in case it exists.
     */
    where: character_specialtiesWhereUniqueInput
    /**
     * In case the character_specialties found by the `where` argument doesn't exist, create a new character_specialties with this data.
     */
    create: XOR<character_specialtiesCreateInput, character_specialtiesUncheckedCreateInput>
    /**
     * In case the character_specialties was found with the provided `where` argument, update it with this data.
     */
    update: XOR<character_specialtiesUpdateInput, character_specialtiesUncheckedUpdateInput>
  }

  /**
   * character_specialties delete
   */
  export type character_specialtiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_specialties
     */
    select?: character_specialtiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_specialties
     */
    omit?: character_specialtiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_specialtiesInclude<ExtArgs> | null
    /**
     * Filter which character_specialties to delete.
     */
    where: character_specialtiesWhereUniqueInput
  }

  /**
   * character_specialties deleteMany
   */
  export type character_specialtiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which character_specialties to delete
     */
    where?: character_specialtiesWhereInput
    /**
     * Limit how many character_specialties to delete.
     */
    limit?: number
  }

  /**
   * character_specialties without action
   */
  export type character_specialtiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_specialties
     */
    select?: character_specialtiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_specialties
     */
    omit?: character_specialtiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_specialtiesInclude<ExtArgs> | null
  }


  /**
   * Model character_willpowers
   */

  export type AggregateCharacter_willpowers = {
    _count: Character_willpowersCountAggregateOutputType | null
    _avg: Character_willpowersAvgAggregateOutputType | null
    _sum: Character_willpowersSumAggregateOutputType | null
    _min: Character_willpowersMinAggregateOutputType | null
    _max: Character_willpowersMaxAggregateOutputType | null
  }

  export type Character_willpowersAvgAggregateOutputType = {
    max_willpower: number | null
    current_aggravated: number | null
    current_superficial: number | null
  }

  export type Character_willpowersSumAggregateOutputType = {
    max_willpower: number | null
    current_aggravated: number | null
    current_superficial: number | null
  }

  export type Character_willpowersMinAggregateOutputType = {
    id: string | null
    char_id: string | null
    max_willpower: number | null
    current_aggravated: number | null
    current_superficial: number | null
  }

  export type Character_willpowersMaxAggregateOutputType = {
    id: string | null
    char_id: string | null
    max_willpower: number | null
    current_aggravated: number | null
    current_superficial: number | null
  }

  export type Character_willpowersCountAggregateOutputType = {
    id: number
    char_id: number
    max_willpower: number
    current_aggravated: number
    current_superficial: number
    _all: number
  }


  export type Character_willpowersAvgAggregateInputType = {
    max_willpower?: true
    current_aggravated?: true
    current_superficial?: true
  }

  export type Character_willpowersSumAggregateInputType = {
    max_willpower?: true
    current_aggravated?: true
    current_superficial?: true
  }

  export type Character_willpowersMinAggregateInputType = {
    id?: true
    char_id?: true
    max_willpower?: true
    current_aggravated?: true
    current_superficial?: true
  }

  export type Character_willpowersMaxAggregateInputType = {
    id?: true
    char_id?: true
    max_willpower?: true
    current_aggravated?: true
    current_superficial?: true
  }

  export type Character_willpowersCountAggregateInputType = {
    id?: true
    char_id?: true
    max_willpower?: true
    current_aggravated?: true
    current_superficial?: true
    _all?: true
  }

  export type Character_willpowersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which character_willpowers to aggregate.
     */
    where?: character_willpowersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_willpowers to fetch.
     */
    orderBy?: character_willpowersOrderByWithRelationInput | character_willpowersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: character_willpowersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_willpowers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_willpowers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned character_willpowers
    **/
    _count?: true | Character_willpowersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Character_willpowersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Character_willpowersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Character_willpowersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Character_willpowersMaxAggregateInputType
  }

  export type GetCharacter_willpowersAggregateType<T extends Character_willpowersAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacter_willpowers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacter_willpowers[P]>
      : GetScalarType<T[P], AggregateCharacter_willpowers[P]>
  }




  export type character_willpowersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: character_willpowersWhereInput
    orderBy?: character_willpowersOrderByWithAggregationInput | character_willpowersOrderByWithAggregationInput[]
    by: Character_willpowersScalarFieldEnum[] | Character_willpowersScalarFieldEnum
    having?: character_willpowersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Character_willpowersCountAggregateInputType | true
    _avg?: Character_willpowersAvgAggregateInputType
    _sum?: Character_willpowersSumAggregateInputType
    _min?: Character_willpowersMinAggregateInputType
    _max?: Character_willpowersMaxAggregateInputType
  }

  export type Character_willpowersGroupByOutputType = {
    id: string
    char_id: string
    max_willpower: number
    current_aggravated: number
    current_superficial: number
    _count: Character_willpowersCountAggregateOutputType | null
    _avg: Character_willpowersAvgAggregateOutputType | null
    _sum: Character_willpowersSumAggregateOutputType | null
    _min: Character_willpowersMinAggregateOutputType | null
    _max: Character_willpowersMaxAggregateOutputType | null
  }

  type GetCharacter_willpowersGroupByPayload<T extends character_willpowersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Character_willpowersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Character_willpowersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Character_willpowersGroupByOutputType[P]>
            : GetScalarType<T[P], Character_willpowersGroupByOutputType[P]>
        }
      >
    >


  export type character_willpowersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    char_id?: boolean
    max_willpower?: boolean
    current_aggravated?: boolean
    current_superficial?: boolean
    characters?: boolean | charactersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character_willpowers"]>

  export type character_willpowersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    char_id?: boolean
    max_willpower?: boolean
    current_aggravated?: boolean
    current_superficial?: boolean
    characters?: boolean | charactersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character_willpowers"]>

  export type character_willpowersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    char_id?: boolean
    max_willpower?: boolean
    current_aggravated?: boolean
    current_superficial?: boolean
    characters?: boolean | charactersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character_willpowers"]>

  export type character_willpowersSelectScalar = {
    id?: boolean
    char_id?: boolean
    max_willpower?: boolean
    current_aggravated?: boolean
    current_superficial?: boolean
  }

  export type character_willpowersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "char_id" | "max_willpower" | "current_aggravated" | "current_superficial", ExtArgs["result"]["character_willpowers"]>
  export type character_willpowersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | charactersDefaultArgs<ExtArgs>
  }
  export type character_willpowersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | charactersDefaultArgs<ExtArgs>
  }
  export type character_willpowersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | charactersDefaultArgs<ExtArgs>
  }

  export type $character_willpowersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "character_willpowers"
    objects: {
      characters: Prisma.$charactersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      char_id: string
      max_willpower: number
      current_aggravated: number
      current_superficial: number
    }, ExtArgs["result"]["character_willpowers"]>
    composites: {}
  }

  type character_willpowersGetPayload<S extends boolean | null | undefined | character_willpowersDefaultArgs> = $Result.GetResult<Prisma.$character_willpowersPayload, S>

  type character_willpowersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<character_willpowersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Character_willpowersCountAggregateInputType | true
    }

  export interface character_willpowersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['character_willpowers'], meta: { name: 'character_willpowers' } }
    /**
     * Find zero or one Character_willpowers that matches the filter.
     * @param {character_willpowersFindUniqueArgs} args - Arguments to find a Character_willpowers
     * @example
     * // Get one Character_willpowers
     * const character_willpowers = await prisma.character_willpowers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends character_willpowersFindUniqueArgs>(args: SelectSubset<T, character_willpowersFindUniqueArgs<ExtArgs>>): Prisma__character_willpowersClient<$Result.GetResult<Prisma.$character_willpowersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Character_willpowers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {character_willpowersFindUniqueOrThrowArgs} args - Arguments to find a Character_willpowers
     * @example
     * // Get one Character_willpowers
     * const character_willpowers = await prisma.character_willpowers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends character_willpowersFindUniqueOrThrowArgs>(args: SelectSubset<T, character_willpowersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__character_willpowersClient<$Result.GetResult<Prisma.$character_willpowersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Character_willpowers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_willpowersFindFirstArgs} args - Arguments to find a Character_willpowers
     * @example
     * // Get one Character_willpowers
     * const character_willpowers = await prisma.character_willpowers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends character_willpowersFindFirstArgs>(args?: SelectSubset<T, character_willpowersFindFirstArgs<ExtArgs>>): Prisma__character_willpowersClient<$Result.GetResult<Prisma.$character_willpowersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Character_willpowers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_willpowersFindFirstOrThrowArgs} args - Arguments to find a Character_willpowers
     * @example
     * // Get one Character_willpowers
     * const character_willpowers = await prisma.character_willpowers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends character_willpowersFindFirstOrThrowArgs>(args?: SelectSubset<T, character_willpowersFindFirstOrThrowArgs<ExtArgs>>): Prisma__character_willpowersClient<$Result.GetResult<Prisma.$character_willpowersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Character_willpowers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_willpowersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Character_willpowers
     * const character_willpowers = await prisma.character_willpowers.findMany()
     * 
     * // Get first 10 Character_willpowers
     * const character_willpowers = await prisma.character_willpowers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const character_willpowersWithIdOnly = await prisma.character_willpowers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends character_willpowersFindManyArgs>(args?: SelectSubset<T, character_willpowersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_willpowersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Character_willpowers.
     * @param {character_willpowersCreateArgs} args - Arguments to create a Character_willpowers.
     * @example
     * // Create one Character_willpowers
     * const Character_willpowers = await prisma.character_willpowers.create({
     *   data: {
     *     // ... data to create a Character_willpowers
     *   }
     * })
     * 
     */
    create<T extends character_willpowersCreateArgs>(args: SelectSubset<T, character_willpowersCreateArgs<ExtArgs>>): Prisma__character_willpowersClient<$Result.GetResult<Prisma.$character_willpowersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Character_willpowers.
     * @param {character_willpowersCreateManyArgs} args - Arguments to create many Character_willpowers.
     * @example
     * // Create many Character_willpowers
     * const character_willpowers = await prisma.character_willpowers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends character_willpowersCreateManyArgs>(args?: SelectSubset<T, character_willpowersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Character_willpowers and returns the data saved in the database.
     * @param {character_willpowersCreateManyAndReturnArgs} args - Arguments to create many Character_willpowers.
     * @example
     * // Create many Character_willpowers
     * const character_willpowers = await prisma.character_willpowers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Character_willpowers and only return the `id`
     * const character_willpowersWithIdOnly = await prisma.character_willpowers.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends character_willpowersCreateManyAndReturnArgs>(args?: SelectSubset<T, character_willpowersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_willpowersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Character_willpowers.
     * @param {character_willpowersDeleteArgs} args - Arguments to delete one Character_willpowers.
     * @example
     * // Delete one Character_willpowers
     * const Character_willpowers = await prisma.character_willpowers.delete({
     *   where: {
     *     // ... filter to delete one Character_willpowers
     *   }
     * })
     * 
     */
    delete<T extends character_willpowersDeleteArgs>(args: SelectSubset<T, character_willpowersDeleteArgs<ExtArgs>>): Prisma__character_willpowersClient<$Result.GetResult<Prisma.$character_willpowersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Character_willpowers.
     * @param {character_willpowersUpdateArgs} args - Arguments to update one Character_willpowers.
     * @example
     * // Update one Character_willpowers
     * const character_willpowers = await prisma.character_willpowers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends character_willpowersUpdateArgs>(args: SelectSubset<T, character_willpowersUpdateArgs<ExtArgs>>): Prisma__character_willpowersClient<$Result.GetResult<Prisma.$character_willpowersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Character_willpowers.
     * @param {character_willpowersDeleteManyArgs} args - Arguments to filter Character_willpowers to delete.
     * @example
     * // Delete a few Character_willpowers
     * const { count } = await prisma.character_willpowers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends character_willpowersDeleteManyArgs>(args?: SelectSubset<T, character_willpowersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Character_willpowers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_willpowersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Character_willpowers
     * const character_willpowers = await prisma.character_willpowers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends character_willpowersUpdateManyArgs>(args: SelectSubset<T, character_willpowersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Character_willpowers and returns the data updated in the database.
     * @param {character_willpowersUpdateManyAndReturnArgs} args - Arguments to update many Character_willpowers.
     * @example
     * // Update many Character_willpowers
     * const character_willpowers = await prisma.character_willpowers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Character_willpowers and only return the `id`
     * const character_willpowersWithIdOnly = await prisma.character_willpowers.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends character_willpowersUpdateManyAndReturnArgs>(args: SelectSubset<T, character_willpowersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_willpowersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Character_willpowers.
     * @param {character_willpowersUpsertArgs} args - Arguments to update or create a Character_willpowers.
     * @example
     * // Update or create a Character_willpowers
     * const character_willpowers = await prisma.character_willpowers.upsert({
     *   create: {
     *     // ... data to create a Character_willpowers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Character_willpowers we want to update
     *   }
     * })
     */
    upsert<T extends character_willpowersUpsertArgs>(args: SelectSubset<T, character_willpowersUpsertArgs<ExtArgs>>): Prisma__character_willpowersClient<$Result.GetResult<Prisma.$character_willpowersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Character_willpowers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_willpowersCountArgs} args - Arguments to filter Character_willpowers to count.
     * @example
     * // Count the number of Character_willpowers
     * const count = await prisma.character_willpowers.count({
     *   where: {
     *     // ... the filter for the Character_willpowers we want to count
     *   }
     * })
    **/
    count<T extends character_willpowersCountArgs>(
      args?: Subset<T, character_willpowersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Character_willpowersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Character_willpowers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Character_willpowersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Character_willpowersAggregateArgs>(args: Subset<T, Character_willpowersAggregateArgs>): Prisma.PrismaPromise<GetCharacter_willpowersAggregateType<T>>

    /**
     * Group by Character_willpowers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {character_willpowersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends character_willpowersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: character_willpowersGroupByArgs['orderBy'] }
        : { orderBy?: character_willpowersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, character_willpowersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacter_willpowersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the character_willpowers model
   */
  readonly fields: character_willpowersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for character_willpowers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__character_willpowersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    characters<T extends charactersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, charactersDefaultArgs<ExtArgs>>): Prisma__charactersClient<$Result.GetResult<Prisma.$charactersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the character_willpowers model
   */
  interface character_willpowersFieldRefs {
    readonly id: FieldRef<"character_willpowers", 'String'>
    readonly char_id: FieldRef<"character_willpowers", 'String'>
    readonly max_willpower: FieldRef<"character_willpowers", 'Int'>
    readonly current_aggravated: FieldRef<"character_willpowers", 'Int'>
    readonly current_superficial: FieldRef<"character_willpowers", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * character_willpowers findUnique
   */
  export type character_willpowersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_willpowers
     */
    select?: character_willpowersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_willpowers
     */
    omit?: character_willpowersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_willpowersInclude<ExtArgs> | null
    /**
     * Filter, which character_willpowers to fetch.
     */
    where: character_willpowersWhereUniqueInput
  }

  /**
   * character_willpowers findUniqueOrThrow
   */
  export type character_willpowersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_willpowers
     */
    select?: character_willpowersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_willpowers
     */
    omit?: character_willpowersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_willpowersInclude<ExtArgs> | null
    /**
     * Filter, which character_willpowers to fetch.
     */
    where: character_willpowersWhereUniqueInput
  }

  /**
   * character_willpowers findFirst
   */
  export type character_willpowersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_willpowers
     */
    select?: character_willpowersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_willpowers
     */
    omit?: character_willpowersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_willpowersInclude<ExtArgs> | null
    /**
     * Filter, which character_willpowers to fetch.
     */
    where?: character_willpowersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_willpowers to fetch.
     */
    orderBy?: character_willpowersOrderByWithRelationInput | character_willpowersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for character_willpowers.
     */
    cursor?: character_willpowersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_willpowers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_willpowers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of character_willpowers.
     */
    distinct?: Character_willpowersScalarFieldEnum | Character_willpowersScalarFieldEnum[]
  }

  /**
   * character_willpowers findFirstOrThrow
   */
  export type character_willpowersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_willpowers
     */
    select?: character_willpowersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_willpowers
     */
    omit?: character_willpowersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_willpowersInclude<ExtArgs> | null
    /**
     * Filter, which character_willpowers to fetch.
     */
    where?: character_willpowersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_willpowers to fetch.
     */
    orderBy?: character_willpowersOrderByWithRelationInput | character_willpowersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for character_willpowers.
     */
    cursor?: character_willpowersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_willpowers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_willpowers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of character_willpowers.
     */
    distinct?: Character_willpowersScalarFieldEnum | Character_willpowersScalarFieldEnum[]
  }

  /**
   * character_willpowers findMany
   */
  export type character_willpowersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_willpowers
     */
    select?: character_willpowersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_willpowers
     */
    omit?: character_willpowersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_willpowersInclude<ExtArgs> | null
    /**
     * Filter, which character_willpowers to fetch.
     */
    where?: character_willpowersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of character_willpowers to fetch.
     */
    orderBy?: character_willpowersOrderByWithRelationInput | character_willpowersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing character_willpowers.
     */
    cursor?: character_willpowersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` character_willpowers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` character_willpowers.
     */
    skip?: number
    distinct?: Character_willpowersScalarFieldEnum | Character_willpowersScalarFieldEnum[]
  }

  /**
   * character_willpowers create
   */
  export type character_willpowersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_willpowers
     */
    select?: character_willpowersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_willpowers
     */
    omit?: character_willpowersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_willpowersInclude<ExtArgs> | null
    /**
     * The data needed to create a character_willpowers.
     */
    data: XOR<character_willpowersCreateInput, character_willpowersUncheckedCreateInput>
  }

  /**
   * character_willpowers createMany
   */
  export type character_willpowersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many character_willpowers.
     */
    data: character_willpowersCreateManyInput | character_willpowersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * character_willpowers createManyAndReturn
   */
  export type character_willpowersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_willpowers
     */
    select?: character_willpowersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the character_willpowers
     */
    omit?: character_willpowersOmit<ExtArgs> | null
    /**
     * The data used to create many character_willpowers.
     */
    data: character_willpowersCreateManyInput | character_willpowersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_willpowersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * character_willpowers update
   */
  export type character_willpowersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_willpowers
     */
    select?: character_willpowersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_willpowers
     */
    omit?: character_willpowersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_willpowersInclude<ExtArgs> | null
    /**
     * The data needed to update a character_willpowers.
     */
    data: XOR<character_willpowersUpdateInput, character_willpowersUncheckedUpdateInput>
    /**
     * Choose, which character_willpowers to update.
     */
    where: character_willpowersWhereUniqueInput
  }

  /**
   * character_willpowers updateMany
   */
  export type character_willpowersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update character_willpowers.
     */
    data: XOR<character_willpowersUpdateManyMutationInput, character_willpowersUncheckedUpdateManyInput>
    /**
     * Filter which character_willpowers to update
     */
    where?: character_willpowersWhereInput
    /**
     * Limit how many character_willpowers to update.
     */
    limit?: number
  }

  /**
   * character_willpowers updateManyAndReturn
   */
  export type character_willpowersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_willpowers
     */
    select?: character_willpowersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the character_willpowers
     */
    omit?: character_willpowersOmit<ExtArgs> | null
    /**
     * The data used to update character_willpowers.
     */
    data: XOR<character_willpowersUpdateManyMutationInput, character_willpowersUncheckedUpdateManyInput>
    /**
     * Filter which character_willpowers to update
     */
    where?: character_willpowersWhereInput
    /**
     * Limit how many character_willpowers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_willpowersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * character_willpowers upsert
   */
  export type character_willpowersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_willpowers
     */
    select?: character_willpowersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_willpowers
     */
    omit?: character_willpowersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_willpowersInclude<ExtArgs> | null
    /**
     * The filter to search for the character_willpowers to update in case it exists.
     */
    where: character_willpowersWhereUniqueInput
    /**
     * In case the character_willpowers found by the `where` argument doesn't exist, create a new character_willpowers with this data.
     */
    create: XOR<character_willpowersCreateInput, character_willpowersUncheckedCreateInput>
    /**
     * In case the character_willpowers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<character_willpowersUpdateInput, character_willpowersUncheckedUpdateInput>
  }

  /**
   * character_willpowers delete
   */
  export type character_willpowersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_willpowers
     */
    select?: character_willpowersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_willpowers
     */
    omit?: character_willpowersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_willpowersInclude<ExtArgs> | null
    /**
     * Filter which character_willpowers to delete.
     */
    where: character_willpowersWhereUniqueInput
  }

  /**
   * character_willpowers deleteMany
   */
  export type character_willpowersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which character_willpowers to delete
     */
    where?: character_willpowersWhereInput
    /**
     * Limit how many character_willpowers to delete.
     */
    limit?: number
  }

  /**
   * character_willpowers without action
   */
  export type character_willpowersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_willpowers
     */
    select?: character_willpowersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_willpowers
     */
    omit?: character_willpowersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_willpowersInclude<ExtArgs> | null
  }


  /**
   * Model characters
   */

  export type AggregateCharacters = {
    _count: CharactersCountAggregateOutputType | null
    _avg: CharactersAvgAggregateOutputType | null
    _sum: CharactersSumAggregateOutputType | null
    _min: CharactersMinAggregateOutputType | null
    _max: CharactersMaxAggregateOutputType | null
  }

  export type CharactersAvgAggregateOutputType = {
    generation: number | null
    total_experience: number | null
  }

  export type CharactersSumAggregateOutputType = {
    generation: number | null
    total_experience: number | null
  }

  export type CharactersMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    name: string | null
    clan_id: string | null
    clan_bane: string | null
    clan_compulsion: string | null
    sect_id: string | null
    player: string | null
    predator_type: string | null
    generation: number | null
    chronicle_id: string | null
    custom_chronicle: string | null
    ambition: string | null
    desire: string | null
    sire: string | null
    total_experience: number | null
    chronicle_tenets: string | null
    group_id: string | null
    type: $Enums.Entity | null
  }

  export type CharactersMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    name: string | null
    clan_id: string | null
    clan_bane: string | null
    clan_compulsion: string | null
    sect_id: string | null
    player: string | null
    predator_type: string | null
    generation: number | null
    chronicle_id: string | null
    custom_chronicle: string | null
    ambition: string | null
    desire: string | null
    sire: string | null
    total_experience: number | null
    chronicle_tenets: string | null
    group_id: string | null
    type: $Enums.Entity | null
  }

  export type CharactersCountAggregateOutputType = {
    id: number
    user_id: number
    name: number
    clan_id: number
    clan_bane: number
    clan_compulsion: number
    sect_id: number
    player: number
    predator_type: number
    generation: number
    chronicle_id: number
    custom_chronicle: number
    ambition: number
    desire: number
    sire: number
    total_experience: number
    chronicle_tenets: number
    group_id: number
    type: number
    _all: number
  }


  export type CharactersAvgAggregateInputType = {
    generation?: true
    total_experience?: true
  }

  export type CharactersSumAggregateInputType = {
    generation?: true
    total_experience?: true
  }

  export type CharactersMinAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    clan_id?: true
    clan_bane?: true
    clan_compulsion?: true
    sect_id?: true
    player?: true
    predator_type?: true
    generation?: true
    chronicle_id?: true
    custom_chronicle?: true
    ambition?: true
    desire?: true
    sire?: true
    total_experience?: true
    chronicle_tenets?: true
    group_id?: true
    type?: true
  }

  export type CharactersMaxAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    clan_id?: true
    clan_bane?: true
    clan_compulsion?: true
    sect_id?: true
    player?: true
    predator_type?: true
    generation?: true
    chronicle_id?: true
    custom_chronicle?: true
    ambition?: true
    desire?: true
    sire?: true
    total_experience?: true
    chronicle_tenets?: true
    group_id?: true
    type?: true
  }

  export type CharactersCountAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    clan_id?: true
    clan_bane?: true
    clan_compulsion?: true
    sect_id?: true
    player?: true
    predator_type?: true
    generation?: true
    chronicle_id?: true
    custom_chronicle?: true
    ambition?: true
    desire?: true
    sire?: true
    total_experience?: true
    chronicle_tenets?: true
    group_id?: true
    type?: true
    _all?: true
  }

  export type CharactersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which characters to aggregate.
     */
    where?: charactersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of characters to fetch.
     */
    orderBy?: charactersOrderByWithRelationInput | charactersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: charactersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned characters
    **/
    _count?: true | CharactersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CharactersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CharactersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharactersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharactersMaxAggregateInputType
  }

  export type GetCharactersAggregateType<T extends CharactersAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacters]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacters[P]>
      : GetScalarType<T[P], AggregateCharacters[P]>
  }




  export type charactersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: charactersWhereInput
    orderBy?: charactersOrderByWithAggregationInput | charactersOrderByWithAggregationInput[]
    by: CharactersScalarFieldEnum[] | CharactersScalarFieldEnum
    having?: charactersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharactersCountAggregateInputType | true
    _avg?: CharactersAvgAggregateInputType
    _sum?: CharactersSumAggregateInputType
    _min?: CharactersMinAggregateInputType
    _max?: CharactersMaxAggregateInputType
  }

  export type CharactersGroupByOutputType = {
    id: string
    user_id: string
    name: string
    clan_id: string | null
    clan_bane: string | null
    clan_compulsion: string | null
    sect_id: string | null
    player: string
    predator_type: string
    generation: number
    chronicle_id: string | null
    custom_chronicle: string | null
    ambition: string
    desire: string
    sire: string
    total_experience: number
    chronicle_tenets: string
    group_id: string
    type: $Enums.Entity
    _count: CharactersCountAggregateOutputType | null
    _avg: CharactersAvgAggregateOutputType | null
    _sum: CharactersSumAggregateOutputType | null
    _min: CharactersMinAggregateOutputType | null
    _max: CharactersMaxAggregateOutputType | null
  }

  type GetCharactersGroupByPayload<T extends charactersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharactersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharactersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharactersGroupByOutputType[P]>
            : GetScalarType<T[P], CharactersGroupByOutputType[P]>
        }
      >
    >


  export type charactersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    name?: boolean
    clan_id?: boolean
    clan_bane?: boolean
    clan_compulsion?: boolean
    sect_id?: boolean
    player?: boolean
    predator_type?: boolean
    generation?: boolean
    chronicle_id?: boolean
    custom_chronicle?: boolean
    ambition?: boolean
    desire?: boolean
    sire?: boolean
    total_experience?: boolean
    chronicle_tenets?: boolean
    group_id?: boolean
    type?: boolean
    character_advantages?: boolean | characters$character_advantagesArgs<ExtArgs>
    character_alchemy_powers?: boolean | characters$character_alchemy_powersArgs<ExtArgs>
    character_attributes?: boolean | characters$character_attributesArgs<ExtArgs>
    character_bloodpotencies?: boolean | characters$character_bloodpotenciesArgs<ExtArgs>
    character_discipline_powers?: boolean | characters$character_discipline_powersArgs<ExtArgs>
    character_disciplines?: boolean | characters$character_disciplinesArgs<ExtArgs>
    character_healths?: boolean | characters$character_healthsArgs<ExtArgs>
    character_humanity?: boolean | characters$character_humanityArgs<ExtArgs>
    character_profile?: boolean | characters$character_profileArgs<ExtArgs>
    character_rituals?: boolean | characters$character_ritualsArgs<ExtArgs>
    character_skills?: boolean | characters$character_skillsArgs<ExtArgs>
    character_specialties?: boolean | characters$character_specialtiesArgs<ExtArgs>
    character_willpowers?: boolean | characters$character_willpowersArgs<ExtArgs>
    chronicles?: boolean | characters$chroniclesArgs<ExtArgs>
    clan_banes?: boolean | characters$clan_banesArgs<ExtArgs>
    clan_compulsions?: boolean | characters$clan_compulsionsArgs<ExtArgs>
    clans?: boolean | characters$clansArgs<ExtArgs>
    char_groups?: boolean | char_groupsDefaultArgs<ExtArgs>
    predator_types?: boolean | predator_typesDefaultArgs<ExtArgs>
    sects?: boolean | characters$sectsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    exp_logs?: boolean | characters$exp_logsArgs<ExtArgs>
    _count?: boolean | CharactersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characters"]>

  export type charactersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    name?: boolean
    clan_id?: boolean
    clan_bane?: boolean
    clan_compulsion?: boolean
    sect_id?: boolean
    player?: boolean
    predator_type?: boolean
    generation?: boolean
    chronicle_id?: boolean
    custom_chronicle?: boolean
    ambition?: boolean
    desire?: boolean
    sire?: boolean
    total_experience?: boolean
    chronicle_tenets?: boolean
    group_id?: boolean
    type?: boolean
    chronicles?: boolean | characters$chroniclesArgs<ExtArgs>
    clan_banes?: boolean | characters$clan_banesArgs<ExtArgs>
    clan_compulsions?: boolean | characters$clan_compulsionsArgs<ExtArgs>
    clans?: boolean | characters$clansArgs<ExtArgs>
    char_groups?: boolean | char_groupsDefaultArgs<ExtArgs>
    predator_types?: boolean | predator_typesDefaultArgs<ExtArgs>
    sects?: boolean | characters$sectsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characters"]>

  export type charactersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    name?: boolean
    clan_id?: boolean
    clan_bane?: boolean
    clan_compulsion?: boolean
    sect_id?: boolean
    player?: boolean
    predator_type?: boolean
    generation?: boolean
    chronicle_id?: boolean
    custom_chronicle?: boolean
    ambition?: boolean
    desire?: boolean
    sire?: boolean
    total_experience?: boolean
    chronicle_tenets?: boolean
    group_id?: boolean
    type?: boolean
    chronicles?: boolean | characters$chroniclesArgs<ExtArgs>
    clan_banes?: boolean | characters$clan_banesArgs<ExtArgs>
    clan_compulsions?: boolean | characters$clan_compulsionsArgs<ExtArgs>
    clans?: boolean | characters$clansArgs<ExtArgs>
    char_groups?: boolean | char_groupsDefaultArgs<ExtArgs>
    predator_types?: boolean | predator_typesDefaultArgs<ExtArgs>
    sects?: boolean | characters$sectsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["characters"]>

  export type charactersSelectScalar = {
    id?: boolean
    user_id?: boolean
    name?: boolean
    clan_id?: boolean
    clan_bane?: boolean
    clan_compulsion?: boolean
    sect_id?: boolean
    player?: boolean
    predator_type?: boolean
    generation?: boolean
    chronicle_id?: boolean
    custom_chronicle?: boolean
    ambition?: boolean
    desire?: boolean
    sire?: boolean
    total_experience?: boolean
    chronicle_tenets?: boolean
    group_id?: boolean
    type?: boolean
  }

  export type charactersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "name" | "clan_id" | "clan_bane" | "clan_compulsion" | "sect_id" | "player" | "predator_type" | "generation" | "chronicle_id" | "custom_chronicle" | "ambition" | "desire" | "sire" | "total_experience" | "chronicle_tenets" | "group_id" | "type", ExtArgs["result"]["characters"]>
  export type charactersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character_advantages?: boolean | characters$character_advantagesArgs<ExtArgs>
    character_alchemy_powers?: boolean | characters$character_alchemy_powersArgs<ExtArgs>
    character_attributes?: boolean | characters$character_attributesArgs<ExtArgs>
    character_bloodpotencies?: boolean | characters$character_bloodpotenciesArgs<ExtArgs>
    character_discipline_powers?: boolean | characters$character_discipline_powersArgs<ExtArgs>
    character_disciplines?: boolean | characters$character_disciplinesArgs<ExtArgs>
    character_healths?: boolean | characters$character_healthsArgs<ExtArgs>
    character_humanity?: boolean | characters$character_humanityArgs<ExtArgs>
    character_profile?: boolean | characters$character_profileArgs<ExtArgs>
    character_rituals?: boolean | characters$character_ritualsArgs<ExtArgs>
    character_skills?: boolean | characters$character_skillsArgs<ExtArgs>
    character_specialties?: boolean | characters$character_specialtiesArgs<ExtArgs>
    character_willpowers?: boolean | characters$character_willpowersArgs<ExtArgs>
    chronicles?: boolean | characters$chroniclesArgs<ExtArgs>
    clan_banes?: boolean | characters$clan_banesArgs<ExtArgs>
    clan_compulsions?: boolean | characters$clan_compulsionsArgs<ExtArgs>
    clans?: boolean | characters$clansArgs<ExtArgs>
    char_groups?: boolean | char_groupsDefaultArgs<ExtArgs>
    predator_types?: boolean | predator_typesDefaultArgs<ExtArgs>
    sects?: boolean | characters$sectsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    exp_logs?: boolean | characters$exp_logsArgs<ExtArgs>
    _count?: boolean | CharactersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type charactersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chronicles?: boolean | characters$chroniclesArgs<ExtArgs>
    clan_banes?: boolean | characters$clan_banesArgs<ExtArgs>
    clan_compulsions?: boolean | characters$clan_compulsionsArgs<ExtArgs>
    clans?: boolean | characters$clansArgs<ExtArgs>
    char_groups?: boolean | char_groupsDefaultArgs<ExtArgs>
    predator_types?: boolean | predator_typesDefaultArgs<ExtArgs>
    sects?: boolean | characters$sectsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type charactersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chronicles?: boolean | characters$chroniclesArgs<ExtArgs>
    clan_banes?: boolean | characters$clan_banesArgs<ExtArgs>
    clan_compulsions?: boolean | characters$clan_compulsionsArgs<ExtArgs>
    clans?: boolean | characters$clansArgs<ExtArgs>
    char_groups?: boolean | char_groupsDefaultArgs<ExtArgs>
    predator_types?: boolean | predator_typesDefaultArgs<ExtArgs>
    sects?: boolean | characters$sectsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $charactersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "characters"
    objects: {
      character_advantages: Prisma.$character_advantagesPayload<ExtArgs>[]
      character_alchemy_powers: Prisma.$character_alchemy_powersPayload<ExtArgs>[]
      character_attributes: Prisma.$character_attributesPayload<ExtArgs>[]
      character_bloodpotencies: Prisma.$character_bloodpotenciesPayload<ExtArgs>[]
      character_discipline_powers: Prisma.$character_discipline_powersPayload<ExtArgs>[]
      character_disciplines: Prisma.$character_disciplinesPayload<ExtArgs>[]
      character_healths: Prisma.$character_healthsPayload<ExtArgs>[]
      character_humanity: Prisma.$character_humanityPayload<ExtArgs>[]
      character_profile: Prisma.$character_profilePayload<ExtArgs>[]
      character_rituals: Prisma.$character_ritualsPayload<ExtArgs>[]
      character_skills: Prisma.$character_skillsPayload<ExtArgs>[]
      character_specialties: Prisma.$character_specialtiesPayload<ExtArgs>[]
      character_willpowers: Prisma.$character_willpowersPayload<ExtArgs>[]
      chronicles: Prisma.$chroniclesPayload<ExtArgs> | null
      clan_banes: Prisma.$clan_banesPayload<ExtArgs> | null
      clan_compulsions: Prisma.$clan_compulsionsPayload<ExtArgs> | null
      clans: Prisma.$clansPayload<ExtArgs> | null
      char_groups: Prisma.$char_groupsPayload<ExtArgs>
      predator_types: Prisma.$predator_typesPayload<ExtArgs>
      sects: Prisma.$sectsPayload<ExtArgs> | null
      users: Prisma.$usersPayload<ExtArgs>
      exp_logs: Prisma.$exp_logsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      name: string
      clan_id: string | null
      clan_bane: string | null
      clan_compulsion: string | null
      sect_id: string | null
      player: string
      predator_type: string
      generation: number
      chronicle_id: string | null
      custom_chronicle: string | null
      ambition: string
      desire: string
      sire: string
      total_experience: number
      chronicle_tenets: string
      group_id: string
      type: $Enums.Entity
    }, ExtArgs["result"]["characters"]>
    composites: {}
  }

  type charactersGetPayload<S extends boolean | null | undefined | charactersDefaultArgs> = $Result.GetResult<Prisma.$charactersPayload, S>

  type charactersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<charactersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CharactersCountAggregateInputType | true
    }

  export interface charactersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['characters'], meta: { name: 'characters' } }
    /**
     * Find zero or one Characters that matches the filter.
     * @param {charactersFindUniqueArgs} args - Arguments to find a Characters
     * @example
     * // Get one Characters
     * const characters = await prisma.characters.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends charactersFindUniqueArgs>(args: SelectSubset<T, charactersFindUniqueArgs<ExtArgs>>): Prisma__charactersClient<$Result.GetResult<Prisma.$charactersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Characters that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {charactersFindUniqueOrThrowArgs} args - Arguments to find a Characters
     * @example
     * // Get one Characters
     * const characters = await prisma.characters.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends charactersFindUniqueOrThrowArgs>(args: SelectSubset<T, charactersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__charactersClient<$Result.GetResult<Prisma.$charactersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Characters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {charactersFindFirstArgs} args - Arguments to find a Characters
     * @example
     * // Get one Characters
     * const characters = await prisma.characters.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends charactersFindFirstArgs>(args?: SelectSubset<T, charactersFindFirstArgs<ExtArgs>>): Prisma__charactersClient<$Result.GetResult<Prisma.$charactersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Characters that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {charactersFindFirstOrThrowArgs} args - Arguments to find a Characters
     * @example
     * // Get one Characters
     * const characters = await prisma.characters.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends charactersFindFirstOrThrowArgs>(args?: SelectSubset<T, charactersFindFirstOrThrowArgs<ExtArgs>>): Prisma__charactersClient<$Result.GetResult<Prisma.$charactersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Characters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {charactersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Characters
     * const characters = await prisma.characters.findMany()
     * 
     * // Get first 10 Characters
     * const characters = await prisma.characters.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const charactersWithIdOnly = await prisma.characters.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends charactersFindManyArgs>(args?: SelectSubset<T, charactersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$charactersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Characters.
     * @param {charactersCreateArgs} args - Arguments to create a Characters.
     * @example
     * // Create one Characters
     * const Characters = await prisma.characters.create({
     *   data: {
     *     // ... data to create a Characters
     *   }
     * })
     * 
     */
    create<T extends charactersCreateArgs>(args: SelectSubset<T, charactersCreateArgs<ExtArgs>>): Prisma__charactersClient<$Result.GetResult<Prisma.$charactersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Characters.
     * @param {charactersCreateManyArgs} args - Arguments to create many Characters.
     * @example
     * // Create many Characters
     * const characters = await prisma.characters.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends charactersCreateManyArgs>(args?: SelectSubset<T, charactersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Characters and returns the data saved in the database.
     * @param {charactersCreateManyAndReturnArgs} args - Arguments to create many Characters.
     * @example
     * // Create many Characters
     * const characters = await prisma.characters.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Characters and only return the `id`
     * const charactersWithIdOnly = await prisma.characters.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends charactersCreateManyAndReturnArgs>(args?: SelectSubset<T, charactersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$charactersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Characters.
     * @param {charactersDeleteArgs} args - Arguments to delete one Characters.
     * @example
     * // Delete one Characters
     * const Characters = await prisma.characters.delete({
     *   where: {
     *     // ... filter to delete one Characters
     *   }
     * })
     * 
     */
    delete<T extends charactersDeleteArgs>(args: SelectSubset<T, charactersDeleteArgs<ExtArgs>>): Prisma__charactersClient<$Result.GetResult<Prisma.$charactersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Characters.
     * @param {charactersUpdateArgs} args - Arguments to update one Characters.
     * @example
     * // Update one Characters
     * const characters = await prisma.characters.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends charactersUpdateArgs>(args: SelectSubset<T, charactersUpdateArgs<ExtArgs>>): Prisma__charactersClient<$Result.GetResult<Prisma.$charactersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Characters.
     * @param {charactersDeleteManyArgs} args - Arguments to filter Characters to delete.
     * @example
     * // Delete a few Characters
     * const { count } = await prisma.characters.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends charactersDeleteManyArgs>(args?: SelectSubset<T, charactersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {charactersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Characters
     * const characters = await prisma.characters.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends charactersUpdateManyArgs>(args: SelectSubset<T, charactersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Characters and returns the data updated in the database.
     * @param {charactersUpdateManyAndReturnArgs} args - Arguments to update many Characters.
     * @example
     * // Update many Characters
     * const characters = await prisma.characters.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Characters and only return the `id`
     * const charactersWithIdOnly = await prisma.characters.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends charactersUpdateManyAndReturnArgs>(args: SelectSubset<T, charactersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$charactersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Characters.
     * @param {charactersUpsertArgs} args - Arguments to update or create a Characters.
     * @example
     * // Update or create a Characters
     * const characters = await prisma.characters.upsert({
     *   create: {
     *     // ... data to create a Characters
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Characters we want to update
     *   }
     * })
     */
    upsert<T extends charactersUpsertArgs>(args: SelectSubset<T, charactersUpsertArgs<ExtArgs>>): Prisma__charactersClient<$Result.GetResult<Prisma.$charactersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {charactersCountArgs} args - Arguments to filter Characters to count.
     * @example
     * // Count the number of Characters
     * const count = await prisma.characters.count({
     *   where: {
     *     // ... the filter for the Characters we want to count
     *   }
     * })
    **/
    count<T extends charactersCountArgs>(
      args?: Subset<T, charactersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharactersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharactersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharactersAggregateArgs>(args: Subset<T, CharactersAggregateArgs>): Prisma.PrismaPromise<GetCharactersAggregateType<T>>

    /**
     * Group by Characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {charactersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends charactersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: charactersGroupByArgs['orderBy'] }
        : { orderBy?: charactersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, charactersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharactersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the characters model
   */
  readonly fields: charactersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for characters.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__charactersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    character_advantages<T extends characters$character_advantagesArgs<ExtArgs> = {}>(args?: Subset<T, characters$character_advantagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_advantagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    character_alchemy_powers<T extends characters$character_alchemy_powersArgs<ExtArgs> = {}>(args?: Subset<T, characters$character_alchemy_powersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_alchemy_powersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    character_attributes<T extends characters$character_attributesArgs<ExtArgs> = {}>(args?: Subset<T, characters$character_attributesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_attributesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    character_bloodpotencies<T extends characters$character_bloodpotenciesArgs<ExtArgs> = {}>(args?: Subset<T, characters$character_bloodpotenciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_bloodpotenciesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    character_discipline_powers<T extends characters$character_discipline_powersArgs<ExtArgs> = {}>(args?: Subset<T, characters$character_discipline_powersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_discipline_powersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    character_disciplines<T extends characters$character_disciplinesArgs<ExtArgs> = {}>(args?: Subset<T, characters$character_disciplinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_disciplinesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    character_healths<T extends characters$character_healthsArgs<ExtArgs> = {}>(args?: Subset<T, characters$character_healthsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_healthsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    character_humanity<T extends characters$character_humanityArgs<ExtArgs> = {}>(args?: Subset<T, characters$character_humanityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_humanityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    character_profile<T extends characters$character_profileArgs<ExtArgs> = {}>(args?: Subset<T, characters$character_profileArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_profilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    character_rituals<T extends characters$character_ritualsArgs<ExtArgs> = {}>(args?: Subset<T, characters$character_ritualsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_ritualsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    character_skills<T extends characters$character_skillsArgs<ExtArgs> = {}>(args?: Subset<T, characters$character_skillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_skillsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    character_specialties<T extends characters$character_specialtiesArgs<ExtArgs> = {}>(args?: Subset<T, characters$character_specialtiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_specialtiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    character_willpowers<T extends characters$character_willpowersArgs<ExtArgs> = {}>(args?: Subset<T, characters$character_willpowersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_willpowersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chronicles<T extends characters$chroniclesArgs<ExtArgs> = {}>(args?: Subset<T, characters$chroniclesArgs<ExtArgs>>): Prisma__chroniclesClient<$Result.GetResult<Prisma.$chroniclesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    clan_banes<T extends characters$clan_banesArgs<ExtArgs> = {}>(args?: Subset<T, characters$clan_banesArgs<ExtArgs>>): Prisma__clan_banesClient<$Result.GetResult<Prisma.$clan_banesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    clan_compulsions<T extends characters$clan_compulsionsArgs<ExtArgs> = {}>(args?: Subset<T, characters$clan_compulsionsArgs<ExtArgs>>): Prisma__clan_compulsionsClient<$Result.GetResult<Prisma.$clan_compulsionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    clans<T extends characters$clansArgs<ExtArgs> = {}>(args?: Subset<T, characters$clansArgs<ExtArgs>>): Prisma__clansClient<$Result.GetResult<Prisma.$clansPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    char_groups<T extends char_groupsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, char_groupsDefaultArgs<ExtArgs>>): Prisma__char_groupsClient<$Result.GetResult<Prisma.$char_groupsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    predator_types<T extends predator_typesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, predator_typesDefaultArgs<ExtArgs>>): Prisma__predator_typesClient<$Result.GetResult<Prisma.$predator_typesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sects<T extends characters$sectsArgs<ExtArgs> = {}>(args?: Subset<T, characters$sectsArgs<ExtArgs>>): Prisma__sectsClient<$Result.GetResult<Prisma.$sectsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    exp_logs<T extends characters$exp_logsArgs<ExtArgs> = {}>(args?: Subset<T, characters$exp_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$exp_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the characters model
   */
  interface charactersFieldRefs {
    readonly id: FieldRef<"characters", 'String'>
    readonly user_id: FieldRef<"characters", 'String'>
    readonly name: FieldRef<"characters", 'String'>
    readonly clan_id: FieldRef<"characters", 'String'>
    readonly clan_bane: FieldRef<"characters", 'String'>
    readonly clan_compulsion: FieldRef<"characters", 'String'>
    readonly sect_id: FieldRef<"characters", 'String'>
    readonly player: FieldRef<"characters", 'String'>
    readonly predator_type: FieldRef<"characters", 'String'>
    readonly generation: FieldRef<"characters", 'Int'>
    readonly chronicle_id: FieldRef<"characters", 'String'>
    readonly custom_chronicle: FieldRef<"characters", 'String'>
    readonly ambition: FieldRef<"characters", 'String'>
    readonly desire: FieldRef<"characters", 'String'>
    readonly sire: FieldRef<"characters", 'String'>
    readonly total_experience: FieldRef<"characters", 'Int'>
    readonly chronicle_tenets: FieldRef<"characters", 'String'>
    readonly group_id: FieldRef<"characters", 'String'>
    readonly type: FieldRef<"characters", 'Entity'>
  }
    

  // Custom InputTypes
  /**
   * characters findUnique
   */
  export type charactersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characters
     */
    select?: charactersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the characters
     */
    omit?: charactersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: charactersInclude<ExtArgs> | null
    /**
     * Filter, which characters to fetch.
     */
    where: charactersWhereUniqueInput
  }

  /**
   * characters findUniqueOrThrow
   */
  export type charactersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characters
     */
    select?: charactersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the characters
     */
    omit?: charactersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: charactersInclude<ExtArgs> | null
    /**
     * Filter, which characters to fetch.
     */
    where: charactersWhereUniqueInput
  }

  /**
   * characters findFirst
   */
  export type charactersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characters
     */
    select?: charactersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the characters
     */
    omit?: charactersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: charactersInclude<ExtArgs> | null
    /**
     * Filter, which characters to fetch.
     */
    where?: charactersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of characters to fetch.
     */
    orderBy?: charactersOrderByWithRelationInput | charactersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for characters.
     */
    cursor?: charactersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of characters.
     */
    distinct?: CharactersScalarFieldEnum | CharactersScalarFieldEnum[]
  }

  /**
   * characters findFirstOrThrow
   */
  export type charactersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characters
     */
    select?: charactersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the characters
     */
    omit?: charactersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: charactersInclude<ExtArgs> | null
    /**
     * Filter, which characters to fetch.
     */
    where?: charactersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of characters to fetch.
     */
    orderBy?: charactersOrderByWithRelationInput | charactersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for characters.
     */
    cursor?: charactersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of characters.
     */
    distinct?: CharactersScalarFieldEnum | CharactersScalarFieldEnum[]
  }

  /**
   * characters findMany
   */
  export type charactersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characters
     */
    select?: charactersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the characters
     */
    omit?: charactersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: charactersInclude<ExtArgs> | null
    /**
     * Filter, which characters to fetch.
     */
    where?: charactersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of characters to fetch.
     */
    orderBy?: charactersOrderByWithRelationInput | charactersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing characters.
     */
    cursor?: charactersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` characters.
     */
    skip?: number
    distinct?: CharactersScalarFieldEnum | CharactersScalarFieldEnum[]
  }

  /**
   * characters create
   */
  export type charactersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characters
     */
    select?: charactersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the characters
     */
    omit?: charactersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: charactersInclude<ExtArgs> | null
    /**
     * The data needed to create a characters.
     */
    data: XOR<charactersCreateInput, charactersUncheckedCreateInput>
  }

  /**
   * characters createMany
   */
  export type charactersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many characters.
     */
    data: charactersCreateManyInput | charactersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * characters createManyAndReturn
   */
  export type charactersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characters
     */
    select?: charactersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the characters
     */
    omit?: charactersOmit<ExtArgs> | null
    /**
     * The data used to create many characters.
     */
    data: charactersCreateManyInput | charactersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: charactersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * characters update
   */
  export type charactersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characters
     */
    select?: charactersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the characters
     */
    omit?: charactersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: charactersInclude<ExtArgs> | null
    /**
     * The data needed to update a characters.
     */
    data: XOR<charactersUpdateInput, charactersUncheckedUpdateInput>
    /**
     * Choose, which characters to update.
     */
    where: charactersWhereUniqueInput
  }

  /**
   * characters updateMany
   */
  export type charactersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update characters.
     */
    data: XOR<charactersUpdateManyMutationInput, charactersUncheckedUpdateManyInput>
    /**
     * Filter which characters to update
     */
    where?: charactersWhereInput
    /**
     * Limit how many characters to update.
     */
    limit?: number
  }

  /**
   * characters updateManyAndReturn
   */
  export type charactersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characters
     */
    select?: charactersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the characters
     */
    omit?: charactersOmit<ExtArgs> | null
    /**
     * The data used to update characters.
     */
    data: XOR<charactersUpdateManyMutationInput, charactersUncheckedUpdateManyInput>
    /**
     * Filter which characters to update
     */
    where?: charactersWhereInput
    /**
     * Limit how many characters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: charactersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * characters upsert
   */
  export type charactersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characters
     */
    select?: charactersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the characters
     */
    omit?: charactersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: charactersInclude<ExtArgs> | null
    /**
     * The filter to search for the characters to update in case it exists.
     */
    where: charactersWhereUniqueInput
    /**
     * In case the characters found by the `where` argument doesn't exist, create a new characters with this data.
     */
    create: XOR<charactersCreateInput, charactersUncheckedCreateInput>
    /**
     * In case the characters was found with the provided `where` argument, update it with this data.
     */
    update: XOR<charactersUpdateInput, charactersUncheckedUpdateInput>
  }

  /**
   * characters delete
   */
  export type charactersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characters
     */
    select?: charactersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the characters
     */
    omit?: charactersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: charactersInclude<ExtArgs> | null
    /**
     * Filter which characters to delete.
     */
    where: charactersWhereUniqueInput
  }

  /**
   * characters deleteMany
   */
  export type charactersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which characters to delete
     */
    where?: charactersWhereInput
    /**
     * Limit how many characters to delete.
     */
    limit?: number
  }

  /**
   * characters.character_advantages
   */
  export type characters$character_advantagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_advantages
     */
    select?: character_advantagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_advantages
     */
    omit?: character_advantagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_advantagesInclude<ExtArgs> | null
    where?: character_advantagesWhereInput
    orderBy?: character_advantagesOrderByWithRelationInput | character_advantagesOrderByWithRelationInput[]
    cursor?: character_advantagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Character_advantagesScalarFieldEnum | Character_advantagesScalarFieldEnum[]
  }

  /**
   * characters.character_alchemy_powers
   */
  export type characters$character_alchemy_powersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_alchemy_powers
     */
    select?: character_alchemy_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_alchemy_powers
     */
    omit?: character_alchemy_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_alchemy_powersInclude<ExtArgs> | null
    where?: character_alchemy_powersWhereInput
    orderBy?: character_alchemy_powersOrderByWithRelationInput | character_alchemy_powersOrderByWithRelationInput[]
    cursor?: character_alchemy_powersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Character_alchemy_powersScalarFieldEnum | Character_alchemy_powersScalarFieldEnum[]
  }

  /**
   * characters.character_attributes
   */
  export type characters$character_attributesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_attributes
     */
    select?: character_attributesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_attributes
     */
    omit?: character_attributesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_attributesInclude<ExtArgs> | null
    where?: character_attributesWhereInput
    orderBy?: character_attributesOrderByWithRelationInput | character_attributesOrderByWithRelationInput[]
    cursor?: character_attributesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Character_attributesScalarFieldEnum | Character_attributesScalarFieldEnum[]
  }

  /**
   * characters.character_bloodpotencies
   */
  export type characters$character_bloodpotenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_bloodpotencies
     */
    select?: character_bloodpotenciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_bloodpotencies
     */
    omit?: character_bloodpotenciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_bloodpotenciesInclude<ExtArgs> | null
    where?: character_bloodpotenciesWhereInput
    orderBy?: character_bloodpotenciesOrderByWithRelationInput | character_bloodpotenciesOrderByWithRelationInput[]
    cursor?: character_bloodpotenciesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Character_bloodpotenciesScalarFieldEnum | Character_bloodpotenciesScalarFieldEnum[]
  }

  /**
   * characters.character_discipline_powers
   */
  export type characters$character_discipline_powersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_discipline_powers
     */
    select?: character_discipline_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_discipline_powers
     */
    omit?: character_discipline_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_discipline_powersInclude<ExtArgs> | null
    where?: character_discipline_powersWhereInput
    orderBy?: character_discipline_powersOrderByWithRelationInput | character_discipline_powersOrderByWithRelationInput[]
    cursor?: character_discipline_powersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Character_discipline_powersScalarFieldEnum | Character_discipline_powersScalarFieldEnum[]
  }

  /**
   * characters.character_disciplines
   */
  export type characters$character_disciplinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_disciplines
     */
    select?: character_disciplinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_disciplines
     */
    omit?: character_disciplinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_disciplinesInclude<ExtArgs> | null
    where?: character_disciplinesWhereInput
    orderBy?: character_disciplinesOrderByWithRelationInput | character_disciplinesOrderByWithRelationInput[]
    cursor?: character_disciplinesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Character_disciplinesScalarFieldEnum | Character_disciplinesScalarFieldEnum[]
  }

  /**
   * characters.character_healths
   */
  export type characters$character_healthsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_healths
     */
    select?: character_healthsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_healths
     */
    omit?: character_healthsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_healthsInclude<ExtArgs> | null
    where?: character_healthsWhereInput
    orderBy?: character_healthsOrderByWithRelationInput | character_healthsOrderByWithRelationInput[]
    cursor?: character_healthsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Character_healthsScalarFieldEnum | Character_healthsScalarFieldEnum[]
  }

  /**
   * characters.character_humanity
   */
  export type characters$character_humanityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_humanity
     */
    select?: character_humanitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_humanity
     */
    omit?: character_humanityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_humanityInclude<ExtArgs> | null
    where?: character_humanityWhereInput
    orderBy?: character_humanityOrderByWithRelationInput | character_humanityOrderByWithRelationInput[]
    cursor?: character_humanityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Character_humanityScalarFieldEnum | Character_humanityScalarFieldEnum[]
  }

  /**
   * characters.character_profile
   */
  export type characters$character_profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_profile
     */
    select?: character_profileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_profile
     */
    omit?: character_profileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_profileInclude<ExtArgs> | null
    where?: character_profileWhereInput
    orderBy?: character_profileOrderByWithRelationInput | character_profileOrderByWithRelationInput[]
    cursor?: character_profileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Character_profileScalarFieldEnum | Character_profileScalarFieldEnum[]
  }

  /**
   * characters.character_rituals
   */
  export type characters$character_ritualsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_rituals
     */
    select?: character_ritualsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_rituals
     */
    omit?: character_ritualsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_ritualsInclude<ExtArgs> | null
    where?: character_ritualsWhereInput
    orderBy?: character_ritualsOrderByWithRelationInput | character_ritualsOrderByWithRelationInput[]
    cursor?: character_ritualsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Character_ritualsScalarFieldEnum | Character_ritualsScalarFieldEnum[]
  }

  /**
   * characters.character_skills
   */
  export type characters$character_skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_skills
     */
    select?: character_skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_skills
     */
    omit?: character_skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_skillsInclude<ExtArgs> | null
    where?: character_skillsWhereInput
    orderBy?: character_skillsOrderByWithRelationInput | character_skillsOrderByWithRelationInput[]
    cursor?: character_skillsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Character_skillsScalarFieldEnum | Character_skillsScalarFieldEnum[]
  }

  /**
   * characters.character_specialties
   */
  export type characters$character_specialtiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_specialties
     */
    select?: character_specialtiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_specialties
     */
    omit?: character_specialtiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_specialtiesInclude<ExtArgs> | null
    where?: character_specialtiesWhereInput
    orderBy?: character_specialtiesOrderByWithRelationInput | character_specialtiesOrderByWithRelationInput[]
    cursor?: character_specialtiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Character_specialtiesScalarFieldEnum | Character_specialtiesScalarFieldEnum[]
  }

  /**
   * characters.character_willpowers
   */
  export type characters$character_willpowersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_willpowers
     */
    select?: character_willpowersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_willpowers
     */
    omit?: character_willpowersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_willpowersInclude<ExtArgs> | null
    where?: character_willpowersWhereInput
    orderBy?: character_willpowersOrderByWithRelationInput | character_willpowersOrderByWithRelationInput[]
    cursor?: character_willpowersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Character_willpowersScalarFieldEnum | Character_willpowersScalarFieldEnum[]
  }

  /**
   * characters.chronicles
   */
  export type characters$chroniclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chronicles
     */
    select?: chroniclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chronicles
     */
    omit?: chroniclesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chroniclesInclude<ExtArgs> | null
    where?: chroniclesWhereInput
  }

  /**
   * characters.clan_banes
   */
  export type characters$clan_banesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clan_banes
     */
    select?: clan_banesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clan_banes
     */
    omit?: clan_banesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clan_banesInclude<ExtArgs> | null
    where?: clan_banesWhereInput
  }

  /**
   * characters.clan_compulsions
   */
  export type characters$clan_compulsionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clan_compulsions
     */
    select?: clan_compulsionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clan_compulsions
     */
    omit?: clan_compulsionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clan_compulsionsInclude<ExtArgs> | null
    where?: clan_compulsionsWhereInput
  }

  /**
   * characters.clans
   */
  export type characters$clansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clans
     */
    select?: clansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clans
     */
    omit?: clansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clansInclude<ExtArgs> | null
    where?: clansWhereInput
  }

  /**
   * characters.sects
   */
  export type characters$sectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sects
     */
    select?: sectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sects
     */
    omit?: sectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectsInclude<ExtArgs> | null
    where?: sectsWhereInput
  }

  /**
   * characters.exp_logs
   */
  export type characters$exp_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exp_logs
     */
    select?: exp_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exp_logs
     */
    omit?: exp_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exp_logsInclude<ExtArgs> | null
    where?: exp_logsWhereInput
    orderBy?: exp_logsOrderByWithRelationInput | exp_logsOrderByWithRelationInput[]
    cursor?: exp_logsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Exp_logsScalarFieldEnum | Exp_logsScalarFieldEnum[]
  }

  /**
   * characters without action
   */
  export type charactersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characters
     */
    select?: charactersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the characters
     */
    omit?: charactersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: charactersInclude<ExtArgs> | null
  }


  /**
   * Model chronicles
   */

  export type AggregateChronicles = {
    _count: ChroniclesCountAggregateOutputType | null
    _min: ChroniclesMinAggregateOutputType | null
    _max: ChroniclesMaxAggregateOutputType | null
  }

  export type ChroniclesMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    name: string | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ChroniclesMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    name: string | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ChroniclesCountAggregateOutputType = {
    id: number
    user_id: number
    name: number
    description: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ChroniclesMinAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type ChroniclesMaxAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type ChroniclesCountAggregateInputType = {
    id?: true
    user_id?: true
    name?: true
    description?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ChroniclesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chronicles to aggregate.
     */
    where?: chroniclesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chronicles to fetch.
     */
    orderBy?: chroniclesOrderByWithRelationInput | chroniclesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chroniclesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chronicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chronicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chronicles
    **/
    _count?: true | ChroniclesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChroniclesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChroniclesMaxAggregateInputType
  }

  export type GetChroniclesAggregateType<T extends ChroniclesAggregateArgs> = {
        [P in keyof T & keyof AggregateChronicles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChronicles[P]>
      : GetScalarType<T[P], AggregateChronicles[P]>
  }




  export type chroniclesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chroniclesWhereInput
    orderBy?: chroniclesOrderByWithAggregationInput | chroniclesOrderByWithAggregationInput[]
    by: ChroniclesScalarFieldEnum[] | ChroniclesScalarFieldEnum
    having?: chroniclesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChroniclesCountAggregateInputType | true
    _min?: ChroniclesMinAggregateInputType
    _max?: ChroniclesMaxAggregateInputType
  }

  export type ChroniclesGroupByOutputType = {
    id: string
    user_id: string
    name: string
    description: string
    created_at: Date
    updated_at: Date
    _count: ChroniclesCountAggregateOutputType | null
    _min: ChroniclesMinAggregateOutputType | null
    _max: ChroniclesMaxAggregateOutputType | null
  }

  type GetChroniclesGroupByPayload<T extends chroniclesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChroniclesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChroniclesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChroniclesGroupByOutputType[P]>
            : GetScalarType<T[P], ChroniclesGroupByOutputType[P]>
        }
      >
    >


  export type chroniclesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    name?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
    characters?: boolean | chronicles$charactersArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | ChroniclesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chronicles"]>

  export type chroniclesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    name?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chronicles"]>

  export type chroniclesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    name?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chronicles"]>

  export type chroniclesSelectScalar = {
    id?: boolean
    user_id?: boolean
    name?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type chroniclesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "name" | "description" | "created_at" | "updated_at", ExtArgs["result"]["chronicles"]>
  export type chroniclesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | chronicles$charactersArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | ChroniclesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type chroniclesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type chroniclesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $chroniclesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "chronicles"
    objects: {
      characters: Prisma.$charactersPayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      name: string
      description: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["chronicles"]>
    composites: {}
  }

  type chroniclesGetPayload<S extends boolean | null | undefined | chroniclesDefaultArgs> = $Result.GetResult<Prisma.$chroniclesPayload, S>

  type chroniclesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<chroniclesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChroniclesCountAggregateInputType | true
    }

  export interface chroniclesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chronicles'], meta: { name: 'chronicles' } }
    /**
     * Find zero or one Chronicles that matches the filter.
     * @param {chroniclesFindUniqueArgs} args - Arguments to find a Chronicles
     * @example
     * // Get one Chronicles
     * const chronicles = await prisma.chronicles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends chroniclesFindUniqueArgs>(args: SelectSubset<T, chroniclesFindUniqueArgs<ExtArgs>>): Prisma__chroniclesClient<$Result.GetResult<Prisma.$chroniclesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chronicles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {chroniclesFindUniqueOrThrowArgs} args - Arguments to find a Chronicles
     * @example
     * // Get one Chronicles
     * const chronicles = await prisma.chronicles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends chroniclesFindUniqueOrThrowArgs>(args: SelectSubset<T, chroniclesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__chroniclesClient<$Result.GetResult<Prisma.$chroniclesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chronicles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chroniclesFindFirstArgs} args - Arguments to find a Chronicles
     * @example
     * // Get one Chronicles
     * const chronicles = await prisma.chronicles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends chroniclesFindFirstArgs>(args?: SelectSubset<T, chroniclesFindFirstArgs<ExtArgs>>): Prisma__chroniclesClient<$Result.GetResult<Prisma.$chroniclesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chronicles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chroniclesFindFirstOrThrowArgs} args - Arguments to find a Chronicles
     * @example
     * // Get one Chronicles
     * const chronicles = await prisma.chronicles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends chroniclesFindFirstOrThrowArgs>(args?: SelectSubset<T, chroniclesFindFirstOrThrowArgs<ExtArgs>>): Prisma__chroniclesClient<$Result.GetResult<Prisma.$chroniclesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chronicles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chroniclesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chronicles
     * const chronicles = await prisma.chronicles.findMany()
     * 
     * // Get first 10 Chronicles
     * const chronicles = await prisma.chronicles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chroniclesWithIdOnly = await prisma.chronicles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends chroniclesFindManyArgs>(args?: SelectSubset<T, chroniclesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chroniclesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chronicles.
     * @param {chroniclesCreateArgs} args - Arguments to create a Chronicles.
     * @example
     * // Create one Chronicles
     * const Chronicles = await prisma.chronicles.create({
     *   data: {
     *     // ... data to create a Chronicles
     *   }
     * })
     * 
     */
    create<T extends chroniclesCreateArgs>(args: SelectSubset<T, chroniclesCreateArgs<ExtArgs>>): Prisma__chroniclesClient<$Result.GetResult<Prisma.$chroniclesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chronicles.
     * @param {chroniclesCreateManyArgs} args - Arguments to create many Chronicles.
     * @example
     * // Create many Chronicles
     * const chronicles = await prisma.chronicles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends chroniclesCreateManyArgs>(args?: SelectSubset<T, chroniclesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chronicles and returns the data saved in the database.
     * @param {chroniclesCreateManyAndReturnArgs} args - Arguments to create many Chronicles.
     * @example
     * // Create many Chronicles
     * const chronicles = await prisma.chronicles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chronicles and only return the `id`
     * const chroniclesWithIdOnly = await prisma.chronicles.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends chroniclesCreateManyAndReturnArgs>(args?: SelectSubset<T, chroniclesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chroniclesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Chronicles.
     * @param {chroniclesDeleteArgs} args - Arguments to delete one Chronicles.
     * @example
     * // Delete one Chronicles
     * const Chronicles = await prisma.chronicles.delete({
     *   where: {
     *     // ... filter to delete one Chronicles
     *   }
     * })
     * 
     */
    delete<T extends chroniclesDeleteArgs>(args: SelectSubset<T, chroniclesDeleteArgs<ExtArgs>>): Prisma__chroniclesClient<$Result.GetResult<Prisma.$chroniclesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chronicles.
     * @param {chroniclesUpdateArgs} args - Arguments to update one Chronicles.
     * @example
     * // Update one Chronicles
     * const chronicles = await prisma.chronicles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends chroniclesUpdateArgs>(args: SelectSubset<T, chroniclesUpdateArgs<ExtArgs>>): Prisma__chroniclesClient<$Result.GetResult<Prisma.$chroniclesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chronicles.
     * @param {chroniclesDeleteManyArgs} args - Arguments to filter Chronicles to delete.
     * @example
     * // Delete a few Chronicles
     * const { count } = await prisma.chronicles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends chroniclesDeleteManyArgs>(args?: SelectSubset<T, chroniclesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chronicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chroniclesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chronicles
     * const chronicles = await prisma.chronicles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends chroniclesUpdateManyArgs>(args: SelectSubset<T, chroniclesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chronicles and returns the data updated in the database.
     * @param {chroniclesUpdateManyAndReturnArgs} args - Arguments to update many Chronicles.
     * @example
     * // Update many Chronicles
     * const chronicles = await prisma.chronicles.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Chronicles and only return the `id`
     * const chroniclesWithIdOnly = await prisma.chronicles.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends chroniclesUpdateManyAndReturnArgs>(args: SelectSubset<T, chroniclesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chroniclesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Chronicles.
     * @param {chroniclesUpsertArgs} args - Arguments to update or create a Chronicles.
     * @example
     * // Update or create a Chronicles
     * const chronicles = await prisma.chronicles.upsert({
     *   create: {
     *     // ... data to create a Chronicles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chronicles we want to update
     *   }
     * })
     */
    upsert<T extends chroniclesUpsertArgs>(args: SelectSubset<T, chroniclesUpsertArgs<ExtArgs>>): Prisma__chroniclesClient<$Result.GetResult<Prisma.$chroniclesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Chronicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chroniclesCountArgs} args - Arguments to filter Chronicles to count.
     * @example
     * // Count the number of Chronicles
     * const count = await prisma.chronicles.count({
     *   where: {
     *     // ... the filter for the Chronicles we want to count
     *   }
     * })
    **/
    count<T extends chroniclesCountArgs>(
      args?: Subset<T, chroniclesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChroniclesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chronicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChroniclesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChroniclesAggregateArgs>(args: Subset<T, ChroniclesAggregateArgs>): Prisma.PrismaPromise<GetChroniclesAggregateType<T>>

    /**
     * Group by Chronicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chroniclesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chroniclesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chroniclesGroupByArgs['orderBy'] }
        : { orderBy?: chroniclesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chroniclesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChroniclesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chronicles model
   */
  readonly fields: chroniclesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chronicles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__chroniclesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    characters<T extends chronicles$charactersArgs<ExtArgs> = {}>(args?: Subset<T, chronicles$charactersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$charactersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the chronicles model
   */
  interface chroniclesFieldRefs {
    readonly id: FieldRef<"chronicles", 'String'>
    readonly user_id: FieldRef<"chronicles", 'String'>
    readonly name: FieldRef<"chronicles", 'String'>
    readonly description: FieldRef<"chronicles", 'String'>
    readonly created_at: FieldRef<"chronicles", 'DateTime'>
    readonly updated_at: FieldRef<"chronicles", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * chronicles findUnique
   */
  export type chroniclesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chronicles
     */
    select?: chroniclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chronicles
     */
    omit?: chroniclesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chroniclesInclude<ExtArgs> | null
    /**
     * Filter, which chronicles to fetch.
     */
    where: chroniclesWhereUniqueInput
  }

  /**
   * chronicles findUniqueOrThrow
   */
  export type chroniclesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chronicles
     */
    select?: chroniclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chronicles
     */
    omit?: chroniclesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chroniclesInclude<ExtArgs> | null
    /**
     * Filter, which chronicles to fetch.
     */
    where: chroniclesWhereUniqueInput
  }

  /**
   * chronicles findFirst
   */
  export type chroniclesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chronicles
     */
    select?: chroniclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chronicles
     */
    omit?: chroniclesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chroniclesInclude<ExtArgs> | null
    /**
     * Filter, which chronicles to fetch.
     */
    where?: chroniclesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chronicles to fetch.
     */
    orderBy?: chroniclesOrderByWithRelationInput | chroniclesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chronicles.
     */
    cursor?: chroniclesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chronicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chronicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chronicles.
     */
    distinct?: ChroniclesScalarFieldEnum | ChroniclesScalarFieldEnum[]
  }

  /**
   * chronicles findFirstOrThrow
   */
  export type chroniclesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chronicles
     */
    select?: chroniclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chronicles
     */
    omit?: chroniclesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chroniclesInclude<ExtArgs> | null
    /**
     * Filter, which chronicles to fetch.
     */
    where?: chroniclesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chronicles to fetch.
     */
    orderBy?: chroniclesOrderByWithRelationInput | chroniclesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chronicles.
     */
    cursor?: chroniclesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chronicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chronicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chronicles.
     */
    distinct?: ChroniclesScalarFieldEnum | ChroniclesScalarFieldEnum[]
  }

  /**
   * chronicles findMany
   */
  export type chroniclesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chronicles
     */
    select?: chroniclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chronicles
     */
    omit?: chroniclesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chroniclesInclude<ExtArgs> | null
    /**
     * Filter, which chronicles to fetch.
     */
    where?: chroniclesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chronicles to fetch.
     */
    orderBy?: chroniclesOrderByWithRelationInput | chroniclesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chronicles.
     */
    cursor?: chroniclesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chronicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chronicles.
     */
    skip?: number
    distinct?: ChroniclesScalarFieldEnum | ChroniclesScalarFieldEnum[]
  }

  /**
   * chronicles create
   */
  export type chroniclesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chronicles
     */
    select?: chroniclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chronicles
     */
    omit?: chroniclesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chroniclesInclude<ExtArgs> | null
    /**
     * The data needed to create a chronicles.
     */
    data: XOR<chroniclesCreateInput, chroniclesUncheckedCreateInput>
  }

  /**
   * chronicles createMany
   */
  export type chroniclesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chronicles.
     */
    data: chroniclesCreateManyInput | chroniclesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * chronicles createManyAndReturn
   */
  export type chroniclesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chronicles
     */
    select?: chroniclesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chronicles
     */
    omit?: chroniclesOmit<ExtArgs> | null
    /**
     * The data used to create many chronicles.
     */
    data: chroniclesCreateManyInput | chroniclesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chroniclesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * chronicles update
   */
  export type chroniclesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chronicles
     */
    select?: chroniclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chronicles
     */
    omit?: chroniclesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chroniclesInclude<ExtArgs> | null
    /**
     * The data needed to update a chronicles.
     */
    data: XOR<chroniclesUpdateInput, chroniclesUncheckedUpdateInput>
    /**
     * Choose, which chronicles to update.
     */
    where: chroniclesWhereUniqueInput
  }

  /**
   * chronicles updateMany
   */
  export type chroniclesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chronicles.
     */
    data: XOR<chroniclesUpdateManyMutationInput, chroniclesUncheckedUpdateManyInput>
    /**
     * Filter which chronicles to update
     */
    where?: chroniclesWhereInput
    /**
     * Limit how many chronicles to update.
     */
    limit?: number
  }

  /**
   * chronicles updateManyAndReturn
   */
  export type chroniclesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chronicles
     */
    select?: chroniclesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chronicles
     */
    omit?: chroniclesOmit<ExtArgs> | null
    /**
     * The data used to update chronicles.
     */
    data: XOR<chroniclesUpdateManyMutationInput, chroniclesUncheckedUpdateManyInput>
    /**
     * Filter which chronicles to update
     */
    where?: chroniclesWhereInput
    /**
     * Limit how many chronicles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chroniclesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * chronicles upsert
   */
  export type chroniclesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chronicles
     */
    select?: chroniclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chronicles
     */
    omit?: chroniclesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chroniclesInclude<ExtArgs> | null
    /**
     * The filter to search for the chronicles to update in case it exists.
     */
    where: chroniclesWhereUniqueInput
    /**
     * In case the chronicles found by the `where` argument doesn't exist, create a new chronicles with this data.
     */
    create: XOR<chroniclesCreateInput, chroniclesUncheckedCreateInput>
    /**
     * In case the chronicles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chroniclesUpdateInput, chroniclesUncheckedUpdateInput>
  }

  /**
   * chronicles delete
   */
  export type chroniclesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chronicles
     */
    select?: chroniclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chronicles
     */
    omit?: chroniclesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chroniclesInclude<ExtArgs> | null
    /**
     * Filter which chronicles to delete.
     */
    where: chroniclesWhereUniqueInput
  }

  /**
   * chronicles deleteMany
   */
  export type chroniclesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chronicles to delete
     */
    where?: chroniclesWhereInput
    /**
     * Limit how many chronicles to delete.
     */
    limit?: number
  }

  /**
   * chronicles.characters
   */
  export type chronicles$charactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characters
     */
    select?: charactersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the characters
     */
    omit?: charactersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: charactersInclude<ExtArgs> | null
    where?: charactersWhereInput
    orderBy?: charactersOrderByWithRelationInput | charactersOrderByWithRelationInput[]
    cursor?: charactersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharactersScalarFieldEnum | CharactersScalarFieldEnum[]
  }

  /**
   * chronicles without action
   */
  export type chroniclesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chronicles
     */
    select?: chroniclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chronicles
     */
    omit?: chroniclesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chroniclesInclude<ExtArgs> | null
  }


  /**
   * Model clan_banes
   */

  export type AggregateClan_banes = {
    _count: Clan_banesCountAggregateOutputType | null
    _min: Clan_banesMinAggregateOutputType | null
    _max: Clan_banesMaxAggregateOutputType | null
  }

  export type Clan_banesMinAggregateOutputType = {
    id: string | null
    name: string | null
    clan_id: string | null
    description: string | null
  }

  export type Clan_banesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    clan_id: string | null
    description: string | null
  }

  export type Clan_banesCountAggregateOutputType = {
    id: number
    name: number
    clan_id: number
    description: number
    _all: number
  }


  export type Clan_banesMinAggregateInputType = {
    id?: true
    name?: true
    clan_id?: true
    description?: true
  }

  export type Clan_banesMaxAggregateInputType = {
    id?: true
    name?: true
    clan_id?: true
    description?: true
  }

  export type Clan_banesCountAggregateInputType = {
    id?: true
    name?: true
    clan_id?: true
    description?: true
    _all?: true
  }

  export type Clan_banesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clan_banes to aggregate.
     */
    where?: clan_banesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clan_banes to fetch.
     */
    orderBy?: clan_banesOrderByWithRelationInput | clan_banesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: clan_banesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clan_banes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clan_banes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned clan_banes
    **/
    _count?: true | Clan_banesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Clan_banesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Clan_banesMaxAggregateInputType
  }

  export type GetClan_banesAggregateType<T extends Clan_banesAggregateArgs> = {
        [P in keyof T & keyof AggregateClan_banes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClan_banes[P]>
      : GetScalarType<T[P], AggregateClan_banes[P]>
  }




  export type clan_banesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clan_banesWhereInput
    orderBy?: clan_banesOrderByWithAggregationInput | clan_banesOrderByWithAggregationInput[]
    by: Clan_banesScalarFieldEnum[] | Clan_banesScalarFieldEnum
    having?: clan_banesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Clan_banesCountAggregateInputType | true
    _min?: Clan_banesMinAggregateInputType
    _max?: Clan_banesMaxAggregateInputType
  }

  export type Clan_banesGroupByOutputType = {
    id: string
    name: string
    clan_id: string
    description: string
    _count: Clan_banesCountAggregateOutputType | null
    _min: Clan_banesMinAggregateOutputType | null
    _max: Clan_banesMaxAggregateOutputType | null
  }

  type GetClan_banesGroupByPayload<T extends clan_banesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Clan_banesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Clan_banesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Clan_banesGroupByOutputType[P]>
            : GetScalarType<T[P], Clan_banesGroupByOutputType[P]>
        }
      >
    >


  export type clan_banesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    clan_id?: boolean
    description?: boolean
    character_bloodpotencies?: boolean | clan_banes$character_bloodpotenciesArgs<ExtArgs>
    characters?: boolean | clan_banes$charactersArgs<ExtArgs>
    clans?: boolean | clansDefaultArgs<ExtArgs>
    _count?: boolean | Clan_banesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clan_banes"]>

  export type clan_banesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    clan_id?: boolean
    description?: boolean
    clans?: boolean | clansDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clan_banes"]>

  export type clan_banesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    clan_id?: boolean
    description?: boolean
    clans?: boolean | clansDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clan_banes"]>

  export type clan_banesSelectScalar = {
    id?: boolean
    name?: boolean
    clan_id?: boolean
    description?: boolean
  }

  export type clan_banesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "clan_id" | "description", ExtArgs["result"]["clan_banes"]>
  export type clan_banesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character_bloodpotencies?: boolean | clan_banes$character_bloodpotenciesArgs<ExtArgs>
    characters?: boolean | clan_banes$charactersArgs<ExtArgs>
    clans?: boolean | clansDefaultArgs<ExtArgs>
    _count?: boolean | Clan_banesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type clan_banesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clans?: boolean | clansDefaultArgs<ExtArgs>
  }
  export type clan_banesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clans?: boolean | clansDefaultArgs<ExtArgs>
  }

  export type $clan_banesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "clan_banes"
    objects: {
      character_bloodpotencies: Prisma.$character_bloodpotenciesPayload<ExtArgs>[]
      characters: Prisma.$charactersPayload<ExtArgs>[]
      clans: Prisma.$clansPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      clan_id: string
      description: string
    }, ExtArgs["result"]["clan_banes"]>
    composites: {}
  }

  type clan_banesGetPayload<S extends boolean | null | undefined | clan_banesDefaultArgs> = $Result.GetResult<Prisma.$clan_banesPayload, S>

  type clan_banesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<clan_banesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Clan_banesCountAggregateInputType | true
    }

  export interface clan_banesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['clan_banes'], meta: { name: 'clan_banes' } }
    /**
     * Find zero or one Clan_banes that matches the filter.
     * @param {clan_banesFindUniqueArgs} args - Arguments to find a Clan_banes
     * @example
     * // Get one Clan_banes
     * const clan_banes = await prisma.clan_banes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends clan_banesFindUniqueArgs>(args: SelectSubset<T, clan_banesFindUniqueArgs<ExtArgs>>): Prisma__clan_banesClient<$Result.GetResult<Prisma.$clan_banesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Clan_banes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {clan_banesFindUniqueOrThrowArgs} args - Arguments to find a Clan_banes
     * @example
     * // Get one Clan_banes
     * const clan_banes = await prisma.clan_banes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends clan_banesFindUniqueOrThrowArgs>(args: SelectSubset<T, clan_banesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__clan_banesClient<$Result.GetResult<Prisma.$clan_banesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Clan_banes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clan_banesFindFirstArgs} args - Arguments to find a Clan_banes
     * @example
     * // Get one Clan_banes
     * const clan_banes = await prisma.clan_banes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends clan_banesFindFirstArgs>(args?: SelectSubset<T, clan_banesFindFirstArgs<ExtArgs>>): Prisma__clan_banesClient<$Result.GetResult<Prisma.$clan_banesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Clan_banes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clan_banesFindFirstOrThrowArgs} args - Arguments to find a Clan_banes
     * @example
     * // Get one Clan_banes
     * const clan_banes = await prisma.clan_banes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends clan_banesFindFirstOrThrowArgs>(args?: SelectSubset<T, clan_banesFindFirstOrThrowArgs<ExtArgs>>): Prisma__clan_banesClient<$Result.GetResult<Prisma.$clan_banesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clan_banes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clan_banesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clan_banes
     * const clan_banes = await prisma.clan_banes.findMany()
     * 
     * // Get first 10 Clan_banes
     * const clan_banes = await prisma.clan_banes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clan_banesWithIdOnly = await prisma.clan_banes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends clan_banesFindManyArgs>(args?: SelectSubset<T, clan_banesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clan_banesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Clan_banes.
     * @param {clan_banesCreateArgs} args - Arguments to create a Clan_banes.
     * @example
     * // Create one Clan_banes
     * const Clan_banes = await prisma.clan_banes.create({
     *   data: {
     *     // ... data to create a Clan_banes
     *   }
     * })
     * 
     */
    create<T extends clan_banesCreateArgs>(args: SelectSubset<T, clan_banesCreateArgs<ExtArgs>>): Prisma__clan_banesClient<$Result.GetResult<Prisma.$clan_banesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clan_banes.
     * @param {clan_banesCreateManyArgs} args - Arguments to create many Clan_banes.
     * @example
     * // Create many Clan_banes
     * const clan_banes = await prisma.clan_banes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends clan_banesCreateManyArgs>(args?: SelectSubset<T, clan_banesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clan_banes and returns the data saved in the database.
     * @param {clan_banesCreateManyAndReturnArgs} args - Arguments to create many Clan_banes.
     * @example
     * // Create many Clan_banes
     * const clan_banes = await prisma.clan_banes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clan_banes and only return the `id`
     * const clan_banesWithIdOnly = await prisma.clan_banes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends clan_banesCreateManyAndReturnArgs>(args?: SelectSubset<T, clan_banesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clan_banesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Clan_banes.
     * @param {clan_banesDeleteArgs} args - Arguments to delete one Clan_banes.
     * @example
     * // Delete one Clan_banes
     * const Clan_banes = await prisma.clan_banes.delete({
     *   where: {
     *     // ... filter to delete one Clan_banes
     *   }
     * })
     * 
     */
    delete<T extends clan_banesDeleteArgs>(args: SelectSubset<T, clan_banesDeleteArgs<ExtArgs>>): Prisma__clan_banesClient<$Result.GetResult<Prisma.$clan_banesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Clan_banes.
     * @param {clan_banesUpdateArgs} args - Arguments to update one Clan_banes.
     * @example
     * // Update one Clan_banes
     * const clan_banes = await prisma.clan_banes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends clan_banesUpdateArgs>(args: SelectSubset<T, clan_banesUpdateArgs<ExtArgs>>): Prisma__clan_banesClient<$Result.GetResult<Prisma.$clan_banesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clan_banes.
     * @param {clan_banesDeleteManyArgs} args - Arguments to filter Clan_banes to delete.
     * @example
     * // Delete a few Clan_banes
     * const { count } = await prisma.clan_banes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends clan_banesDeleteManyArgs>(args?: SelectSubset<T, clan_banesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clan_banes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clan_banesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clan_banes
     * const clan_banes = await prisma.clan_banes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends clan_banesUpdateManyArgs>(args: SelectSubset<T, clan_banesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clan_banes and returns the data updated in the database.
     * @param {clan_banesUpdateManyAndReturnArgs} args - Arguments to update many Clan_banes.
     * @example
     * // Update many Clan_banes
     * const clan_banes = await prisma.clan_banes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clan_banes and only return the `id`
     * const clan_banesWithIdOnly = await prisma.clan_banes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends clan_banesUpdateManyAndReturnArgs>(args: SelectSubset<T, clan_banesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clan_banesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Clan_banes.
     * @param {clan_banesUpsertArgs} args - Arguments to update or create a Clan_banes.
     * @example
     * // Update or create a Clan_banes
     * const clan_banes = await prisma.clan_banes.upsert({
     *   create: {
     *     // ... data to create a Clan_banes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clan_banes we want to update
     *   }
     * })
     */
    upsert<T extends clan_banesUpsertArgs>(args: SelectSubset<T, clan_banesUpsertArgs<ExtArgs>>): Prisma__clan_banesClient<$Result.GetResult<Prisma.$clan_banesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clan_banes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clan_banesCountArgs} args - Arguments to filter Clan_banes to count.
     * @example
     * // Count the number of Clan_banes
     * const count = await prisma.clan_banes.count({
     *   where: {
     *     // ... the filter for the Clan_banes we want to count
     *   }
     * })
    **/
    count<T extends clan_banesCountArgs>(
      args?: Subset<T, clan_banesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Clan_banesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Clan_banes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Clan_banesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Clan_banesAggregateArgs>(args: Subset<T, Clan_banesAggregateArgs>): Prisma.PrismaPromise<GetClan_banesAggregateType<T>>

    /**
     * Group by Clan_banes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clan_banesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends clan_banesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: clan_banesGroupByArgs['orderBy'] }
        : { orderBy?: clan_banesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, clan_banesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClan_banesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the clan_banes model
   */
  readonly fields: clan_banesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for clan_banes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__clan_banesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    character_bloodpotencies<T extends clan_banes$character_bloodpotenciesArgs<ExtArgs> = {}>(args?: Subset<T, clan_banes$character_bloodpotenciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_bloodpotenciesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    characters<T extends clan_banes$charactersArgs<ExtArgs> = {}>(args?: Subset<T, clan_banes$charactersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$charactersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clans<T extends clansDefaultArgs<ExtArgs> = {}>(args?: Subset<T, clansDefaultArgs<ExtArgs>>): Prisma__clansClient<$Result.GetResult<Prisma.$clansPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the clan_banes model
   */
  interface clan_banesFieldRefs {
    readonly id: FieldRef<"clan_banes", 'String'>
    readonly name: FieldRef<"clan_banes", 'String'>
    readonly clan_id: FieldRef<"clan_banes", 'String'>
    readonly description: FieldRef<"clan_banes", 'String'>
  }
    

  // Custom InputTypes
  /**
   * clan_banes findUnique
   */
  export type clan_banesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clan_banes
     */
    select?: clan_banesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clan_banes
     */
    omit?: clan_banesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clan_banesInclude<ExtArgs> | null
    /**
     * Filter, which clan_banes to fetch.
     */
    where: clan_banesWhereUniqueInput
  }

  /**
   * clan_banes findUniqueOrThrow
   */
  export type clan_banesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clan_banes
     */
    select?: clan_banesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clan_banes
     */
    omit?: clan_banesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clan_banesInclude<ExtArgs> | null
    /**
     * Filter, which clan_banes to fetch.
     */
    where: clan_banesWhereUniqueInput
  }

  /**
   * clan_banes findFirst
   */
  export type clan_banesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clan_banes
     */
    select?: clan_banesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clan_banes
     */
    omit?: clan_banesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clan_banesInclude<ExtArgs> | null
    /**
     * Filter, which clan_banes to fetch.
     */
    where?: clan_banesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clan_banes to fetch.
     */
    orderBy?: clan_banesOrderByWithRelationInput | clan_banesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clan_banes.
     */
    cursor?: clan_banesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clan_banes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clan_banes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clan_banes.
     */
    distinct?: Clan_banesScalarFieldEnum | Clan_banesScalarFieldEnum[]
  }

  /**
   * clan_banes findFirstOrThrow
   */
  export type clan_banesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clan_banes
     */
    select?: clan_banesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clan_banes
     */
    omit?: clan_banesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clan_banesInclude<ExtArgs> | null
    /**
     * Filter, which clan_banes to fetch.
     */
    where?: clan_banesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clan_banes to fetch.
     */
    orderBy?: clan_banesOrderByWithRelationInput | clan_banesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clan_banes.
     */
    cursor?: clan_banesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clan_banes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clan_banes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clan_banes.
     */
    distinct?: Clan_banesScalarFieldEnum | Clan_banesScalarFieldEnum[]
  }

  /**
   * clan_banes findMany
   */
  export type clan_banesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clan_banes
     */
    select?: clan_banesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clan_banes
     */
    omit?: clan_banesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clan_banesInclude<ExtArgs> | null
    /**
     * Filter, which clan_banes to fetch.
     */
    where?: clan_banesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clan_banes to fetch.
     */
    orderBy?: clan_banesOrderByWithRelationInput | clan_banesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing clan_banes.
     */
    cursor?: clan_banesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clan_banes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clan_banes.
     */
    skip?: number
    distinct?: Clan_banesScalarFieldEnum | Clan_banesScalarFieldEnum[]
  }

  /**
   * clan_banes create
   */
  export type clan_banesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clan_banes
     */
    select?: clan_banesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clan_banes
     */
    omit?: clan_banesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clan_banesInclude<ExtArgs> | null
    /**
     * The data needed to create a clan_banes.
     */
    data: XOR<clan_banesCreateInput, clan_banesUncheckedCreateInput>
  }

  /**
   * clan_banes createMany
   */
  export type clan_banesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many clan_banes.
     */
    data: clan_banesCreateManyInput | clan_banesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * clan_banes createManyAndReturn
   */
  export type clan_banesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clan_banes
     */
    select?: clan_banesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the clan_banes
     */
    omit?: clan_banesOmit<ExtArgs> | null
    /**
     * The data used to create many clan_banes.
     */
    data: clan_banesCreateManyInput | clan_banesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clan_banesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * clan_banes update
   */
  export type clan_banesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clan_banes
     */
    select?: clan_banesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clan_banes
     */
    omit?: clan_banesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clan_banesInclude<ExtArgs> | null
    /**
     * The data needed to update a clan_banes.
     */
    data: XOR<clan_banesUpdateInput, clan_banesUncheckedUpdateInput>
    /**
     * Choose, which clan_banes to update.
     */
    where: clan_banesWhereUniqueInput
  }

  /**
   * clan_banes updateMany
   */
  export type clan_banesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update clan_banes.
     */
    data: XOR<clan_banesUpdateManyMutationInput, clan_banesUncheckedUpdateManyInput>
    /**
     * Filter which clan_banes to update
     */
    where?: clan_banesWhereInput
    /**
     * Limit how many clan_banes to update.
     */
    limit?: number
  }

  /**
   * clan_banes updateManyAndReturn
   */
  export type clan_banesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clan_banes
     */
    select?: clan_banesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the clan_banes
     */
    omit?: clan_banesOmit<ExtArgs> | null
    /**
     * The data used to update clan_banes.
     */
    data: XOR<clan_banesUpdateManyMutationInput, clan_banesUncheckedUpdateManyInput>
    /**
     * Filter which clan_banes to update
     */
    where?: clan_banesWhereInput
    /**
     * Limit how many clan_banes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clan_banesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * clan_banes upsert
   */
  export type clan_banesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clan_banes
     */
    select?: clan_banesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clan_banes
     */
    omit?: clan_banesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clan_banesInclude<ExtArgs> | null
    /**
     * The filter to search for the clan_banes to update in case it exists.
     */
    where: clan_banesWhereUniqueInput
    /**
     * In case the clan_banes found by the `where` argument doesn't exist, create a new clan_banes with this data.
     */
    create: XOR<clan_banesCreateInput, clan_banesUncheckedCreateInput>
    /**
     * In case the clan_banes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<clan_banesUpdateInput, clan_banesUncheckedUpdateInput>
  }

  /**
   * clan_banes delete
   */
  export type clan_banesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clan_banes
     */
    select?: clan_banesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clan_banes
     */
    omit?: clan_banesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clan_banesInclude<ExtArgs> | null
    /**
     * Filter which clan_banes to delete.
     */
    where: clan_banesWhereUniqueInput
  }

  /**
   * clan_banes deleteMany
   */
  export type clan_banesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clan_banes to delete
     */
    where?: clan_banesWhereInput
    /**
     * Limit how many clan_banes to delete.
     */
    limit?: number
  }

  /**
   * clan_banes.character_bloodpotencies
   */
  export type clan_banes$character_bloodpotenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_bloodpotencies
     */
    select?: character_bloodpotenciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_bloodpotencies
     */
    omit?: character_bloodpotenciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_bloodpotenciesInclude<ExtArgs> | null
    where?: character_bloodpotenciesWhereInput
    orderBy?: character_bloodpotenciesOrderByWithRelationInput | character_bloodpotenciesOrderByWithRelationInput[]
    cursor?: character_bloodpotenciesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Character_bloodpotenciesScalarFieldEnum | Character_bloodpotenciesScalarFieldEnum[]
  }

  /**
   * clan_banes.characters
   */
  export type clan_banes$charactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characters
     */
    select?: charactersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the characters
     */
    omit?: charactersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: charactersInclude<ExtArgs> | null
    where?: charactersWhereInput
    orderBy?: charactersOrderByWithRelationInput | charactersOrderByWithRelationInput[]
    cursor?: charactersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharactersScalarFieldEnum | CharactersScalarFieldEnum[]
  }

  /**
   * clan_banes without action
   */
  export type clan_banesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clan_banes
     */
    select?: clan_banesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clan_banes
     */
    omit?: clan_banesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clan_banesInclude<ExtArgs> | null
  }


  /**
   * Model clan_compulsions
   */

  export type AggregateClan_compulsions = {
    _count: Clan_compulsionsCountAggregateOutputType | null
    _min: Clan_compulsionsMinAggregateOutputType | null
    _max: Clan_compulsionsMaxAggregateOutputType | null
  }

  export type Clan_compulsionsMinAggregateOutputType = {
    id: string | null
    name: string | null
    clan_id: string | null
    description: string | null
  }

  export type Clan_compulsionsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    clan_id: string | null
    description: string | null
  }

  export type Clan_compulsionsCountAggregateOutputType = {
    id: number
    name: number
    clan_id: number
    description: number
    _all: number
  }


  export type Clan_compulsionsMinAggregateInputType = {
    id?: true
    name?: true
    clan_id?: true
    description?: true
  }

  export type Clan_compulsionsMaxAggregateInputType = {
    id?: true
    name?: true
    clan_id?: true
    description?: true
  }

  export type Clan_compulsionsCountAggregateInputType = {
    id?: true
    name?: true
    clan_id?: true
    description?: true
    _all?: true
  }

  export type Clan_compulsionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clan_compulsions to aggregate.
     */
    where?: clan_compulsionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clan_compulsions to fetch.
     */
    orderBy?: clan_compulsionsOrderByWithRelationInput | clan_compulsionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: clan_compulsionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clan_compulsions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clan_compulsions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned clan_compulsions
    **/
    _count?: true | Clan_compulsionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Clan_compulsionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Clan_compulsionsMaxAggregateInputType
  }

  export type GetClan_compulsionsAggregateType<T extends Clan_compulsionsAggregateArgs> = {
        [P in keyof T & keyof AggregateClan_compulsions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClan_compulsions[P]>
      : GetScalarType<T[P], AggregateClan_compulsions[P]>
  }




  export type clan_compulsionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clan_compulsionsWhereInput
    orderBy?: clan_compulsionsOrderByWithAggregationInput | clan_compulsionsOrderByWithAggregationInput[]
    by: Clan_compulsionsScalarFieldEnum[] | Clan_compulsionsScalarFieldEnum
    having?: clan_compulsionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Clan_compulsionsCountAggregateInputType | true
    _min?: Clan_compulsionsMinAggregateInputType
    _max?: Clan_compulsionsMaxAggregateInputType
  }

  export type Clan_compulsionsGroupByOutputType = {
    id: string
    name: string
    clan_id: string
    description: string
    _count: Clan_compulsionsCountAggregateOutputType | null
    _min: Clan_compulsionsMinAggregateOutputType | null
    _max: Clan_compulsionsMaxAggregateOutputType | null
  }

  type GetClan_compulsionsGroupByPayload<T extends clan_compulsionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Clan_compulsionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Clan_compulsionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Clan_compulsionsGroupByOutputType[P]>
            : GetScalarType<T[P], Clan_compulsionsGroupByOutputType[P]>
        }
      >
    >


  export type clan_compulsionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    clan_id?: boolean
    description?: boolean
    character_bloodpotencies?: boolean | clan_compulsions$character_bloodpotenciesArgs<ExtArgs>
    characters?: boolean | clan_compulsions$charactersArgs<ExtArgs>
    clans?: boolean | clansDefaultArgs<ExtArgs>
    _count?: boolean | Clan_compulsionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clan_compulsions"]>

  export type clan_compulsionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    clan_id?: boolean
    description?: boolean
    clans?: boolean | clansDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clan_compulsions"]>

  export type clan_compulsionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    clan_id?: boolean
    description?: boolean
    clans?: boolean | clansDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clan_compulsions"]>

  export type clan_compulsionsSelectScalar = {
    id?: boolean
    name?: boolean
    clan_id?: boolean
    description?: boolean
  }

  export type clan_compulsionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "clan_id" | "description", ExtArgs["result"]["clan_compulsions"]>
  export type clan_compulsionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character_bloodpotencies?: boolean | clan_compulsions$character_bloodpotenciesArgs<ExtArgs>
    characters?: boolean | clan_compulsions$charactersArgs<ExtArgs>
    clans?: boolean | clansDefaultArgs<ExtArgs>
    _count?: boolean | Clan_compulsionsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type clan_compulsionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clans?: boolean | clansDefaultArgs<ExtArgs>
  }
  export type clan_compulsionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clans?: boolean | clansDefaultArgs<ExtArgs>
  }

  export type $clan_compulsionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "clan_compulsions"
    objects: {
      character_bloodpotencies: Prisma.$character_bloodpotenciesPayload<ExtArgs>[]
      characters: Prisma.$charactersPayload<ExtArgs>[]
      clans: Prisma.$clansPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      clan_id: string
      description: string
    }, ExtArgs["result"]["clan_compulsions"]>
    composites: {}
  }

  type clan_compulsionsGetPayload<S extends boolean | null | undefined | clan_compulsionsDefaultArgs> = $Result.GetResult<Prisma.$clan_compulsionsPayload, S>

  type clan_compulsionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<clan_compulsionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Clan_compulsionsCountAggregateInputType | true
    }

  export interface clan_compulsionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['clan_compulsions'], meta: { name: 'clan_compulsions' } }
    /**
     * Find zero or one Clan_compulsions that matches the filter.
     * @param {clan_compulsionsFindUniqueArgs} args - Arguments to find a Clan_compulsions
     * @example
     * // Get one Clan_compulsions
     * const clan_compulsions = await prisma.clan_compulsions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends clan_compulsionsFindUniqueArgs>(args: SelectSubset<T, clan_compulsionsFindUniqueArgs<ExtArgs>>): Prisma__clan_compulsionsClient<$Result.GetResult<Prisma.$clan_compulsionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Clan_compulsions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {clan_compulsionsFindUniqueOrThrowArgs} args - Arguments to find a Clan_compulsions
     * @example
     * // Get one Clan_compulsions
     * const clan_compulsions = await prisma.clan_compulsions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends clan_compulsionsFindUniqueOrThrowArgs>(args: SelectSubset<T, clan_compulsionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__clan_compulsionsClient<$Result.GetResult<Prisma.$clan_compulsionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Clan_compulsions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clan_compulsionsFindFirstArgs} args - Arguments to find a Clan_compulsions
     * @example
     * // Get one Clan_compulsions
     * const clan_compulsions = await prisma.clan_compulsions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends clan_compulsionsFindFirstArgs>(args?: SelectSubset<T, clan_compulsionsFindFirstArgs<ExtArgs>>): Prisma__clan_compulsionsClient<$Result.GetResult<Prisma.$clan_compulsionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Clan_compulsions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clan_compulsionsFindFirstOrThrowArgs} args - Arguments to find a Clan_compulsions
     * @example
     * // Get one Clan_compulsions
     * const clan_compulsions = await prisma.clan_compulsions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends clan_compulsionsFindFirstOrThrowArgs>(args?: SelectSubset<T, clan_compulsionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__clan_compulsionsClient<$Result.GetResult<Prisma.$clan_compulsionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clan_compulsions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clan_compulsionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clan_compulsions
     * const clan_compulsions = await prisma.clan_compulsions.findMany()
     * 
     * // Get first 10 Clan_compulsions
     * const clan_compulsions = await prisma.clan_compulsions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clan_compulsionsWithIdOnly = await prisma.clan_compulsions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends clan_compulsionsFindManyArgs>(args?: SelectSubset<T, clan_compulsionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clan_compulsionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Clan_compulsions.
     * @param {clan_compulsionsCreateArgs} args - Arguments to create a Clan_compulsions.
     * @example
     * // Create one Clan_compulsions
     * const Clan_compulsions = await prisma.clan_compulsions.create({
     *   data: {
     *     // ... data to create a Clan_compulsions
     *   }
     * })
     * 
     */
    create<T extends clan_compulsionsCreateArgs>(args: SelectSubset<T, clan_compulsionsCreateArgs<ExtArgs>>): Prisma__clan_compulsionsClient<$Result.GetResult<Prisma.$clan_compulsionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clan_compulsions.
     * @param {clan_compulsionsCreateManyArgs} args - Arguments to create many Clan_compulsions.
     * @example
     * // Create many Clan_compulsions
     * const clan_compulsions = await prisma.clan_compulsions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends clan_compulsionsCreateManyArgs>(args?: SelectSubset<T, clan_compulsionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clan_compulsions and returns the data saved in the database.
     * @param {clan_compulsionsCreateManyAndReturnArgs} args - Arguments to create many Clan_compulsions.
     * @example
     * // Create many Clan_compulsions
     * const clan_compulsions = await prisma.clan_compulsions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clan_compulsions and only return the `id`
     * const clan_compulsionsWithIdOnly = await prisma.clan_compulsions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends clan_compulsionsCreateManyAndReturnArgs>(args?: SelectSubset<T, clan_compulsionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clan_compulsionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Clan_compulsions.
     * @param {clan_compulsionsDeleteArgs} args - Arguments to delete one Clan_compulsions.
     * @example
     * // Delete one Clan_compulsions
     * const Clan_compulsions = await prisma.clan_compulsions.delete({
     *   where: {
     *     // ... filter to delete one Clan_compulsions
     *   }
     * })
     * 
     */
    delete<T extends clan_compulsionsDeleteArgs>(args: SelectSubset<T, clan_compulsionsDeleteArgs<ExtArgs>>): Prisma__clan_compulsionsClient<$Result.GetResult<Prisma.$clan_compulsionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Clan_compulsions.
     * @param {clan_compulsionsUpdateArgs} args - Arguments to update one Clan_compulsions.
     * @example
     * // Update one Clan_compulsions
     * const clan_compulsions = await prisma.clan_compulsions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends clan_compulsionsUpdateArgs>(args: SelectSubset<T, clan_compulsionsUpdateArgs<ExtArgs>>): Prisma__clan_compulsionsClient<$Result.GetResult<Prisma.$clan_compulsionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clan_compulsions.
     * @param {clan_compulsionsDeleteManyArgs} args - Arguments to filter Clan_compulsions to delete.
     * @example
     * // Delete a few Clan_compulsions
     * const { count } = await prisma.clan_compulsions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends clan_compulsionsDeleteManyArgs>(args?: SelectSubset<T, clan_compulsionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clan_compulsions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clan_compulsionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clan_compulsions
     * const clan_compulsions = await prisma.clan_compulsions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends clan_compulsionsUpdateManyArgs>(args: SelectSubset<T, clan_compulsionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clan_compulsions and returns the data updated in the database.
     * @param {clan_compulsionsUpdateManyAndReturnArgs} args - Arguments to update many Clan_compulsions.
     * @example
     * // Update many Clan_compulsions
     * const clan_compulsions = await prisma.clan_compulsions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clan_compulsions and only return the `id`
     * const clan_compulsionsWithIdOnly = await prisma.clan_compulsions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends clan_compulsionsUpdateManyAndReturnArgs>(args: SelectSubset<T, clan_compulsionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clan_compulsionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Clan_compulsions.
     * @param {clan_compulsionsUpsertArgs} args - Arguments to update or create a Clan_compulsions.
     * @example
     * // Update or create a Clan_compulsions
     * const clan_compulsions = await prisma.clan_compulsions.upsert({
     *   create: {
     *     // ... data to create a Clan_compulsions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clan_compulsions we want to update
     *   }
     * })
     */
    upsert<T extends clan_compulsionsUpsertArgs>(args: SelectSubset<T, clan_compulsionsUpsertArgs<ExtArgs>>): Prisma__clan_compulsionsClient<$Result.GetResult<Prisma.$clan_compulsionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clan_compulsions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clan_compulsionsCountArgs} args - Arguments to filter Clan_compulsions to count.
     * @example
     * // Count the number of Clan_compulsions
     * const count = await prisma.clan_compulsions.count({
     *   where: {
     *     // ... the filter for the Clan_compulsions we want to count
     *   }
     * })
    **/
    count<T extends clan_compulsionsCountArgs>(
      args?: Subset<T, clan_compulsionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Clan_compulsionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Clan_compulsions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Clan_compulsionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Clan_compulsionsAggregateArgs>(args: Subset<T, Clan_compulsionsAggregateArgs>): Prisma.PrismaPromise<GetClan_compulsionsAggregateType<T>>

    /**
     * Group by Clan_compulsions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clan_compulsionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends clan_compulsionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: clan_compulsionsGroupByArgs['orderBy'] }
        : { orderBy?: clan_compulsionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, clan_compulsionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClan_compulsionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the clan_compulsions model
   */
  readonly fields: clan_compulsionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for clan_compulsions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__clan_compulsionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    character_bloodpotencies<T extends clan_compulsions$character_bloodpotenciesArgs<ExtArgs> = {}>(args?: Subset<T, clan_compulsions$character_bloodpotenciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_bloodpotenciesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    characters<T extends clan_compulsions$charactersArgs<ExtArgs> = {}>(args?: Subset<T, clan_compulsions$charactersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$charactersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clans<T extends clansDefaultArgs<ExtArgs> = {}>(args?: Subset<T, clansDefaultArgs<ExtArgs>>): Prisma__clansClient<$Result.GetResult<Prisma.$clansPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the clan_compulsions model
   */
  interface clan_compulsionsFieldRefs {
    readonly id: FieldRef<"clan_compulsions", 'String'>
    readonly name: FieldRef<"clan_compulsions", 'String'>
    readonly clan_id: FieldRef<"clan_compulsions", 'String'>
    readonly description: FieldRef<"clan_compulsions", 'String'>
  }
    

  // Custom InputTypes
  /**
   * clan_compulsions findUnique
   */
  export type clan_compulsionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clan_compulsions
     */
    select?: clan_compulsionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clan_compulsions
     */
    omit?: clan_compulsionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clan_compulsionsInclude<ExtArgs> | null
    /**
     * Filter, which clan_compulsions to fetch.
     */
    where: clan_compulsionsWhereUniqueInput
  }

  /**
   * clan_compulsions findUniqueOrThrow
   */
  export type clan_compulsionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clan_compulsions
     */
    select?: clan_compulsionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clan_compulsions
     */
    omit?: clan_compulsionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clan_compulsionsInclude<ExtArgs> | null
    /**
     * Filter, which clan_compulsions to fetch.
     */
    where: clan_compulsionsWhereUniqueInput
  }

  /**
   * clan_compulsions findFirst
   */
  export type clan_compulsionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clan_compulsions
     */
    select?: clan_compulsionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clan_compulsions
     */
    omit?: clan_compulsionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clan_compulsionsInclude<ExtArgs> | null
    /**
     * Filter, which clan_compulsions to fetch.
     */
    where?: clan_compulsionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clan_compulsions to fetch.
     */
    orderBy?: clan_compulsionsOrderByWithRelationInput | clan_compulsionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clan_compulsions.
     */
    cursor?: clan_compulsionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clan_compulsions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clan_compulsions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clan_compulsions.
     */
    distinct?: Clan_compulsionsScalarFieldEnum | Clan_compulsionsScalarFieldEnum[]
  }

  /**
   * clan_compulsions findFirstOrThrow
   */
  export type clan_compulsionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clan_compulsions
     */
    select?: clan_compulsionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clan_compulsions
     */
    omit?: clan_compulsionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clan_compulsionsInclude<ExtArgs> | null
    /**
     * Filter, which clan_compulsions to fetch.
     */
    where?: clan_compulsionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clan_compulsions to fetch.
     */
    orderBy?: clan_compulsionsOrderByWithRelationInput | clan_compulsionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clan_compulsions.
     */
    cursor?: clan_compulsionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clan_compulsions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clan_compulsions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clan_compulsions.
     */
    distinct?: Clan_compulsionsScalarFieldEnum | Clan_compulsionsScalarFieldEnum[]
  }

  /**
   * clan_compulsions findMany
   */
  export type clan_compulsionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clan_compulsions
     */
    select?: clan_compulsionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clan_compulsions
     */
    omit?: clan_compulsionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clan_compulsionsInclude<ExtArgs> | null
    /**
     * Filter, which clan_compulsions to fetch.
     */
    where?: clan_compulsionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clan_compulsions to fetch.
     */
    orderBy?: clan_compulsionsOrderByWithRelationInput | clan_compulsionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing clan_compulsions.
     */
    cursor?: clan_compulsionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clan_compulsions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clan_compulsions.
     */
    skip?: number
    distinct?: Clan_compulsionsScalarFieldEnum | Clan_compulsionsScalarFieldEnum[]
  }

  /**
   * clan_compulsions create
   */
  export type clan_compulsionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clan_compulsions
     */
    select?: clan_compulsionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clan_compulsions
     */
    omit?: clan_compulsionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clan_compulsionsInclude<ExtArgs> | null
    /**
     * The data needed to create a clan_compulsions.
     */
    data: XOR<clan_compulsionsCreateInput, clan_compulsionsUncheckedCreateInput>
  }

  /**
   * clan_compulsions createMany
   */
  export type clan_compulsionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many clan_compulsions.
     */
    data: clan_compulsionsCreateManyInput | clan_compulsionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * clan_compulsions createManyAndReturn
   */
  export type clan_compulsionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clan_compulsions
     */
    select?: clan_compulsionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the clan_compulsions
     */
    omit?: clan_compulsionsOmit<ExtArgs> | null
    /**
     * The data used to create many clan_compulsions.
     */
    data: clan_compulsionsCreateManyInput | clan_compulsionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clan_compulsionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * clan_compulsions update
   */
  export type clan_compulsionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clan_compulsions
     */
    select?: clan_compulsionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clan_compulsions
     */
    omit?: clan_compulsionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clan_compulsionsInclude<ExtArgs> | null
    /**
     * The data needed to update a clan_compulsions.
     */
    data: XOR<clan_compulsionsUpdateInput, clan_compulsionsUncheckedUpdateInput>
    /**
     * Choose, which clan_compulsions to update.
     */
    where: clan_compulsionsWhereUniqueInput
  }

  /**
   * clan_compulsions updateMany
   */
  export type clan_compulsionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update clan_compulsions.
     */
    data: XOR<clan_compulsionsUpdateManyMutationInput, clan_compulsionsUncheckedUpdateManyInput>
    /**
     * Filter which clan_compulsions to update
     */
    where?: clan_compulsionsWhereInput
    /**
     * Limit how many clan_compulsions to update.
     */
    limit?: number
  }

  /**
   * clan_compulsions updateManyAndReturn
   */
  export type clan_compulsionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clan_compulsions
     */
    select?: clan_compulsionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the clan_compulsions
     */
    omit?: clan_compulsionsOmit<ExtArgs> | null
    /**
     * The data used to update clan_compulsions.
     */
    data: XOR<clan_compulsionsUpdateManyMutationInput, clan_compulsionsUncheckedUpdateManyInput>
    /**
     * Filter which clan_compulsions to update
     */
    where?: clan_compulsionsWhereInput
    /**
     * Limit how many clan_compulsions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clan_compulsionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * clan_compulsions upsert
   */
  export type clan_compulsionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clan_compulsions
     */
    select?: clan_compulsionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clan_compulsions
     */
    omit?: clan_compulsionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clan_compulsionsInclude<ExtArgs> | null
    /**
     * The filter to search for the clan_compulsions to update in case it exists.
     */
    where: clan_compulsionsWhereUniqueInput
    /**
     * In case the clan_compulsions found by the `where` argument doesn't exist, create a new clan_compulsions with this data.
     */
    create: XOR<clan_compulsionsCreateInput, clan_compulsionsUncheckedCreateInput>
    /**
     * In case the clan_compulsions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<clan_compulsionsUpdateInput, clan_compulsionsUncheckedUpdateInput>
  }

  /**
   * clan_compulsions delete
   */
  export type clan_compulsionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clan_compulsions
     */
    select?: clan_compulsionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clan_compulsions
     */
    omit?: clan_compulsionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clan_compulsionsInclude<ExtArgs> | null
    /**
     * Filter which clan_compulsions to delete.
     */
    where: clan_compulsionsWhereUniqueInput
  }

  /**
   * clan_compulsions deleteMany
   */
  export type clan_compulsionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clan_compulsions to delete
     */
    where?: clan_compulsionsWhereInput
    /**
     * Limit how many clan_compulsions to delete.
     */
    limit?: number
  }

  /**
   * clan_compulsions.character_bloodpotencies
   */
  export type clan_compulsions$character_bloodpotenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_bloodpotencies
     */
    select?: character_bloodpotenciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_bloodpotencies
     */
    omit?: character_bloodpotenciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_bloodpotenciesInclude<ExtArgs> | null
    where?: character_bloodpotenciesWhereInput
    orderBy?: character_bloodpotenciesOrderByWithRelationInput | character_bloodpotenciesOrderByWithRelationInput[]
    cursor?: character_bloodpotenciesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Character_bloodpotenciesScalarFieldEnum | Character_bloodpotenciesScalarFieldEnum[]
  }

  /**
   * clan_compulsions.characters
   */
  export type clan_compulsions$charactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characters
     */
    select?: charactersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the characters
     */
    omit?: charactersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: charactersInclude<ExtArgs> | null
    where?: charactersWhereInput
    orderBy?: charactersOrderByWithRelationInput | charactersOrderByWithRelationInput[]
    cursor?: charactersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharactersScalarFieldEnum | CharactersScalarFieldEnum[]
  }

  /**
   * clan_compulsions without action
   */
  export type clan_compulsionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clan_compulsions
     */
    select?: clan_compulsionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clan_compulsions
     */
    omit?: clan_compulsionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clan_compulsionsInclude<ExtArgs> | null
  }


  /**
   * Model clans
   */

  export type AggregateClans = {
    _count: ClansCountAggregateOutputType | null
    _min: ClansMinAggregateOutputType | null
    _max: ClansMaxAggregateOutputType | null
  }

  export type ClansMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
  }

  export type ClansMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
  }

  export type ClansCountAggregateOutputType = {
    id: number
    name: number
    description: number
    _all: number
  }


  export type ClansMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type ClansMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type ClansCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type ClansAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clans to aggregate.
     */
    where?: clansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clans to fetch.
     */
    orderBy?: clansOrderByWithRelationInput | clansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: clansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned clans
    **/
    _count?: true | ClansCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClansMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClansMaxAggregateInputType
  }

  export type GetClansAggregateType<T extends ClansAggregateArgs> = {
        [P in keyof T & keyof AggregateClans]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClans[P]>
      : GetScalarType<T[P], AggregateClans[P]>
  }




  export type clansGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clansWhereInput
    orderBy?: clansOrderByWithAggregationInput | clansOrderByWithAggregationInput[]
    by: ClansScalarFieldEnum[] | ClansScalarFieldEnum
    having?: clansScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClansCountAggregateInputType | true
    _min?: ClansMinAggregateInputType
    _max?: ClansMaxAggregateInputType
  }

  export type ClansGroupByOutputType = {
    id: string
    name: string
    description: string
    _count: ClansCountAggregateOutputType | null
    _min: ClansMinAggregateOutputType | null
    _max: ClansMaxAggregateOutputType | null
  }

  type GetClansGroupByPayload<T extends clansGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClansGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClansGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClansGroupByOutputType[P]>
            : GetScalarType<T[P], ClansGroupByOutputType[P]>
        }
      >
    >


  export type clansSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    advantages?: boolean | clans$advantagesArgs<ExtArgs>
    characters?: boolean | clans$charactersArgs<ExtArgs>
    clan_banes?: boolean | clans$clan_banesArgs<ExtArgs>
    clan_compulsions?: boolean | clans$clan_compulsionsArgs<ExtArgs>
    _count?: boolean | ClansCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clans"]>

  export type clansSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["clans"]>

  export type clansSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["clans"]>

  export type clansSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
  }

  export type clansOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description", ExtArgs["result"]["clans"]>
  export type clansInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    advantages?: boolean | clans$advantagesArgs<ExtArgs>
    characters?: boolean | clans$charactersArgs<ExtArgs>
    clan_banes?: boolean | clans$clan_banesArgs<ExtArgs>
    clan_compulsions?: boolean | clans$clan_compulsionsArgs<ExtArgs>
    _count?: boolean | ClansCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type clansIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type clansIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $clansPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "clans"
    objects: {
      advantages: Prisma.$advantagesPayload<ExtArgs>[]
      characters: Prisma.$charactersPayload<ExtArgs>[]
      clan_banes: Prisma.$clan_banesPayload<ExtArgs>[]
      clan_compulsions: Prisma.$clan_compulsionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
    }, ExtArgs["result"]["clans"]>
    composites: {}
  }

  type clansGetPayload<S extends boolean | null | undefined | clansDefaultArgs> = $Result.GetResult<Prisma.$clansPayload, S>

  type clansCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<clansFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClansCountAggregateInputType | true
    }

  export interface clansDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['clans'], meta: { name: 'clans' } }
    /**
     * Find zero or one Clans that matches the filter.
     * @param {clansFindUniqueArgs} args - Arguments to find a Clans
     * @example
     * // Get one Clans
     * const clans = await prisma.clans.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends clansFindUniqueArgs>(args: SelectSubset<T, clansFindUniqueArgs<ExtArgs>>): Prisma__clansClient<$Result.GetResult<Prisma.$clansPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Clans that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {clansFindUniqueOrThrowArgs} args - Arguments to find a Clans
     * @example
     * // Get one Clans
     * const clans = await prisma.clans.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends clansFindUniqueOrThrowArgs>(args: SelectSubset<T, clansFindUniqueOrThrowArgs<ExtArgs>>): Prisma__clansClient<$Result.GetResult<Prisma.$clansPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Clans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clansFindFirstArgs} args - Arguments to find a Clans
     * @example
     * // Get one Clans
     * const clans = await prisma.clans.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends clansFindFirstArgs>(args?: SelectSubset<T, clansFindFirstArgs<ExtArgs>>): Prisma__clansClient<$Result.GetResult<Prisma.$clansPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Clans that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clansFindFirstOrThrowArgs} args - Arguments to find a Clans
     * @example
     * // Get one Clans
     * const clans = await prisma.clans.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends clansFindFirstOrThrowArgs>(args?: SelectSubset<T, clansFindFirstOrThrowArgs<ExtArgs>>): Prisma__clansClient<$Result.GetResult<Prisma.$clansPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clansFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clans
     * const clans = await prisma.clans.findMany()
     * 
     * // Get first 10 Clans
     * const clans = await prisma.clans.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clansWithIdOnly = await prisma.clans.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends clansFindManyArgs>(args?: SelectSubset<T, clansFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clansPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Clans.
     * @param {clansCreateArgs} args - Arguments to create a Clans.
     * @example
     * // Create one Clans
     * const Clans = await prisma.clans.create({
     *   data: {
     *     // ... data to create a Clans
     *   }
     * })
     * 
     */
    create<T extends clansCreateArgs>(args: SelectSubset<T, clansCreateArgs<ExtArgs>>): Prisma__clansClient<$Result.GetResult<Prisma.$clansPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clans.
     * @param {clansCreateManyArgs} args - Arguments to create many Clans.
     * @example
     * // Create many Clans
     * const clans = await prisma.clans.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends clansCreateManyArgs>(args?: SelectSubset<T, clansCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clans and returns the data saved in the database.
     * @param {clansCreateManyAndReturnArgs} args - Arguments to create many Clans.
     * @example
     * // Create many Clans
     * const clans = await prisma.clans.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clans and only return the `id`
     * const clansWithIdOnly = await prisma.clans.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends clansCreateManyAndReturnArgs>(args?: SelectSubset<T, clansCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clansPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Clans.
     * @param {clansDeleteArgs} args - Arguments to delete one Clans.
     * @example
     * // Delete one Clans
     * const Clans = await prisma.clans.delete({
     *   where: {
     *     // ... filter to delete one Clans
     *   }
     * })
     * 
     */
    delete<T extends clansDeleteArgs>(args: SelectSubset<T, clansDeleteArgs<ExtArgs>>): Prisma__clansClient<$Result.GetResult<Prisma.$clansPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Clans.
     * @param {clansUpdateArgs} args - Arguments to update one Clans.
     * @example
     * // Update one Clans
     * const clans = await prisma.clans.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends clansUpdateArgs>(args: SelectSubset<T, clansUpdateArgs<ExtArgs>>): Prisma__clansClient<$Result.GetResult<Prisma.$clansPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clans.
     * @param {clansDeleteManyArgs} args - Arguments to filter Clans to delete.
     * @example
     * // Delete a few Clans
     * const { count } = await prisma.clans.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends clansDeleteManyArgs>(args?: SelectSubset<T, clansDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clansUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clans
     * const clans = await prisma.clans.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends clansUpdateManyArgs>(args: SelectSubset<T, clansUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clans and returns the data updated in the database.
     * @param {clansUpdateManyAndReturnArgs} args - Arguments to update many Clans.
     * @example
     * // Update many Clans
     * const clans = await prisma.clans.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clans and only return the `id`
     * const clansWithIdOnly = await prisma.clans.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends clansUpdateManyAndReturnArgs>(args: SelectSubset<T, clansUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clansPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Clans.
     * @param {clansUpsertArgs} args - Arguments to update or create a Clans.
     * @example
     * // Update or create a Clans
     * const clans = await prisma.clans.upsert({
     *   create: {
     *     // ... data to create a Clans
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clans we want to update
     *   }
     * })
     */
    upsert<T extends clansUpsertArgs>(args: SelectSubset<T, clansUpsertArgs<ExtArgs>>): Prisma__clansClient<$Result.GetResult<Prisma.$clansPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clansCountArgs} args - Arguments to filter Clans to count.
     * @example
     * // Count the number of Clans
     * const count = await prisma.clans.count({
     *   where: {
     *     // ... the filter for the Clans we want to count
     *   }
     * })
    **/
    count<T extends clansCountArgs>(
      args?: Subset<T, clansCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClansCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Clans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClansAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClansAggregateArgs>(args: Subset<T, ClansAggregateArgs>): Prisma.PrismaPromise<GetClansAggregateType<T>>

    /**
     * Group by Clans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clansGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends clansGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: clansGroupByArgs['orderBy'] }
        : { orderBy?: clansGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, clansGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClansGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the clans model
   */
  readonly fields: clansFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for clans.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__clansClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    advantages<T extends clans$advantagesArgs<ExtArgs> = {}>(args?: Subset<T, clans$advantagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$advantagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    characters<T extends clans$charactersArgs<ExtArgs> = {}>(args?: Subset<T, clans$charactersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$charactersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clan_banes<T extends clans$clan_banesArgs<ExtArgs> = {}>(args?: Subset<T, clans$clan_banesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clan_banesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clan_compulsions<T extends clans$clan_compulsionsArgs<ExtArgs> = {}>(args?: Subset<T, clans$clan_compulsionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clan_compulsionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the clans model
   */
  interface clansFieldRefs {
    readonly id: FieldRef<"clans", 'String'>
    readonly name: FieldRef<"clans", 'String'>
    readonly description: FieldRef<"clans", 'String'>
  }
    

  // Custom InputTypes
  /**
   * clans findUnique
   */
  export type clansFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clans
     */
    select?: clansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clans
     */
    omit?: clansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clansInclude<ExtArgs> | null
    /**
     * Filter, which clans to fetch.
     */
    where: clansWhereUniqueInput
  }

  /**
   * clans findUniqueOrThrow
   */
  export type clansFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clans
     */
    select?: clansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clans
     */
    omit?: clansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clansInclude<ExtArgs> | null
    /**
     * Filter, which clans to fetch.
     */
    where: clansWhereUniqueInput
  }

  /**
   * clans findFirst
   */
  export type clansFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clans
     */
    select?: clansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clans
     */
    omit?: clansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clansInclude<ExtArgs> | null
    /**
     * Filter, which clans to fetch.
     */
    where?: clansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clans to fetch.
     */
    orderBy?: clansOrderByWithRelationInput | clansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clans.
     */
    cursor?: clansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clans.
     */
    distinct?: ClansScalarFieldEnum | ClansScalarFieldEnum[]
  }

  /**
   * clans findFirstOrThrow
   */
  export type clansFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clans
     */
    select?: clansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clans
     */
    omit?: clansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clansInclude<ExtArgs> | null
    /**
     * Filter, which clans to fetch.
     */
    where?: clansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clans to fetch.
     */
    orderBy?: clansOrderByWithRelationInput | clansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clans.
     */
    cursor?: clansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clans.
     */
    distinct?: ClansScalarFieldEnum | ClansScalarFieldEnum[]
  }

  /**
   * clans findMany
   */
  export type clansFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clans
     */
    select?: clansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clans
     */
    omit?: clansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clansInclude<ExtArgs> | null
    /**
     * Filter, which clans to fetch.
     */
    where?: clansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clans to fetch.
     */
    orderBy?: clansOrderByWithRelationInput | clansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing clans.
     */
    cursor?: clansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clans.
     */
    skip?: number
    distinct?: ClansScalarFieldEnum | ClansScalarFieldEnum[]
  }

  /**
   * clans create
   */
  export type clansCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clans
     */
    select?: clansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clans
     */
    omit?: clansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clansInclude<ExtArgs> | null
    /**
     * The data needed to create a clans.
     */
    data: XOR<clansCreateInput, clansUncheckedCreateInput>
  }

  /**
   * clans createMany
   */
  export type clansCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many clans.
     */
    data: clansCreateManyInput | clansCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * clans createManyAndReturn
   */
  export type clansCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clans
     */
    select?: clansSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the clans
     */
    omit?: clansOmit<ExtArgs> | null
    /**
     * The data used to create many clans.
     */
    data: clansCreateManyInput | clansCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * clans update
   */
  export type clansUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clans
     */
    select?: clansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clans
     */
    omit?: clansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clansInclude<ExtArgs> | null
    /**
     * The data needed to update a clans.
     */
    data: XOR<clansUpdateInput, clansUncheckedUpdateInput>
    /**
     * Choose, which clans to update.
     */
    where: clansWhereUniqueInput
  }

  /**
   * clans updateMany
   */
  export type clansUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update clans.
     */
    data: XOR<clansUpdateManyMutationInput, clansUncheckedUpdateManyInput>
    /**
     * Filter which clans to update
     */
    where?: clansWhereInput
    /**
     * Limit how many clans to update.
     */
    limit?: number
  }

  /**
   * clans updateManyAndReturn
   */
  export type clansUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clans
     */
    select?: clansSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the clans
     */
    omit?: clansOmit<ExtArgs> | null
    /**
     * The data used to update clans.
     */
    data: XOR<clansUpdateManyMutationInput, clansUncheckedUpdateManyInput>
    /**
     * Filter which clans to update
     */
    where?: clansWhereInput
    /**
     * Limit how many clans to update.
     */
    limit?: number
  }

  /**
   * clans upsert
   */
  export type clansUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clans
     */
    select?: clansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clans
     */
    omit?: clansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clansInclude<ExtArgs> | null
    /**
     * The filter to search for the clans to update in case it exists.
     */
    where: clansWhereUniqueInput
    /**
     * In case the clans found by the `where` argument doesn't exist, create a new clans with this data.
     */
    create: XOR<clansCreateInput, clansUncheckedCreateInput>
    /**
     * In case the clans was found with the provided `where` argument, update it with this data.
     */
    update: XOR<clansUpdateInput, clansUncheckedUpdateInput>
  }

  /**
   * clans delete
   */
  export type clansDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clans
     */
    select?: clansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clans
     */
    omit?: clansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clansInclude<ExtArgs> | null
    /**
     * Filter which clans to delete.
     */
    where: clansWhereUniqueInput
  }

  /**
   * clans deleteMany
   */
  export type clansDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clans to delete
     */
    where?: clansWhereInput
    /**
     * Limit how many clans to delete.
     */
    limit?: number
  }

  /**
   * clans.advantages
   */
  export type clans$advantagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the advantages
     */
    select?: advantagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the advantages
     */
    omit?: advantagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: advantagesInclude<ExtArgs> | null
    where?: advantagesWhereInput
    orderBy?: advantagesOrderByWithRelationInput | advantagesOrderByWithRelationInput[]
    cursor?: advantagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdvantagesScalarFieldEnum | AdvantagesScalarFieldEnum[]
  }

  /**
   * clans.characters
   */
  export type clans$charactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characters
     */
    select?: charactersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the characters
     */
    omit?: charactersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: charactersInclude<ExtArgs> | null
    where?: charactersWhereInput
    orderBy?: charactersOrderByWithRelationInput | charactersOrderByWithRelationInput[]
    cursor?: charactersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharactersScalarFieldEnum | CharactersScalarFieldEnum[]
  }

  /**
   * clans.clan_banes
   */
  export type clans$clan_banesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clan_banes
     */
    select?: clan_banesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clan_banes
     */
    omit?: clan_banesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clan_banesInclude<ExtArgs> | null
    where?: clan_banesWhereInput
    orderBy?: clan_banesOrderByWithRelationInput | clan_banesOrderByWithRelationInput[]
    cursor?: clan_banesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Clan_banesScalarFieldEnum | Clan_banesScalarFieldEnum[]
  }

  /**
   * clans.clan_compulsions
   */
  export type clans$clan_compulsionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clan_compulsions
     */
    select?: clan_compulsionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clan_compulsions
     */
    omit?: clan_compulsionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clan_compulsionsInclude<ExtArgs> | null
    where?: clan_compulsionsWhereInput
    orderBy?: clan_compulsionsOrderByWithRelationInput | clan_compulsionsOrderByWithRelationInput[]
    cursor?: clan_compulsionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Clan_compulsionsScalarFieldEnum | Clan_compulsionsScalarFieldEnum[]
  }

  /**
   * clans without action
   */
  export type clansDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the clans
     */
    select?: clansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the clans
     */
    omit?: clansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: clansInclude<ExtArgs> | null
  }


  /**
   * Model discipline_powers
   */

  export type AggregateDiscipline_powers = {
    _count: Discipline_powersCountAggregateOutputType | null
    _avg: Discipline_powersAvgAggregateOutputType | null
    _sum: Discipline_powersSumAggregateOutputType | null
    _min: Discipline_powersMinAggregateOutputType | null
    _max: Discipline_powersMaxAggregateOutputType | null
  }

  export type Discipline_powersAvgAggregateOutputType = {
    level: number | null
  }

  export type Discipline_powersSumAggregateOutputType = {
    level: number | null
  }

  export type Discipline_powersMinAggregateOutputType = {
    id: string | null
    discipline_id: string | null
    name: string | null
    level: number | null
    description: string | null
    dice_pool: string | null
    cost: string | null
    prerequisites: string | null
    amalgam: string | null
    system: string | null
    duration: string | null
  }

  export type Discipline_powersMaxAggregateOutputType = {
    id: string | null
    discipline_id: string | null
    name: string | null
    level: number | null
    description: string | null
    dice_pool: string | null
    cost: string | null
    prerequisites: string | null
    amalgam: string | null
    system: string | null
    duration: string | null
  }

  export type Discipline_powersCountAggregateOutputType = {
    id: number
    discipline_id: number
    name: number
    level: number
    description: number
    dice_pool: number
    cost: number
    prerequisites: number
    amalgam: number
    system: number
    duration: number
    _all: number
  }


  export type Discipline_powersAvgAggregateInputType = {
    level?: true
  }

  export type Discipline_powersSumAggregateInputType = {
    level?: true
  }

  export type Discipline_powersMinAggregateInputType = {
    id?: true
    discipline_id?: true
    name?: true
    level?: true
    description?: true
    dice_pool?: true
    cost?: true
    prerequisites?: true
    amalgam?: true
    system?: true
    duration?: true
  }

  export type Discipline_powersMaxAggregateInputType = {
    id?: true
    discipline_id?: true
    name?: true
    level?: true
    description?: true
    dice_pool?: true
    cost?: true
    prerequisites?: true
    amalgam?: true
    system?: true
    duration?: true
  }

  export type Discipline_powersCountAggregateInputType = {
    id?: true
    discipline_id?: true
    name?: true
    level?: true
    description?: true
    dice_pool?: true
    cost?: true
    prerequisites?: true
    amalgam?: true
    system?: true
    duration?: true
    _all?: true
  }

  export type Discipline_powersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which discipline_powers to aggregate.
     */
    where?: discipline_powersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of discipline_powers to fetch.
     */
    orderBy?: discipline_powersOrderByWithRelationInput | discipline_powersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: discipline_powersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` discipline_powers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` discipline_powers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned discipline_powers
    **/
    _count?: true | Discipline_powersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Discipline_powersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Discipline_powersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Discipline_powersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Discipline_powersMaxAggregateInputType
  }

  export type GetDiscipline_powersAggregateType<T extends Discipline_powersAggregateArgs> = {
        [P in keyof T & keyof AggregateDiscipline_powers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiscipline_powers[P]>
      : GetScalarType<T[P], AggregateDiscipline_powers[P]>
  }




  export type discipline_powersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: discipline_powersWhereInput
    orderBy?: discipline_powersOrderByWithAggregationInput | discipline_powersOrderByWithAggregationInput[]
    by: Discipline_powersScalarFieldEnum[] | Discipline_powersScalarFieldEnum
    having?: discipline_powersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Discipline_powersCountAggregateInputType | true
    _avg?: Discipline_powersAvgAggregateInputType
    _sum?: Discipline_powersSumAggregateInputType
    _min?: Discipline_powersMinAggregateInputType
    _max?: Discipline_powersMaxAggregateInputType
  }

  export type Discipline_powersGroupByOutputType = {
    id: string
    discipline_id: string
    name: string
    level: number
    description: string
    dice_pool: string
    cost: string
    prerequisites: string
    amalgam: string
    system: string
    duration: string
    _count: Discipline_powersCountAggregateOutputType | null
    _avg: Discipline_powersAvgAggregateOutputType | null
    _sum: Discipline_powersSumAggregateOutputType | null
    _min: Discipline_powersMinAggregateOutputType | null
    _max: Discipline_powersMaxAggregateOutputType | null
  }

  type GetDiscipline_powersGroupByPayload<T extends discipline_powersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Discipline_powersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Discipline_powersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Discipline_powersGroupByOutputType[P]>
            : GetScalarType<T[P], Discipline_powersGroupByOutputType[P]>
        }
      >
    >


  export type discipline_powersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    discipline_id?: boolean
    name?: boolean
    level?: boolean
    description?: boolean
    dice_pool?: boolean
    cost?: boolean
    prerequisites?: boolean
    amalgam?: boolean
    system?: boolean
    duration?: boolean
    character_discipline_powers?: boolean | discipline_powers$character_discipline_powersArgs<ExtArgs>
    disciplines?: boolean | disciplinesDefaultArgs<ExtArgs>
    _count?: boolean | Discipline_powersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["discipline_powers"]>

  export type discipline_powersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    discipline_id?: boolean
    name?: boolean
    level?: boolean
    description?: boolean
    dice_pool?: boolean
    cost?: boolean
    prerequisites?: boolean
    amalgam?: boolean
    system?: boolean
    duration?: boolean
    disciplines?: boolean | disciplinesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["discipline_powers"]>

  export type discipline_powersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    discipline_id?: boolean
    name?: boolean
    level?: boolean
    description?: boolean
    dice_pool?: boolean
    cost?: boolean
    prerequisites?: boolean
    amalgam?: boolean
    system?: boolean
    duration?: boolean
    disciplines?: boolean | disciplinesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["discipline_powers"]>

  export type discipline_powersSelectScalar = {
    id?: boolean
    discipline_id?: boolean
    name?: boolean
    level?: boolean
    description?: boolean
    dice_pool?: boolean
    cost?: boolean
    prerequisites?: boolean
    amalgam?: boolean
    system?: boolean
    duration?: boolean
  }

  export type discipline_powersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "discipline_id" | "name" | "level" | "description" | "dice_pool" | "cost" | "prerequisites" | "amalgam" | "system" | "duration", ExtArgs["result"]["discipline_powers"]>
  export type discipline_powersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character_discipline_powers?: boolean | discipline_powers$character_discipline_powersArgs<ExtArgs>
    disciplines?: boolean | disciplinesDefaultArgs<ExtArgs>
    _count?: boolean | Discipline_powersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type discipline_powersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    disciplines?: boolean | disciplinesDefaultArgs<ExtArgs>
  }
  export type discipline_powersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    disciplines?: boolean | disciplinesDefaultArgs<ExtArgs>
  }

  export type $discipline_powersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "discipline_powers"
    objects: {
      character_discipline_powers: Prisma.$character_discipline_powersPayload<ExtArgs>[]
      disciplines: Prisma.$disciplinesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      discipline_id: string
      name: string
      level: number
      description: string
      dice_pool: string
      cost: string
      prerequisites: string
      amalgam: string
      system: string
      duration: string
    }, ExtArgs["result"]["discipline_powers"]>
    composites: {}
  }

  type discipline_powersGetPayload<S extends boolean | null | undefined | discipline_powersDefaultArgs> = $Result.GetResult<Prisma.$discipline_powersPayload, S>

  type discipline_powersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<discipline_powersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Discipline_powersCountAggregateInputType | true
    }

  export interface discipline_powersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['discipline_powers'], meta: { name: 'discipline_powers' } }
    /**
     * Find zero or one Discipline_powers that matches the filter.
     * @param {discipline_powersFindUniqueArgs} args - Arguments to find a Discipline_powers
     * @example
     * // Get one Discipline_powers
     * const discipline_powers = await prisma.discipline_powers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends discipline_powersFindUniqueArgs>(args: SelectSubset<T, discipline_powersFindUniqueArgs<ExtArgs>>): Prisma__discipline_powersClient<$Result.GetResult<Prisma.$discipline_powersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Discipline_powers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {discipline_powersFindUniqueOrThrowArgs} args - Arguments to find a Discipline_powers
     * @example
     * // Get one Discipline_powers
     * const discipline_powers = await prisma.discipline_powers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends discipline_powersFindUniqueOrThrowArgs>(args: SelectSubset<T, discipline_powersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__discipline_powersClient<$Result.GetResult<Prisma.$discipline_powersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Discipline_powers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {discipline_powersFindFirstArgs} args - Arguments to find a Discipline_powers
     * @example
     * // Get one Discipline_powers
     * const discipline_powers = await prisma.discipline_powers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends discipline_powersFindFirstArgs>(args?: SelectSubset<T, discipline_powersFindFirstArgs<ExtArgs>>): Prisma__discipline_powersClient<$Result.GetResult<Prisma.$discipline_powersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Discipline_powers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {discipline_powersFindFirstOrThrowArgs} args - Arguments to find a Discipline_powers
     * @example
     * // Get one Discipline_powers
     * const discipline_powers = await prisma.discipline_powers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends discipline_powersFindFirstOrThrowArgs>(args?: SelectSubset<T, discipline_powersFindFirstOrThrowArgs<ExtArgs>>): Prisma__discipline_powersClient<$Result.GetResult<Prisma.$discipline_powersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Discipline_powers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {discipline_powersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Discipline_powers
     * const discipline_powers = await prisma.discipline_powers.findMany()
     * 
     * // Get first 10 Discipline_powers
     * const discipline_powers = await prisma.discipline_powers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const discipline_powersWithIdOnly = await prisma.discipline_powers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends discipline_powersFindManyArgs>(args?: SelectSubset<T, discipline_powersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$discipline_powersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Discipline_powers.
     * @param {discipline_powersCreateArgs} args - Arguments to create a Discipline_powers.
     * @example
     * // Create one Discipline_powers
     * const Discipline_powers = await prisma.discipline_powers.create({
     *   data: {
     *     // ... data to create a Discipline_powers
     *   }
     * })
     * 
     */
    create<T extends discipline_powersCreateArgs>(args: SelectSubset<T, discipline_powersCreateArgs<ExtArgs>>): Prisma__discipline_powersClient<$Result.GetResult<Prisma.$discipline_powersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Discipline_powers.
     * @param {discipline_powersCreateManyArgs} args - Arguments to create many Discipline_powers.
     * @example
     * // Create many Discipline_powers
     * const discipline_powers = await prisma.discipline_powers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends discipline_powersCreateManyArgs>(args?: SelectSubset<T, discipline_powersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Discipline_powers and returns the data saved in the database.
     * @param {discipline_powersCreateManyAndReturnArgs} args - Arguments to create many Discipline_powers.
     * @example
     * // Create many Discipline_powers
     * const discipline_powers = await prisma.discipline_powers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Discipline_powers and only return the `id`
     * const discipline_powersWithIdOnly = await prisma.discipline_powers.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends discipline_powersCreateManyAndReturnArgs>(args?: SelectSubset<T, discipline_powersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$discipline_powersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Discipline_powers.
     * @param {discipline_powersDeleteArgs} args - Arguments to delete one Discipline_powers.
     * @example
     * // Delete one Discipline_powers
     * const Discipline_powers = await prisma.discipline_powers.delete({
     *   where: {
     *     // ... filter to delete one Discipline_powers
     *   }
     * })
     * 
     */
    delete<T extends discipline_powersDeleteArgs>(args: SelectSubset<T, discipline_powersDeleteArgs<ExtArgs>>): Prisma__discipline_powersClient<$Result.GetResult<Prisma.$discipline_powersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Discipline_powers.
     * @param {discipline_powersUpdateArgs} args - Arguments to update one Discipline_powers.
     * @example
     * // Update one Discipline_powers
     * const discipline_powers = await prisma.discipline_powers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends discipline_powersUpdateArgs>(args: SelectSubset<T, discipline_powersUpdateArgs<ExtArgs>>): Prisma__discipline_powersClient<$Result.GetResult<Prisma.$discipline_powersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Discipline_powers.
     * @param {discipline_powersDeleteManyArgs} args - Arguments to filter Discipline_powers to delete.
     * @example
     * // Delete a few Discipline_powers
     * const { count } = await prisma.discipline_powers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends discipline_powersDeleteManyArgs>(args?: SelectSubset<T, discipline_powersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Discipline_powers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {discipline_powersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Discipline_powers
     * const discipline_powers = await prisma.discipline_powers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends discipline_powersUpdateManyArgs>(args: SelectSubset<T, discipline_powersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Discipline_powers and returns the data updated in the database.
     * @param {discipline_powersUpdateManyAndReturnArgs} args - Arguments to update many Discipline_powers.
     * @example
     * // Update many Discipline_powers
     * const discipline_powers = await prisma.discipline_powers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Discipline_powers and only return the `id`
     * const discipline_powersWithIdOnly = await prisma.discipline_powers.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends discipline_powersUpdateManyAndReturnArgs>(args: SelectSubset<T, discipline_powersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$discipline_powersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Discipline_powers.
     * @param {discipline_powersUpsertArgs} args - Arguments to update or create a Discipline_powers.
     * @example
     * // Update or create a Discipline_powers
     * const discipline_powers = await prisma.discipline_powers.upsert({
     *   create: {
     *     // ... data to create a Discipline_powers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Discipline_powers we want to update
     *   }
     * })
     */
    upsert<T extends discipline_powersUpsertArgs>(args: SelectSubset<T, discipline_powersUpsertArgs<ExtArgs>>): Prisma__discipline_powersClient<$Result.GetResult<Prisma.$discipline_powersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Discipline_powers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {discipline_powersCountArgs} args - Arguments to filter Discipline_powers to count.
     * @example
     * // Count the number of Discipline_powers
     * const count = await prisma.discipline_powers.count({
     *   where: {
     *     // ... the filter for the Discipline_powers we want to count
     *   }
     * })
    **/
    count<T extends discipline_powersCountArgs>(
      args?: Subset<T, discipline_powersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Discipline_powersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Discipline_powers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Discipline_powersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Discipline_powersAggregateArgs>(args: Subset<T, Discipline_powersAggregateArgs>): Prisma.PrismaPromise<GetDiscipline_powersAggregateType<T>>

    /**
     * Group by Discipline_powers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {discipline_powersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends discipline_powersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: discipline_powersGroupByArgs['orderBy'] }
        : { orderBy?: discipline_powersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, discipline_powersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiscipline_powersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the discipline_powers model
   */
  readonly fields: discipline_powersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for discipline_powers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__discipline_powersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    character_discipline_powers<T extends discipline_powers$character_discipline_powersArgs<ExtArgs> = {}>(args?: Subset<T, discipline_powers$character_discipline_powersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_discipline_powersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    disciplines<T extends disciplinesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, disciplinesDefaultArgs<ExtArgs>>): Prisma__disciplinesClient<$Result.GetResult<Prisma.$disciplinesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the discipline_powers model
   */
  interface discipline_powersFieldRefs {
    readonly id: FieldRef<"discipline_powers", 'String'>
    readonly discipline_id: FieldRef<"discipline_powers", 'String'>
    readonly name: FieldRef<"discipline_powers", 'String'>
    readonly level: FieldRef<"discipline_powers", 'Int'>
    readonly description: FieldRef<"discipline_powers", 'String'>
    readonly dice_pool: FieldRef<"discipline_powers", 'String'>
    readonly cost: FieldRef<"discipline_powers", 'String'>
    readonly prerequisites: FieldRef<"discipline_powers", 'String'>
    readonly amalgam: FieldRef<"discipline_powers", 'String'>
    readonly system: FieldRef<"discipline_powers", 'String'>
    readonly duration: FieldRef<"discipline_powers", 'String'>
  }
    

  // Custom InputTypes
  /**
   * discipline_powers findUnique
   */
  export type discipline_powersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the discipline_powers
     */
    select?: discipline_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the discipline_powers
     */
    omit?: discipline_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: discipline_powersInclude<ExtArgs> | null
    /**
     * Filter, which discipline_powers to fetch.
     */
    where: discipline_powersWhereUniqueInput
  }

  /**
   * discipline_powers findUniqueOrThrow
   */
  export type discipline_powersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the discipline_powers
     */
    select?: discipline_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the discipline_powers
     */
    omit?: discipline_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: discipline_powersInclude<ExtArgs> | null
    /**
     * Filter, which discipline_powers to fetch.
     */
    where: discipline_powersWhereUniqueInput
  }

  /**
   * discipline_powers findFirst
   */
  export type discipline_powersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the discipline_powers
     */
    select?: discipline_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the discipline_powers
     */
    omit?: discipline_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: discipline_powersInclude<ExtArgs> | null
    /**
     * Filter, which discipline_powers to fetch.
     */
    where?: discipline_powersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of discipline_powers to fetch.
     */
    orderBy?: discipline_powersOrderByWithRelationInput | discipline_powersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for discipline_powers.
     */
    cursor?: discipline_powersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` discipline_powers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` discipline_powers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of discipline_powers.
     */
    distinct?: Discipline_powersScalarFieldEnum | Discipline_powersScalarFieldEnum[]
  }

  /**
   * discipline_powers findFirstOrThrow
   */
  export type discipline_powersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the discipline_powers
     */
    select?: discipline_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the discipline_powers
     */
    omit?: discipline_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: discipline_powersInclude<ExtArgs> | null
    /**
     * Filter, which discipline_powers to fetch.
     */
    where?: discipline_powersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of discipline_powers to fetch.
     */
    orderBy?: discipline_powersOrderByWithRelationInput | discipline_powersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for discipline_powers.
     */
    cursor?: discipline_powersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` discipline_powers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` discipline_powers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of discipline_powers.
     */
    distinct?: Discipline_powersScalarFieldEnum | Discipline_powersScalarFieldEnum[]
  }

  /**
   * discipline_powers findMany
   */
  export type discipline_powersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the discipline_powers
     */
    select?: discipline_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the discipline_powers
     */
    omit?: discipline_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: discipline_powersInclude<ExtArgs> | null
    /**
     * Filter, which discipline_powers to fetch.
     */
    where?: discipline_powersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of discipline_powers to fetch.
     */
    orderBy?: discipline_powersOrderByWithRelationInput | discipline_powersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing discipline_powers.
     */
    cursor?: discipline_powersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` discipline_powers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` discipline_powers.
     */
    skip?: number
    distinct?: Discipline_powersScalarFieldEnum | Discipline_powersScalarFieldEnum[]
  }

  /**
   * discipline_powers create
   */
  export type discipline_powersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the discipline_powers
     */
    select?: discipline_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the discipline_powers
     */
    omit?: discipline_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: discipline_powersInclude<ExtArgs> | null
    /**
     * The data needed to create a discipline_powers.
     */
    data: XOR<discipline_powersCreateInput, discipline_powersUncheckedCreateInput>
  }

  /**
   * discipline_powers createMany
   */
  export type discipline_powersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many discipline_powers.
     */
    data: discipline_powersCreateManyInput | discipline_powersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * discipline_powers createManyAndReturn
   */
  export type discipline_powersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the discipline_powers
     */
    select?: discipline_powersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the discipline_powers
     */
    omit?: discipline_powersOmit<ExtArgs> | null
    /**
     * The data used to create many discipline_powers.
     */
    data: discipline_powersCreateManyInput | discipline_powersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: discipline_powersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * discipline_powers update
   */
  export type discipline_powersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the discipline_powers
     */
    select?: discipline_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the discipline_powers
     */
    omit?: discipline_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: discipline_powersInclude<ExtArgs> | null
    /**
     * The data needed to update a discipline_powers.
     */
    data: XOR<discipline_powersUpdateInput, discipline_powersUncheckedUpdateInput>
    /**
     * Choose, which discipline_powers to update.
     */
    where: discipline_powersWhereUniqueInput
  }

  /**
   * discipline_powers updateMany
   */
  export type discipline_powersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update discipline_powers.
     */
    data: XOR<discipline_powersUpdateManyMutationInput, discipline_powersUncheckedUpdateManyInput>
    /**
     * Filter which discipline_powers to update
     */
    where?: discipline_powersWhereInput
    /**
     * Limit how many discipline_powers to update.
     */
    limit?: number
  }

  /**
   * discipline_powers updateManyAndReturn
   */
  export type discipline_powersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the discipline_powers
     */
    select?: discipline_powersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the discipline_powers
     */
    omit?: discipline_powersOmit<ExtArgs> | null
    /**
     * The data used to update discipline_powers.
     */
    data: XOR<discipline_powersUpdateManyMutationInput, discipline_powersUncheckedUpdateManyInput>
    /**
     * Filter which discipline_powers to update
     */
    where?: discipline_powersWhereInput
    /**
     * Limit how many discipline_powers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: discipline_powersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * discipline_powers upsert
   */
  export type discipline_powersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the discipline_powers
     */
    select?: discipline_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the discipline_powers
     */
    omit?: discipline_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: discipline_powersInclude<ExtArgs> | null
    /**
     * The filter to search for the discipline_powers to update in case it exists.
     */
    where: discipline_powersWhereUniqueInput
    /**
     * In case the discipline_powers found by the `where` argument doesn't exist, create a new discipline_powers with this data.
     */
    create: XOR<discipline_powersCreateInput, discipline_powersUncheckedCreateInput>
    /**
     * In case the discipline_powers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<discipline_powersUpdateInput, discipline_powersUncheckedUpdateInput>
  }

  /**
   * discipline_powers delete
   */
  export type discipline_powersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the discipline_powers
     */
    select?: discipline_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the discipline_powers
     */
    omit?: discipline_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: discipline_powersInclude<ExtArgs> | null
    /**
     * Filter which discipline_powers to delete.
     */
    where: discipline_powersWhereUniqueInput
  }

  /**
   * discipline_powers deleteMany
   */
  export type discipline_powersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which discipline_powers to delete
     */
    where?: discipline_powersWhereInput
    /**
     * Limit how many discipline_powers to delete.
     */
    limit?: number
  }

  /**
   * discipline_powers.character_discipline_powers
   */
  export type discipline_powers$character_discipline_powersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_discipline_powers
     */
    select?: character_discipline_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_discipline_powers
     */
    omit?: character_discipline_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_discipline_powersInclude<ExtArgs> | null
    where?: character_discipline_powersWhereInput
    orderBy?: character_discipline_powersOrderByWithRelationInput | character_discipline_powersOrderByWithRelationInput[]
    cursor?: character_discipline_powersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Character_discipline_powersScalarFieldEnum | Character_discipline_powersScalarFieldEnum[]
  }

  /**
   * discipline_powers without action
   */
  export type discipline_powersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the discipline_powers
     */
    select?: discipline_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the discipline_powers
     */
    omit?: discipline_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: discipline_powersInclude<ExtArgs> | null
  }


  /**
   * Model disciplines
   */

  export type AggregateDisciplines = {
    _count: DisciplinesCountAggregateOutputType | null
    _min: DisciplinesMinAggregateOutputType | null
    _max: DisciplinesMaxAggregateOutputType | null
  }

  export type DisciplinesMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    nicknames: string | null
    characteristics: string | null
    type: string | null
    masquerade_threat: string | null
    blood_resonance: string | null
  }

  export type DisciplinesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    nicknames: string | null
    characteristics: string | null
    type: string | null
    masquerade_threat: string | null
    blood_resonance: string | null
  }

  export type DisciplinesCountAggregateOutputType = {
    id: number
    name: number
    description: number
    nicknames: number
    characteristics: number
    type: number
    masquerade_threat: number
    blood_resonance: number
    _all: number
  }


  export type DisciplinesMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    nicknames?: true
    characteristics?: true
    type?: true
    masquerade_threat?: true
    blood_resonance?: true
  }

  export type DisciplinesMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    nicknames?: true
    characteristics?: true
    type?: true
    masquerade_threat?: true
    blood_resonance?: true
  }

  export type DisciplinesCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    nicknames?: true
    characteristics?: true
    type?: true
    masquerade_threat?: true
    blood_resonance?: true
    _all?: true
  }

  export type DisciplinesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which disciplines to aggregate.
     */
    where?: disciplinesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of disciplines to fetch.
     */
    orderBy?: disciplinesOrderByWithRelationInput | disciplinesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: disciplinesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` disciplines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` disciplines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned disciplines
    **/
    _count?: true | DisciplinesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DisciplinesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DisciplinesMaxAggregateInputType
  }

  export type GetDisciplinesAggregateType<T extends DisciplinesAggregateArgs> = {
        [P in keyof T & keyof AggregateDisciplines]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDisciplines[P]>
      : GetScalarType<T[P], AggregateDisciplines[P]>
  }




  export type disciplinesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: disciplinesWhereInput
    orderBy?: disciplinesOrderByWithAggregationInput | disciplinesOrderByWithAggregationInput[]
    by: DisciplinesScalarFieldEnum[] | DisciplinesScalarFieldEnum
    having?: disciplinesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DisciplinesCountAggregateInputType | true
    _min?: DisciplinesMinAggregateInputType
    _max?: DisciplinesMaxAggregateInputType
  }

  export type DisciplinesGroupByOutputType = {
    id: string
    name: string
    description: string
    nicknames: string
    characteristics: string
    type: string
    masquerade_threat: string
    blood_resonance: string
    _count: DisciplinesCountAggregateOutputType | null
    _min: DisciplinesMinAggregateOutputType | null
    _max: DisciplinesMaxAggregateOutputType | null
  }

  type GetDisciplinesGroupByPayload<T extends disciplinesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DisciplinesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DisciplinesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DisciplinesGroupByOutputType[P]>
            : GetScalarType<T[P], DisciplinesGroupByOutputType[P]>
        }
      >
    >


  export type disciplinesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    nicknames?: boolean
    characteristics?: boolean
    type?: boolean
    masquerade_threat?: boolean
    blood_resonance?: boolean
    character_disciplines?: boolean | disciplines$character_disciplinesArgs<ExtArgs>
    discipline_powers?: boolean | disciplines$discipline_powersArgs<ExtArgs>
    _count?: boolean | DisciplinesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disciplines"]>

  export type disciplinesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    nicknames?: boolean
    characteristics?: boolean
    type?: boolean
    masquerade_threat?: boolean
    blood_resonance?: boolean
  }, ExtArgs["result"]["disciplines"]>

  export type disciplinesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    nicknames?: boolean
    characteristics?: boolean
    type?: boolean
    masquerade_threat?: boolean
    blood_resonance?: boolean
  }, ExtArgs["result"]["disciplines"]>

  export type disciplinesSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    nicknames?: boolean
    characteristics?: boolean
    type?: boolean
    masquerade_threat?: boolean
    blood_resonance?: boolean
  }

  export type disciplinesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "nicknames" | "characteristics" | "type" | "masquerade_threat" | "blood_resonance", ExtArgs["result"]["disciplines"]>
  export type disciplinesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character_disciplines?: boolean | disciplines$character_disciplinesArgs<ExtArgs>
    discipline_powers?: boolean | disciplines$discipline_powersArgs<ExtArgs>
    _count?: boolean | DisciplinesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type disciplinesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type disciplinesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $disciplinesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "disciplines"
    objects: {
      character_disciplines: Prisma.$character_disciplinesPayload<ExtArgs>[]
      discipline_powers: Prisma.$discipline_powersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      nicknames: string
      characteristics: string
      type: string
      masquerade_threat: string
      blood_resonance: string
    }, ExtArgs["result"]["disciplines"]>
    composites: {}
  }

  type disciplinesGetPayload<S extends boolean | null | undefined | disciplinesDefaultArgs> = $Result.GetResult<Prisma.$disciplinesPayload, S>

  type disciplinesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<disciplinesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DisciplinesCountAggregateInputType | true
    }

  export interface disciplinesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['disciplines'], meta: { name: 'disciplines' } }
    /**
     * Find zero or one Disciplines that matches the filter.
     * @param {disciplinesFindUniqueArgs} args - Arguments to find a Disciplines
     * @example
     * // Get one Disciplines
     * const disciplines = await prisma.disciplines.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends disciplinesFindUniqueArgs>(args: SelectSubset<T, disciplinesFindUniqueArgs<ExtArgs>>): Prisma__disciplinesClient<$Result.GetResult<Prisma.$disciplinesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Disciplines that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {disciplinesFindUniqueOrThrowArgs} args - Arguments to find a Disciplines
     * @example
     * // Get one Disciplines
     * const disciplines = await prisma.disciplines.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends disciplinesFindUniqueOrThrowArgs>(args: SelectSubset<T, disciplinesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__disciplinesClient<$Result.GetResult<Prisma.$disciplinesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Disciplines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {disciplinesFindFirstArgs} args - Arguments to find a Disciplines
     * @example
     * // Get one Disciplines
     * const disciplines = await prisma.disciplines.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends disciplinesFindFirstArgs>(args?: SelectSubset<T, disciplinesFindFirstArgs<ExtArgs>>): Prisma__disciplinesClient<$Result.GetResult<Prisma.$disciplinesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Disciplines that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {disciplinesFindFirstOrThrowArgs} args - Arguments to find a Disciplines
     * @example
     * // Get one Disciplines
     * const disciplines = await prisma.disciplines.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends disciplinesFindFirstOrThrowArgs>(args?: SelectSubset<T, disciplinesFindFirstOrThrowArgs<ExtArgs>>): Prisma__disciplinesClient<$Result.GetResult<Prisma.$disciplinesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Disciplines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {disciplinesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Disciplines
     * const disciplines = await prisma.disciplines.findMany()
     * 
     * // Get first 10 Disciplines
     * const disciplines = await prisma.disciplines.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const disciplinesWithIdOnly = await prisma.disciplines.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends disciplinesFindManyArgs>(args?: SelectSubset<T, disciplinesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$disciplinesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Disciplines.
     * @param {disciplinesCreateArgs} args - Arguments to create a Disciplines.
     * @example
     * // Create one Disciplines
     * const Disciplines = await prisma.disciplines.create({
     *   data: {
     *     // ... data to create a Disciplines
     *   }
     * })
     * 
     */
    create<T extends disciplinesCreateArgs>(args: SelectSubset<T, disciplinesCreateArgs<ExtArgs>>): Prisma__disciplinesClient<$Result.GetResult<Prisma.$disciplinesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Disciplines.
     * @param {disciplinesCreateManyArgs} args - Arguments to create many Disciplines.
     * @example
     * // Create many Disciplines
     * const disciplines = await prisma.disciplines.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends disciplinesCreateManyArgs>(args?: SelectSubset<T, disciplinesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Disciplines and returns the data saved in the database.
     * @param {disciplinesCreateManyAndReturnArgs} args - Arguments to create many Disciplines.
     * @example
     * // Create many Disciplines
     * const disciplines = await prisma.disciplines.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Disciplines and only return the `id`
     * const disciplinesWithIdOnly = await prisma.disciplines.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends disciplinesCreateManyAndReturnArgs>(args?: SelectSubset<T, disciplinesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$disciplinesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Disciplines.
     * @param {disciplinesDeleteArgs} args - Arguments to delete one Disciplines.
     * @example
     * // Delete one Disciplines
     * const Disciplines = await prisma.disciplines.delete({
     *   where: {
     *     // ... filter to delete one Disciplines
     *   }
     * })
     * 
     */
    delete<T extends disciplinesDeleteArgs>(args: SelectSubset<T, disciplinesDeleteArgs<ExtArgs>>): Prisma__disciplinesClient<$Result.GetResult<Prisma.$disciplinesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Disciplines.
     * @param {disciplinesUpdateArgs} args - Arguments to update one Disciplines.
     * @example
     * // Update one Disciplines
     * const disciplines = await prisma.disciplines.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends disciplinesUpdateArgs>(args: SelectSubset<T, disciplinesUpdateArgs<ExtArgs>>): Prisma__disciplinesClient<$Result.GetResult<Prisma.$disciplinesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Disciplines.
     * @param {disciplinesDeleteManyArgs} args - Arguments to filter Disciplines to delete.
     * @example
     * // Delete a few Disciplines
     * const { count } = await prisma.disciplines.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends disciplinesDeleteManyArgs>(args?: SelectSubset<T, disciplinesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Disciplines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {disciplinesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Disciplines
     * const disciplines = await prisma.disciplines.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends disciplinesUpdateManyArgs>(args: SelectSubset<T, disciplinesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Disciplines and returns the data updated in the database.
     * @param {disciplinesUpdateManyAndReturnArgs} args - Arguments to update many Disciplines.
     * @example
     * // Update many Disciplines
     * const disciplines = await prisma.disciplines.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Disciplines and only return the `id`
     * const disciplinesWithIdOnly = await prisma.disciplines.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends disciplinesUpdateManyAndReturnArgs>(args: SelectSubset<T, disciplinesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$disciplinesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Disciplines.
     * @param {disciplinesUpsertArgs} args - Arguments to update or create a Disciplines.
     * @example
     * // Update or create a Disciplines
     * const disciplines = await prisma.disciplines.upsert({
     *   create: {
     *     // ... data to create a Disciplines
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Disciplines we want to update
     *   }
     * })
     */
    upsert<T extends disciplinesUpsertArgs>(args: SelectSubset<T, disciplinesUpsertArgs<ExtArgs>>): Prisma__disciplinesClient<$Result.GetResult<Prisma.$disciplinesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Disciplines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {disciplinesCountArgs} args - Arguments to filter Disciplines to count.
     * @example
     * // Count the number of Disciplines
     * const count = await prisma.disciplines.count({
     *   where: {
     *     // ... the filter for the Disciplines we want to count
     *   }
     * })
    **/
    count<T extends disciplinesCountArgs>(
      args?: Subset<T, disciplinesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DisciplinesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Disciplines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisciplinesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DisciplinesAggregateArgs>(args: Subset<T, DisciplinesAggregateArgs>): Prisma.PrismaPromise<GetDisciplinesAggregateType<T>>

    /**
     * Group by Disciplines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {disciplinesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends disciplinesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: disciplinesGroupByArgs['orderBy'] }
        : { orderBy?: disciplinesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, disciplinesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDisciplinesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the disciplines model
   */
  readonly fields: disciplinesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for disciplines.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__disciplinesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    character_disciplines<T extends disciplines$character_disciplinesArgs<ExtArgs> = {}>(args?: Subset<T, disciplines$character_disciplinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_disciplinesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    discipline_powers<T extends disciplines$discipline_powersArgs<ExtArgs> = {}>(args?: Subset<T, disciplines$discipline_powersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$discipline_powersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the disciplines model
   */
  interface disciplinesFieldRefs {
    readonly id: FieldRef<"disciplines", 'String'>
    readonly name: FieldRef<"disciplines", 'String'>
    readonly description: FieldRef<"disciplines", 'String'>
    readonly nicknames: FieldRef<"disciplines", 'String'>
    readonly characteristics: FieldRef<"disciplines", 'String'>
    readonly type: FieldRef<"disciplines", 'String'>
    readonly masquerade_threat: FieldRef<"disciplines", 'String'>
    readonly blood_resonance: FieldRef<"disciplines", 'String'>
  }
    

  // Custom InputTypes
  /**
   * disciplines findUnique
   */
  export type disciplinesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disciplines
     */
    select?: disciplinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disciplines
     */
    omit?: disciplinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disciplinesInclude<ExtArgs> | null
    /**
     * Filter, which disciplines to fetch.
     */
    where: disciplinesWhereUniqueInput
  }

  /**
   * disciplines findUniqueOrThrow
   */
  export type disciplinesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disciplines
     */
    select?: disciplinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disciplines
     */
    omit?: disciplinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disciplinesInclude<ExtArgs> | null
    /**
     * Filter, which disciplines to fetch.
     */
    where: disciplinesWhereUniqueInput
  }

  /**
   * disciplines findFirst
   */
  export type disciplinesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disciplines
     */
    select?: disciplinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disciplines
     */
    omit?: disciplinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disciplinesInclude<ExtArgs> | null
    /**
     * Filter, which disciplines to fetch.
     */
    where?: disciplinesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of disciplines to fetch.
     */
    orderBy?: disciplinesOrderByWithRelationInput | disciplinesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for disciplines.
     */
    cursor?: disciplinesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` disciplines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` disciplines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of disciplines.
     */
    distinct?: DisciplinesScalarFieldEnum | DisciplinesScalarFieldEnum[]
  }

  /**
   * disciplines findFirstOrThrow
   */
  export type disciplinesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disciplines
     */
    select?: disciplinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disciplines
     */
    omit?: disciplinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disciplinesInclude<ExtArgs> | null
    /**
     * Filter, which disciplines to fetch.
     */
    where?: disciplinesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of disciplines to fetch.
     */
    orderBy?: disciplinesOrderByWithRelationInput | disciplinesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for disciplines.
     */
    cursor?: disciplinesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` disciplines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` disciplines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of disciplines.
     */
    distinct?: DisciplinesScalarFieldEnum | DisciplinesScalarFieldEnum[]
  }

  /**
   * disciplines findMany
   */
  export type disciplinesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disciplines
     */
    select?: disciplinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disciplines
     */
    omit?: disciplinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disciplinesInclude<ExtArgs> | null
    /**
     * Filter, which disciplines to fetch.
     */
    where?: disciplinesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of disciplines to fetch.
     */
    orderBy?: disciplinesOrderByWithRelationInput | disciplinesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing disciplines.
     */
    cursor?: disciplinesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` disciplines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` disciplines.
     */
    skip?: number
    distinct?: DisciplinesScalarFieldEnum | DisciplinesScalarFieldEnum[]
  }

  /**
   * disciplines create
   */
  export type disciplinesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disciplines
     */
    select?: disciplinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disciplines
     */
    omit?: disciplinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disciplinesInclude<ExtArgs> | null
    /**
     * The data needed to create a disciplines.
     */
    data: XOR<disciplinesCreateInput, disciplinesUncheckedCreateInput>
  }

  /**
   * disciplines createMany
   */
  export type disciplinesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many disciplines.
     */
    data: disciplinesCreateManyInput | disciplinesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * disciplines createManyAndReturn
   */
  export type disciplinesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disciplines
     */
    select?: disciplinesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the disciplines
     */
    omit?: disciplinesOmit<ExtArgs> | null
    /**
     * The data used to create many disciplines.
     */
    data: disciplinesCreateManyInput | disciplinesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * disciplines update
   */
  export type disciplinesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disciplines
     */
    select?: disciplinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disciplines
     */
    omit?: disciplinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disciplinesInclude<ExtArgs> | null
    /**
     * The data needed to update a disciplines.
     */
    data: XOR<disciplinesUpdateInput, disciplinesUncheckedUpdateInput>
    /**
     * Choose, which disciplines to update.
     */
    where: disciplinesWhereUniqueInput
  }

  /**
   * disciplines updateMany
   */
  export type disciplinesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update disciplines.
     */
    data: XOR<disciplinesUpdateManyMutationInput, disciplinesUncheckedUpdateManyInput>
    /**
     * Filter which disciplines to update
     */
    where?: disciplinesWhereInput
    /**
     * Limit how many disciplines to update.
     */
    limit?: number
  }

  /**
   * disciplines updateManyAndReturn
   */
  export type disciplinesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disciplines
     */
    select?: disciplinesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the disciplines
     */
    omit?: disciplinesOmit<ExtArgs> | null
    /**
     * The data used to update disciplines.
     */
    data: XOR<disciplinesUpdateManyMutationInput, disciplinesUncheckedUpdateManyInput>
    /**
     * Filter which disciplines to update
     */
    where?: disciplinesWhereInput
    /**
     * Limit how many disciplines to update.
     */
    limit?: number
  }

  /**
   * disciplines upsert
   */
  export type disciplinesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disciplines
     */
    select?: disciplinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disciplines
     */
    omit?: disciplinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disciplinesInclude<ExtArgs> | null
    /**
     * The filter to search for the disciplines to update in case it exists.
     */
    where: disciplinesWhereUniqueInput
    /**
     * In case the disciplines found by the `where` argument doesn't exist, create a new disciplines with this data.
     */
    create: XOR<disciplinesCreateInput, disciplinesUncheckedCreateInput>
    /**
     * In case the disciplines was found with the provided `where` argument, update it with this data.
     */
    update: XOR<disciplinesUpdateInput, disciplinesUncheckedUpdateInput>
  }

  /**
   * disciplines delete
   */
  export type disciplinesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disciplines
     */
    select?: disciplinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disciplines
     */
    omit?: disciplinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disciplinesInclude<ExtArgs> | null
    /**
     * Filter which disciplines to delete.
     */
    where: disciplinesWhereUniqueInput
  }

  /**
   * disciplines deleteMany
   */
  export type disciplinesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which disciplines to delete
     */
    where?: disciplinesWhereInput
    /**
     * Limit how many disciplines to delete.
     */
    limit?: number
  }

  /**
   * disciplines.character_disciplines
   */
  export type disciplines$character_disciplinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_disciplines
     */
    select?: character_disciplinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_disciplines
     */
    omit?: character_disciplinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_disciplinesInclude<ExtArgs> | null
    where?: character_disciplinesWhereInput
    orderBy?: character_disciplinesOrderByWithRelationInput | character_disciplinesOrderByWithRelationInput[]
    cursor?: character_disciplinesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Character_disciplinesScalarFieldEnum | Character_disciplinesScalarFieldEnum[]
  }

  /**
   * disciplines.discipline_powers
   */
  export type disciplines$discipline_powersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the discipline_powers
     */
    select?: discipline_powersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the discipline_powers
     */
    omit?: discipline_powersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: discipline_powersInclude<ExtArgs> | null
    where?: discipline_powersWhereInput
    orderBy?: discipline_powersOrderByWithRelationInput | discipline_powersOrderByWithRelationInput[]
    cursor?: discipline_powersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Discipline_powersScalarFieldEnum | Discipline_powersScalarFieldEnum[]
  }

  /**
   * disciplines without action
   */
  export type disciplinesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the disciplines
     */
    select?: disciplinesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the disciplines
     */
    omit?: disciplinesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: disciplinesInclude<ExtArgs> | null
  }


  /**
   * Model exp_logs
   */

  export type AggregateExp_logs = {
    _count: Exp_logsCountAggregateOutputType | null
    _avg: Exp_logsAvgAggregateOutputType | null
    _sum: Exp_logsSumAggregateOutputType | null
    _min: Exp_logsMinAggregateOutputType | null
    _max: Exp_logsMaxAggregateOutputType | null
  }

  export type Exp_logsAvgAggregateOutputType = {
    prev_level: number | null
    new_level: number | null
    expanditure: number | null
  }

  export type Exp_logsSumAggregateOutputType = {
    prev_level: number | null
    new_level: number | null
    expanditure: number | null
  }

  export type Exp_logsMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    char_id: string | null
    section: string | null
    name: string | null
    prev_level: number | null
    new_level: number | null
    expanditure: number | null
    created_at: Date | null
  }

  export type Exp_logsMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    char_id: string | null
    section: string | null
    name: string | null
    prev_level: number | null
    new_level: number | null
    expanditure: number | null
    created_at: Date | null
  }

  export type Exp_logsCountAggregateOutputType = {
    id: number
    user_id: number
    char_id: number
    section: number
    name: number
    prev_level: number
    new_level: number
    expanditure: number
    created_at: number
    _all: number
  }


  export type Exp_logsAvgAggregateInputType = {
    prev_level?: true
    new_level?: true
    expanditure?: true
  }

  export type Exp_logsSumAggregateInputType = {
    prev_level?: true
    new_level?: true
    expanditure?: true
  }

  export type Exp_logsMinAggregateInputType = {
    id?: true
    user_id?: true
    char_id?: true
    section?: true
    name?: true
    prev_level?: true
    new_level?: true
    expanditure?: true
    created_at?: true
  }

  export type Exp_logsMaxAggregateInputType = {
    id?: true
    user_id?: true
    char_id?: true
    section?: true
    name?: true
    prev_level?: true
    new_level?: true
    expanditure?: true
    created_at?: true
  }

  export type Exp_logsCountAggregateInputType = {
    id?: true
    user_id?: true
    char_id?: true
    section?: true
    name?: true
    prev_level?: true
    new_level?: true
    expanditure?: true
    created_at?: true
    _all?: true
  }

  export type Exp_logsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which exp_logs to aggregate.
     */
    where?: exp_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exp_logs to fetch.
     */
    orderBy?: exp_logsOrderByWithRelationInput | exp_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: exp_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exp_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exp_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned exp_logs
    **/
    _count?: true | Exp_logsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Exp_logsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Exp_logsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Exp_logsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Exp_logsMaxAggregateInputType
  }

  export type GetExp_logsAggregateType<T extends Exp_logsAggregateArgs> = {
        [P in keyof T & keyof AggregateExp_logs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExp_logs[P]>
      : GetScalarType<T[P], AggregateExp_logs[P]>
  }




  export type exp_logsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: exp_logsWhereInput
    orderBy?: exp_logsOrderByWithAggregationInput | exp_logsOrderByWithAggregationInput[]
    by: Exp_logsScalarFieldEnum[] | Exp_logsScalarFieldEnum
    having?: exp_logsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Exp_logsCountAggregateInputType | true
    _avg?: Exp_logsAvgAggregateInputType
    _sum?: Exp_logsSumAggregateInputType
    _min?: Exp_logsMinAggregateInputType
    _max?: Exp_logsMaxAggregateInputType
  }

  export type Exp_logsGroupByOutputType = {
    id: string
    user_id: string
    char_id: string
    section: string | null
    name: string | null
    prev_level: number | null
    new_level: number | null
    expanditure: number | null
    created_at: Date
    _count: Exp_logsCountAggregateOutputType | null
    _avg: Exp_logsAvgAggregateOutputType | null
    _sum: Exp_logsSumAggregateOutputType | null
    _min: Exp_logsMinAggregateOutputType | null
    _max: Exp_logsMaxAggregateOutputType | null
  }

  type GetExp_logsGroupByPayload<T extends exp_logsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Exp_logsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Exp_logsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Exp_logsGroupByOutputType[P]>
            : GetScalarType<T[P], Exp_logsGroupByOutputType[P]>
        }
      >
    >


  export type exp_logsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    char_id?: boolean
    section?: boolean
    name?: boolean
    prev_level?: boolean
    new_level?: boolean
    expanditure?: boolean
    created_at?: boolean
    characters?: boolean | charactersDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exp_logs"]>

  export type exp_logsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    char_id?: boolean
    section?: boolean
    name?: boolean
    prev_level?: boolean
    new_level?: boolean
    expanditure?: boolean
    created_at?: boolean
    characters?: boolean | charactersDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exp_logs"]>

  export type exp_logsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    char_id?: boolean
    section?: boolean
    name?: boolean
    prev_level?: boolean
    new_level?: boolean
    expanditure?: boolean
    created_at?: boolean
    characters?: boolean | charactersDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exp_logs"]>

  export type exp_logsSelectScalar = {
    id?: boolean
    user_id?: boolean
    char_id?: boolean
    section?: boolean
    name?: boolean
    prev_level?: boolean
    new_level?: boolean
    expanditure?: boolean
    created_at?: boolean
  }

  export type exp_logsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "char_id" | "section" | "name" | "prev_level" | "new_level" | "expanditure" | "created_at", ExtArgs["result"]["exp_logs"]>
  export type exp_logsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | charactersDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type exp_logsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | charactersDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type exp_logsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | charactersDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $exp_logsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "exp_logs"
    objects: {
      characters: Prisma.$charactersPayload<ExtArgs>
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      char_id: string
      section: string | null
      name: string | null
      prev_level: number | null
      new_level: number | null
      expanditure: number | null
      created_at: Date
    }, ExtArgs["result"]["exp_logs"]>
    composites: {}
  }

  type exp_logsGetPayload<S extends boolean | null | undefined | exp_logsDefaultArgs> = $Result.GetResult<Prisma.$exp_logsPayload, S>

  type exp_logsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<exp_logsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Exp_logsCountAggregateInputType | true
    }

  export interface exp_logsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['exp_logs'], meta: { name: 'exp_logs' } }
    /**
     * Find zero or one Exp_logs that matches the filter.
     * @param {exp_logsFindUniqueArgs} args - Arguments to find a Exp_logs
     * @example
     * // Get one Exp_logs
     * const exp_logs = await prisma.exp_logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends exp_logsFindUniqueArgs>(args: SelectSubset<T, exp_logsFindUniqueArgs<ExtArgs>>): Prisma__exp_logsClient<$Result.GetResult<Prisma.$exp_logsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Exp_logs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {exp_logsFindUniqueOrThrowArgs} args - Arguments to find a Exp_logs
     * @example
     * // Get one Exp_logs
     * const exp_logs = await prisma.exp_logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends exp_logsFindUniqueOrThrowArgs>(args: SelectSubset<T, exp_logsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__exp_logsClient<$Result.GetResult<Prisma.$exp_logsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exp_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exp_logsFindFirstArgs} args - Arguments to find a Exp_logs
     * @example
     * // Get one Exp_logs
     * const exp_logs = await prisma.exp_logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends exp_logsFindFirstArgs>(args?: SelectSubset<T, exp_logsFindFirstArgs<ExtArgs>>): Prisma__exp_logsClient<$Result.GetResult<Prisma.$exp_logsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exp_logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exp_logsFindFirstOrThrowArgs} args - Arguments to find a Exp_logs
     * @example
     * // Get one Exp_logs
     * const exp_logs = await prisma.exp_logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends exp_logsFindFirstOrThrowArgs>(args?: SelectSubset<T, exp_logsFindFirstOrThrowArgs<ExtArgs>>): Prisma__exp_logsClient<$Result.GetResult<Prisma.$exp_logsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Exp_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exp_logsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exp_logs
     * const exp_logs = await prisma.exp_logs.findMany()
     * 
     * // Get first 10 Exp_logs
     * const exp_logs = await prisma.exp_logs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exp_logsWithIdOnly = await prisma.exp_logs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends exp_logsFindManyArgs>(args?: SelectSubset<T, exp_logsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$exp_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Exp_logs.
     * @param {exp_logsCreateArgs} args - Arguments to create a Exp_logs.
     * @example
     * // Create one Exp_logs
     * const Exp_logs = await prisma.exp_logs.create({
     *   data: {
     *     // ... data to create a Exp_logs
     *   }
     * })
     * 
     */
    create<T extends exp_logsCreateArgs>(args: SelectSubset<T, exp_logsCreateArgs<ExtArgs>>): Prisma__exp_logsClient<$Result.GetResult<Prisma.$exp_logsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Exp_logs.
     * @param {exp_logsCreateManyArgs} args - Arguments to create many Exp_logs.
     * @example
     * // Create many Exp_logs
     * const exp_logs = await prisma.exp_logs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends exp_logsCreateManyArgs>(args?: SelectSubset<T, exp_logsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Exp_logs and returns the data saved in the database.
     * @param {exp_logsCreateManyAndReturnArgs} args - Arguments to create many Exp_logs.
     * @example
     * // Create many Exp_logs
     * const exp_logs = await prisma.exp_logs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Exp_logs and only return the `id`
     * const exp_logsWithIdOnly = await prisma.exp_logs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends exp_logsCreateManyAndReturnArgs>(args?: SelectSubset<T, exp_logsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$exp_logsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Exp_logs.
     * @param {exp_logsDeleteArgs} args - Arguments to delete one Exp_logs.
     * @example
     * // Delete one Exp_logs
     * const Exp_logs = await prisma.exp_logs.delete({
     *   where: {
     *     // ... filter to delete one Exp_logs
     *   }
     * })
     * 
     */
    delete<T extends exp_logsDeleteArgs>(args: SelectSubset<T, exp_logsDeleteArgs<ExtArgs>>): Prisma__exp_logsClient<$Result.GetResult<Prisma.$exp_logsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Exp_logs.
     * @param {exp_logsUpdateArgs} args - Arguments to update one Exp_logs.
     * @example
     * // Update one Exp_logs
     * const exp_logs = await prisma.exp_logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends exp_logsUpdateArgs>(args: SelectSubset<T, exp_logsUpdateArgs<ExtArgs>>): Prisma__exp_logsClient<$Result.GetResult<Prisma.$exp_logsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Exp_logs.
     * @param {exp_logsDeleteManyArgs} args - Arguments to filter Exp_logs to delete.
     * @example
     * // Delete a few Exp_logs
     * const { count } = await prisma.exp_logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends exp_logsDeleteManyArgs>(args?: SelectSubset<T, exp_logsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exp_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exp_logsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exp_logs
     * const exp_logs = await prisma.exp_logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends exp_logsUpdateManyArgs>(args: SelectSubset<T, exp_logsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exp_logs and returns the data updated in the database.
     * @param {exp_logsUpdateManyAndReturnArgs} args - Arguments to update many Exp_logs.
     * @example
     * // Update many Exp_logs
     * const exp_logs = await prisma.exp_logs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Exp_logs and only return the `id`
     * const exp_logsWithIdOnly = await prisma.exp_logs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends exp_logsUpdateManyAndReturnArgs>(args: SelectSubset<T, exp_logsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$exp_logsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Exp_logs.
     * @param {exp_logsUpsertArgs} args - Arguments to update or create a Exp_logs.
     * @example
     * // Update or create a Exp_logs
     * const exp_logs = await prisma.exp_logs.upsert({
     *   create: {
     *     // ... data to create a Exp_logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exp_logs we want to update
     *   }
     * })
     */
    upsert<T extends exp_logsUpsertArgs>(args: SelectSubset<T, exp_logsUpsertArgs<ExtArgs>>): Prisma__exp_logsClient<$Result.GetResult<Prisma.$exp_logsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Exp_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exp_logsCountArgs} args - Arguments to filter Exp_logs to count.
     * @example
     * // Count the number of Exp_logs
     * const count = await prisma.exp_logs.count({
     *   where: {
     *     // ... the filter for the Exp_logs we want to count
     *   }
     * })
    **/
    count<T extends exp_logsCountArgs>(
      args?: Subset<T, exp_logsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Exp_logsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exp_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Exp_logsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Exp_logsAggregateArgs>(args: Subset<T, Exp_logsAggregateArgs>): Prisma.PrismaPromise<GetExp_logsAggregateType<T>>

    /**
     * Group by Exp_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exp_logsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends exp_logsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: exp_logsGroupByArgs['orderBy'] }
        : { orderBy?: exp_logsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, exp_logsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExp_logsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the exp_logs model
   */
  readonly fields: exp_logsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for exp_logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__exp_logsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    characters<T extends charactersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, charactersDefaultArgs<ExtArgs>>): Prisma__charactersClient<$Result.GetResult<Prisma.$charactersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the exp_logs model
   */
  interface exp_logsFieldRefs {
    readonly id: FieldRef<"exp_logs", 'String'>
    readonly user_id: FieldRef<"exp_logs", 'String'>
    readonly char_id: FieldRef<"exp_logs", 'String'>
    readonly section: FieldRef<"exp_logs", 'String'>
    readonly name: FieldRef<"exp_logs", 'String'>
    readonly prev_level: FieldRef<"exp_logs", 'Int'>
    readonly new_level: FieldRef<"exp_logs", 'Int'>
    readonly expanditure: FieldRef<"exp_logs", 'Int'>
    readonly created_at: FieldRef<"exp_logs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * exp_logs findUnique
   */
  export type exp_logsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exp_logs
     */
    select?: exp_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exp_logs
     */
    omit?: exp_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exp_logsInclude<ExtArgs> | null
    /**
     * Filter, which exp_logs to fetch.
     */
    where: exp_logsWhereUniqueInput
  }

  /**
   * exp_logs findUniqueOrThrow
   */
  export type exp_logsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exp_logs
     */
    select?: exp_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exp_logs
     */
    omit?: exp_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exp_logsInclude<ExtArgs> | null
    /**
     * Filter, which exp_logs to fetch.
     */
    where: exp_logsWhereUniqueInput
  }

  /**
   * exp_logs findFirst
   */
  export type exp_logsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exp_logs
     */
    select?: exp_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exp_logs
     */
    omit?: exp_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exp_logsInclude<ExtArgs> | null
    /**
     * Filter, which exp_logs to fetch.
     */
    where?: exp_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exp_logs to fetch.
     */
    orderBy?: exp_logsOrderByWithRelationInput | exp_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for exp_logs.
     */
    cursor?: exp_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exp_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exp_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of exp_logs.
     */
    distinct?: Exp_logsScalarFieldEnum | Exp_logsScalarFieldEnum[]
  }

  /**
   * exp_logs findFirstOrThrow
   */
  export type exp_logsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exp_logs
     */
    select?: exp_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exp_logs
     */
    omit?: exp_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exp_logsInclude<ExtArgs> | null
    /**
     * Filter, which exp_logs to fetch.
     */
    where?: exp_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exp_logs to fetch.
     */
    orderBy?: exp_logsOrderByWithRelationInput | exp_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for exp_logs.
     */
    cursor?: exp_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exp_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exp_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of exp_logs.
     */
    distinct?: Exp_logsScalarFieldEnum | Exp_logsScalarFieldEnum[]
  }

  /**
   * exp_logs findMany
   */
  export type exp_logsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exp_logs
     */
    select?: exp_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exp_logs
     */
    omit?: exp_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exp_logsInclude<ExtArgs> | null
    /**
     * Filter, which exp_logs to fetch.
     */
    where?: exp_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exp_logs to fetch.
     */
    orderBy?: exp_logsOrderByWithRelationInput | exp_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing exp_logs.
     */
    cursor?: exp_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exp_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exp_logs.
     */
    skip?: number
    distinct?: Exp_logsScalarFieldEnum | Exp_logsScalarFieldEnum[]
  }

  /**
   * exp_logs create
   */
  export type exp_logsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exp_logs
     */
    select?: exp_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exp_logs
     */
    omit?: exp_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exp_logsInclude<ExtArgs> | null
    /**
     * The data needed to create a exp_logs.
     */
    data: XOR<exp_logsCreateInput, exp_logsUncheckedCreateInput>
  }

  /**
   * exp_logs createMany
   */
  export type exp_logsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many exp_logs.
     */
    data: exp_logsCreateManyInput | exp_logsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * exp_logs createManyAndReturn
   */
  export type exp_logsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exp_logs
     */
    select?: exp_logsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the exp_logs
     */
    omit?: exp_logsOmit<ExtArgs> | null
    /**
     * The data used to create many exp_logs.
     */
    data: exp_logsCreateManyInput | exp_logsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exp_logsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * exp_logs update
   */
  export type exp_logsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exp_logs
     */
    select?: exp_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exp_logs
     */
    omit?: exp_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exp_logsInclude<ExtArgs> | null
    /**
     * The data needed to update a exp_logs.
     */
    data: XOR<exp_logsUpdateInput, exp_logsUncheckedUpdateInput>
    /**
     * Choose, which exp_logs to update.
     */
    where: exp_logsWhereUniqueInput
  }

  /**
   * exp_logs updateMany
   */
  export type exp_logsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update exp_logs.
     */
    data: XOR<exp_logsUpdateManyMutationInput, exp_logsUncheckedUpdateManyInput>
    /**
     * Filter which exp_logs to update
     */
    where?: exp_logsWhereInput
    /**
     * Limit how many exp_logs to update.
     */
    limit?: number
  }

  /**
   * exp_logs updateManyAndReturn
   */
  export type exp_logsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exp_logs
     */
    select?: exp_logsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the exp_logs
     */
    omit?: exp_logsOmit<ExtArgs> | null
    /**
     * The data used to update exp_logs.
     */
    data: XOR<exp_logsUpdateManyMutationInput, exp_logsUncheckedUpdateManyInput>
    /**
     * Filter which exp_logs to update
     */
    where?: exp_logsWhereInput
    /**
     * Limit how many exp_logs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exp_logsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * exp_logs upsert
   */
  export type exp_logsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exp_logs
     */
    select?: exp_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exp_logs
     */
    omit?: exp_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exp_logsInclude<ExtArgs> | null
    /**
     * The filter to search for the exp_logs to update in case it exists.
     */
    where: exp_logsWhereUniqueInput
    /**
     * In case the exp_logs found by the `where` argument doesn't exist, create a new exp_logs with this data.
     */
    create: XOR<exp_logsCreateInput, exp_logsUncheckedCreateInput>
    /**
     * In case the exp_logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<exp_logsUpdateInput, exp_logsUncheckedUpdateInput>
  }

  /**
   * exp_logs delete
   */
  export type exp_logsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exp_logs
     */
    select?: exp_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exp_logs
     */
    omit?: exp_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exp_logsInclude<ExtArgs> | null
    /**
     * Filter which exp_logs to delete.
     */
    where: exp_logsWhereUniqueInput
  }

  /**
   * exp_logs deleteMany
   */
  export type exp_logsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which exp_logs to delete
     */
    where?: exp_logsWhereInput
    /**
     * Limit how many exp_logs to delete.
     */
    limit?: number
  }

  /**
   * exp_logs without action
   */
  export type exp_logsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exp_logs
     */
    select?: exp_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exp_logs
     */
    omit?: exp_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exp_logsInclude<ExtArgs> | null
  }


  /**
   * Model humanity
   */

  export type AggregateHumanity = {
    _count: HumanityCountAggregateOutputType | null
    _avg: HumanityAvgAggregateOutputType | null
    _sum: HumanitySumAggregateOutputType | null
    _min: HumanityMinAggregateOutputType | null
    _max: HumanityMaxAggregateOutputType | null
  }

  export type HumanityAvgAggregateOutputType = {
    level: number | null
  }

  export type HumanitySumAggregateOutputType = {
    level: number | null
  }

  export type HumanityMinAggregateOutputType = {
    id: string | null
    description: string | null
    level: number | null
  }

  export type HumanityMaxAggregateOutputType = {
    id: string | null
    description: string | null
    level: number | null
  }

  export type HumanityCountAggregateOutputType = {
    id: number
    description: number
    level: number
    _all: number
  }


  export type HumanityAvgAggregateInputType = {
    level?: true
  }

  export type HumanitySumAggregateInputType = {
    level?: true
  }

  export type HumanityMinAggregateInputType = {
    id?: true
    description?: true
    level?: true
  }

  export type HumanityMaxAggregateInputType = {
    id?: true
    description?: true
    level?: true
  }

  export type HumanityCountAggregateInputType = {
    id?: true
    description?: true
    level?: true
    _all?: true
  }

  export type HumanityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which humanity to aggregate.
     */
    where?: humanityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of humanities to fetch.
     */
    orderBy?: humanityOrderByWithRelationInput | humanityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: humanityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` humanities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` humanities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned humanities
    **/
    _count?: true | HumanityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HumanityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HumanitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HumanityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HumanityMaxAggregateInputType
  }

  export type GetHumanityAggregateType<T extends HumanityAggregateArgs> = {
        [P in keyof T & keyof AggregateHumanity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHumanity[P]>
      : GetScalarType<T[P], AggregateHumanity[P]>
  }




  export type humanityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: humanityWhereInput
    orderBy?: humanityOrderByWithAggregationInput | humanityOrderByWithAggregationInput[]
    by: HumanityScalarFieldEnum[] | HumanityScalarFieldEnum
    having?: humanityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HumanityCountAggregateInputType | true
    _avg?: HumanityAvgAggregateInputType
    _sum?: HumanitySumAggregateInputType
    _min?: HumanityMinAggregateInputType
    _max?: HumanityMaxAggregateInputType
  }

  export type HumanityGroupByOutputType = {
    id: string
    description: string
    level: number
    _count: HumanityCountAggregateOutputType | null
    _avg: HumanityAvgAggregateOutputType | null
    _sum: HumanitySumAggregateOutputType | null
    _min: HumanityMinAggregateOutputType | null
    _max: HumanityMaxAggregateOutputType | null
  }

  type GetHumanityGroupByPayload<T extends humanityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HumanityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HumanityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HumanityGroupByOutputType[P]>
            : GetScalarType<T[P], HumanityGroupByOutputType[P]>
        }
      >
    >


  export type humanitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    level?: boolean
  }, ExtArgs["result"]["humanity"]>

  export type humanitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    level?: boolean
  }, ExtArgs["result"]["humanity"]>

  export type humanitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    level?: boolean
  }, ExtArgs["result"]["humanity"]>

  export type humanitySelectScalar = {
    id?: boolean
    description?: boolean
    level?: boolean
  }

  export type humanityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "description" | "level", ExtArgs["result"]["humanity"]>

  export type $humanityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "humanity"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      description: string
      level: number
    }, ExtArgs["result"]["humanity"]>
    composites: {}
  }

  type humanityGetPayload<S extends boolean | null | undefined | humanityDefaultArgs> = $Result.GetResult<Prisma.$humanityPayload, S>

  type humanityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<humanityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HumanityCountAggregateInputType | true
    }

  export interface humanityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['humanity'], meta: { name: 'humanity' } }
    /**
     * Find zero or one Humanity that matches the filter.
     * @param {humanityFindUniqueArgs} args - Arguments to find a Humanity
     * @example
     * // Get one Humanity
     * const humanity = await prisma.humanity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends humanityFindUniqueArgs>(args: SelectSubset<T, humanityFindUniqueArgs<ExtArgs>>): Prisma__humanityClient<$Result.GetResult<Prisma.$humanityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Humanity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {humanityFindUniqueOrThrowArgs} args - Arguments to find a Humanity
     * @example
     * // Get one Humanity
     * const humanity = await prisma.humanity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends humanityFindUniqueOrThrowArgs>(args: SelectSubset<T, humanityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__humanityClient<$Result.GetResult<Prisma.$humanityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Humanity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {humanityFindFirstArgs} args - Arguments to find a Humanity
     * @example
     * // Get one Humanity
     * const humanity = await prisma.humanity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends humanityFindFirstArgs>(args?: SelectSubset<T, humanityFindFirstArgs<ExtArgs>>): Prisma__humanityClient<$Result.GetResult<Prisma.$humanityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Humanity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {humanityFindFirstOrThrowArgs} args - Arguments to find a Humanity
     * @example
     * // Get one Humanity
     * const humanity = await prisma.humanity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends humanityFindFirstOrThrowArgs>(args?: SelectSubset<T, humanityFindFirstOrThrowArgs<ExtArgs>>): Prisma__humanityClient<$Result.GetResult<Prisma.$humanityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Humanities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {humanityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Humanities
     * const humanities = await prisma.humanity.findMany()
     * 
     * // Get first 10 Humanities
     * const humanities = await prisma.humanity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const humanityWithIdOnly = await prisma.humanity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends humanityFindManyArgs>(args?: SelectSubset<T, humanityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$humanityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Humanity.
     * @param {humanityCreateArgs} args - Arguments to create a Humanity.
     * @example
     * // Create one Humanity
     * const Humanity = await prisma.humanity.create({
     *   data: {
     *     // ... data to create a Humanity
     *   }
     * })
     * 
     */
    create<T extends humanityCreateArgs>(args: SelectSubset<T, humanityCreateArgs<ExtArgs>>): Prisma__humanityClient<$Result.GetResult<Prisma.$humanityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Humanities.
     * @param {humanityCreateManyArgs} args - Arguments to create many Humanities.
     * @example
     * // Create many Humanities
     * const humanity = await prisma.humanity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends humanityCreateManyArgs>(args?: SelectSubset<T, humanityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Humanities and returns the data saved in the database.
     * @param {humanityCreateManyAndReturnArgs} args - Arguments to create many Humanities.
     * @example
     * // Create many Humanities
     * const humanity = await prisma.humanity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Humanities and only return the `id`
     * const humanityWithIdOnly = await prisma.humanity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends humanityCreateManyAndReturnArgs>(args?: SelectSubset<T, humanityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$humanityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Humanity.
     * @param {humanityDeleteArgs} args - Arguments to delete one Humanity.
     * @example
     * // Delete one Humanity
     * const Humanity = await prisma.humanity.delete({
     *   where: {
     *     // ... filter to delete one Humanity
     *   }
     * })
     * 
     */
    delete<T extends humanityDeleteArgs>(args: SelectSubset<T, humanityDeleteArgs<ExtArgs>>): Prisma__humanityClient<$Result.GetResult<Prisma.$humanityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Humanity.
     * @param {humanityUpdateArgs} args - Arguments to update one Humanity.
     * @example
     * // Update one Humanity
     * const humanity = await prisma.humanity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends humanityUpdateArgs>(args: SelectSubset<T, humanityUpdateArgs<ExtArgs>>): Prisma__humanityClient<$Result.GetResult<Prisma.$humanityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Humanities.
     * @param {humanityDeleteManyArgs} args - Arguments to filter Humanities to delete.
     * @example
     * // Delete a few Humanities
     * const { count } = await prisma.humanity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends humanityDeleteManyArgs>(args?: SelectSubset<T, humanityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Humanities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {humanityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Humanities
     * const humanity = await prisma.humanity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends humanityUpdateManyArgs>(args: SelectSubset<T, humanityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Humanities and returns the data updated in the database.
     * @param {humanityUpdateManyAndReturnArgs} args - Arguments to update many Humanities.
     * @example
     * // Update many Humanities
     * const humanity = await prisma.humanity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Humanities and only return the `id`
     * const humanityWithIdOnly = await prisma.humanity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends humanityUpdateManyAndReturnArgs>(args: SelectSubset<T, humanityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$humanityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Humanity.
     * @param {humanityUpsertArgs} args - Arguments to update or create a Humanity.
     * @example
     * // Update or create a Humanity
     * const humanity = await prisma.humanity.upsert({
     *   create: {
     *     // ... data to create a Humanity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Humanity we want to update
     *   }
     * })
     */
    upsert<T extends humanityUpsertArgs>(args: SelectSubset<T, humanityUpsertArgs<ExtArgs>>): Prisma__humanityClient<$Result.GetResult<Prisma.$humanityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Humanities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {humanityCountArgs} args - Arguments to filter Humanities to count.
     * @example
     * // Count the number of Humanities
     * const count = await prisma.humanity.count({
     *   where: {
     *     // ... the filter for the Humanities we want to count
     *   }
     * })
    **/
    count<T extends humanityCountArgs>(
      args?: Subset<T, humanityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HumanityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Humanity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HumanityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HumanityAggregateArgs>(args: Subset<T, HumanityAggregateArgs>): Prisma.PrismaPromise<GetHumanityAggregateType<T>>

    /**
     * Group by Humanity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {humanityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends humanityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: humanityGroupByArgs['orderBy'] }
        : { orderBy?: humanityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, humanityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHumanityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the humanity model
   */
  readonly fields: humanityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for humanity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__humanityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the humanity model
   */
  interface humanityFieldRefs {
    readonly id: FieldRef<"humanity", 'String'>
    readonly description: FieldRef<"humanity", 'String'>
    readonly level: FieldRef<"humanity", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * humanity findUnique
   */
  export type humanityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the humanity
     */
    select?: humanitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the humanity
     */
    omit?: humanityOmit<ExtArgs> | null
    /**
     * Filter, which humanity to fetch.
     */
    where: humanityWhereUniqueInput
  }

  /**
   * humanity findUniqueOrThrow
   */
  export type humanityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the humanity
     */
    select?: humanitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the humanity
     */
    omit?: humanityOmit<ExtArgs> | null
    /**
     * Filter, which humanity to fetch.
     */
    where: humanityWhereUniqueInput
  }

  /**
   * humanity findFirst
   */
  export type humanityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the humanity
     */
    select?: humanitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the humanity
     */
    omit?: humanityOmit<ExtArgs> | null
    /**
     * Filter, which humanity to fetch.
     */
    where?: humanityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of humanities to fetch.
     */
    orderBy?: humanityOrderByWithRelationInput | humanityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for humanities.
     */
    cursor?: humanityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` humanities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` humanities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of humanities.
     */
    distinct?: HumanityScalarFieldEnum | HumanityScalarFieldEnum[]
  }

  /**
   * humanity findFirstOrThrow
   */
  export type humanityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the humanity
     */
    select?: humanitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the humanity
     */
    omit?: humanityOmit<ExtArgs> | null
    /**
     * Filter, which humanity to fetch.
     */
    where?: humanityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of humanities to fetch.
     */
    orderBy?: humanityOrderByWithRelationInput | humanityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for humanities.
     */
    cursor?: humanityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` humanities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` humanities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of humanities.
     */
    distinct?: HumanityScalarFieldEnum | HumanityScalarFieldEnum[]
  }

  /**
   * humanity findMany
   */
  export type humanityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the humanity
     */
    select?: humanitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the humanity
     */
    omit?: humanityOmit<ExtArgs> | null
    /**
     * Filter, which humanities to fetch.
     */
    where?: humanityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of humanities to fetch.
     */
    orderBy?: humanityOrderByWithRelationInput | humanityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing humanities.
     */
    cursor?: humanityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` humanities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` humanities.
     */
    skip?: number
    distinct?: HumanityScalarFieldEnum | HumanityScalarFieldEnum[]
  }

  /**
   * humanity create
   */
  export type humanityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the humanity
     */
    select?: humanitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the humanity
     */
    omit?: humanityOmit<ExtArgs> | null
    /**
     * The data needed to create a humanity.
     */
    data: XOR<humanityCreateInput, humanityUncheckedCreateInput>
  }

  /**
   * humanity createMany
   */
  export type humanityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many humanities.
     */
    data: humanityCreateManyInput | humanityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * humanity createManyAndReturn
   */
  export type humanityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the humanity
     */
    select?: humanitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the humanity
     */
    omit?: humanityOmit<ExtArgs> | null
    /**
     * The data used to create many humanities.
     */
    data: humanityCreateManyInput | humanityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * humanity update
   */
  export type humanityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the humanity
     */
    select?: humanitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the humanity
     */
    omit?: humanityOmit<ExtArgs> | null
    /**
     * The data needed to update a humanity.
     */
    data: XOR<humanityUpdateInput, humanityUncheckedUpdateInput>
    /**
     * Choose, which humanity to update.
     */
    where: humanityWhereUniqueInput
  }

  /**
   * humanity updateMany
   */
  export type humanityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update humanities.
     */
    data: XOR<humanityUpdateManyMutationInput, humanityUncheckedUpdateManyInput>
    /**
     * Filter which humanities to update
     */
    where?: humanityWhereInput
    /**
     * Limit how many humanities to update.
     */
    limit?: number
  }

  /**
   * humanity updateManyAndReturn
   */
  export type humanityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the humanity
     */
    select?: humanitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the humanity
     */
    omit?: humanityOmit<ExtArgs> | null
    /**
     * The data used to update humanities.
     */
    data: XOR<humanityUpdateManyMutationInput, humanityUncheckedUpdateManyInput>
    /**
     * Filter which humanities to update
     */
    where?: humanityWhereInput
    /**
     * Limit how many humanities to update.
     */
    limit?: number
  }

  /**
   * humanity upsert
   */
  export type humanityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the humanity
     */
    select?: humanitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the humanity
     */
    omit?: humanityOmit<ExtArgs> | null
    /**
     * The filter to search for the humanity to update in case it exists.
     */
    where: humanityWhereUniqueInput
    /**
     * In case the humanity found by the `where` argument doesn't exist, create a new humanity with this data.
     */
    create: XOR<humanityCreateInput, humanityUncheckedCreateInput>
    /**
     * In case the humanity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<humanityUpdateInput, humanityUncheckedUpdateInput>
  }

  /**
   * humanity delete
   */
  export type humanityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the humanity
     */
    select?: humanitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the humanity
     */
    omit?: humanityOmit<ExtArgs> | null
    /**
     * Filter which humanity to delete.
     */
    where: humanityWhereUniqueInput
  }

  /**
   * humanity deleteMany
   */
  export type humanityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which humanities to delete
     */
    where?: humanityWhereInput
    /**
     * Limit how many humanities to delete.
     */
    limit?: number
  }

  /**
   * humanity without action
   */
  export type humanityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the humanity
     */
    select?: humanitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the humanity
     */
    omit?: humanityOmit<ExtArgs> | null
  }


  /**
   * Model predator_types
   */

  export type AggregatePredator_types = {
    _count: Predator_typesCountAggregateOutputType | null
    _min: Predator_typesMinAggregateOutputType | null
    _max: Predator_typesMaxAggregateOutputType | null
  }

  export type Predator_typesMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    dice_pool: string | null
    benefits: string | null
  }

  export type Predator_typesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    dice_pool: string | null
    benefits: string | null
  }

  export type Predator_typesCountAggregateOutputType = {
    id: number
    name: number
    description: number
    dice_pool: number
    benefits: number
    _all: number
  }


  export type Predator_typesMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    dice_pool?: true
    benefits?: true
  }

  export type Predator_typesMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    dice_pool?: true
    benefits?: true
  }

  export type Predator_typesCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    dice_pool?: true
    benefits?: true
    _all?: true
  }

  export type Predator_typesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which predator_types to aggregate.
     */
    where?: predator_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of predator_types to fetch.
     */
    orderBy?: predator_typesOrderByWithRelationInput | predator_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: predator_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` predator_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` predator_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned predator_types
    **/
    _count?: true | Predator_typesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Predator_typesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Predator_typesMaxAggregateInputType
  }

  export type GetPredator_typesAggregateType<T extends Predator_typesAggregateArgs> = {
        [P in keyof T & keyof AggregatePredator_types]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePredator_types[P]>
      : GetScalarType<T[P], AggregatePredator_types[P]>
  }




  export type predator_typesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: predator_typesWhereInput
    orderBy?: predator_typesOrderByWithAggregationInput | predator_typesOrderByWithAggregationInput[]
    by: Predator_typesScalarFieldEnum[] | Predator_typesScalarFieldEnum
    having?: predator_typesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Predator_typesCountAggregateInputType | true
    _min?: Predator_typesMinAggregateInputType
    _max?: Predator_typesMaxAggregateInputType
  }

  export type Predator_typesGroupByOutputType = {
    id: string
    name: string
    description: string
    dice_pool: string
    benefits: string
    _count: Predator_typesCountAggregateOutputType | null
    _min: Predator_typesMinAggregateOutputType | null
    _max: Predator_typesMaxAggregateOutputType | null
  }

  type GetPredator_typesGroupByPayload<T extends predator_typesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Predator_typesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Predator_typesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Predator_typesGroupByOutputType[P]>
            : GetScalarType<T[P], Predator_typesGroupByOutputType[P]>
        }
      >
    >


  export type predator_typesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    dice_pool?: boolean
    benefits?: boolean
    characters?: boolean | predator_types$charactersArgs<ExtArgs>
    _count?: boolean | Predator_typesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["predator_types"]>

  export type predator_typesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    dice_pool?: boolean
    benefits?: boolean
  }, ExtArgs["result"]["predator_types"]>

  export type predator_typesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    dice_pool?: boolean
    benefits?: boolean
  }, ExtArgs["result"]["predator_types"]>

  export type predator_typesSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    dice_pool?: boolean
    benefits?: boolean
  }

  export type predator_typesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "dice_pool" | "benefits", ExtArgs["result"]["predator_types"]>
  export type predator_typesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | predator_types$charactersArgs<ExtArgs>
    _count?: boolean | Predator_typesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type predator_typesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type predator_typesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $predator_typesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "predator_types"
    objects: {
      characters: Prisma.$charactersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      dice_pool: string
      benefits: string
    }, ExtArgs["result"]["predator_types"]>
    composites: {}
  }

  type predator_typesGetPayload<S extends boolean | null | undefined | predator_typesDefaultArgs> = $Result.GetResult<Prisma.$predator_typesPayload, S>

  type predator_typesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<predator_typesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Predator_typesCountAggregateInputType | true
    }

  export interface predator_typesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['predator_types'], meta: { name: 'predator_types' } }
    /**
     * Find zero or one Predator_types that matches the filter.
     * @param {predator_typesFindUniqueArgs} args - Arguments to find a Predator_types
     * @example
     * // Get one Predator_types
     * const predator_types = await prisma.predator_types.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends predator_typesFindUniqueArgs>(args: SelectSubset<T, predator_typesFindUniqueArgs<ExtArgs>>): Prisma__predator_typesClient<$Result.GetResult<Prisma.$predator_typesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Predator_types that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {predator_typesFindUniqueOrThrowArgs} args - Arguments to find a Predator_types
     * @example
     * // Get one Predator_types
     * const predator_types = await prisma.predator_types.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends predator_typesFindUniqueOrThrowArgs>(args: SelectSubset<T, predator_typesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__predator_typesClient<$Result.GetResult<Prisma.$predator_typesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Predator_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {predator_typesFindFirstArgs} args - Arguments to find a Predator_types
     * @example
     * // Get one Predator_types
     * const predator_types = await prisma.predator_types.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends predator_typesFindFirstArgs>(args?: SelectSubset<T, predator_typesFindFirstArgs<ExtArgs>>): Prisma__predator_typesClient<$Result.GetResult<Prisma.$predator_typesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Predator_types that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {predator_typesFindFirstOrThrowArgs} args - Arguments to find a Predator_types
     * @example
     * // Get one Predator_types
     * const predator_types = await prisma.predator_types.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends predator_typesFindFirstOrThrowArgs>(args?: SelectSubset<T, predator_typesFindFirstOrThrowArgs<ExtArgs>>): Prisma__predator_typesClient<$Result.GetResult<Prisma.$predator_typesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Predator_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {predator_typesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Predator_types
     * const predator_types = await prisma.predator_types.findMany()
     * 
     * // Get first 10 Predator_types
     * const predator_types = await prisma.predator_types.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const predator_typesWithIdOnly = await prisma.predator_types.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends predator_typesFindManyArgs>(args?: SelectSubset<T, predator_typesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$predator_typesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Predator_types.
     * @param {predator_typesCreateArgs} args - Arguments to create a Predator_types.
     * @example
     * // Create one Predator_types
     * const Predator_types = await prisma.predator_types.create({
     *   data: {
     *     // ... data to create a Predator_types
     *   }
     * })
     * 
     */
    create<T extends predator_typesCreateArgs>(args: SelectSubset<T, predator_typesCreateArgs<ExtArgs>>): Prisma__predator_typesClient<$Result.GetResult<Prisma.$predator_typesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Predator_types.
     * @param {predator_typesCreateManyArgs} args - Arguments to create many Predator_types.
     * @example
     * // Create many Predator_types
     * const predator_types = await prisma.predator_types.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends predator_typesCreateManyArgs>(args?: SelectSubset<T, predator_typesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Predator_types and returns the data saved in the database.
     * @param {predator_typesCreateManyAndReturnArgs} args - Arguments to create many Predator_types.
     * @example
     * // Create many Predator_types
     * const predator_types = await prisma.predator_types.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Predator_types and only return the `id`
     * const predator_typesWithIdOnly = await prisma.predator_types.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends predator_typesCreateManyAndReturnArgs>(args?: SelectSubset<T, predator_typesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$predator_typesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Predator_types.
     * @param {predator_typesDeleteArgs} args - Arguments to delete one Predator_types.
     * @example
     * // Delete one Predator_types
     * const Predator_types = await prisma.predator_types.delete({
     *   where: {
     *     // ... filter to delete one Predator_types
     *   }
     * })
     * 
     */
    delete<T extends predator_typesDeleteArgs>(args: SelectSubset<T, predator_typesDeleteArgs<ExtArgs>>): Prisma__predator_typesClient<$Result.GetResult<Prisma.$predator_typesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Predator_types.
     * @param {predator_typesUpdateArgs} args - Arguments to update one Predator_types.
     * @example
     * // Update one Predator_types
     * const predator_types = await prisma.predator_types.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends predator_typesUpdateArgs>(args: SelectSubset<T, predator_typesUpdateArgs<ExtArgs>>): Prisma__predator_typesClient<$Result.GetResult<Prisma.$predator_typesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Predator_types.
     * @param {predator_typesDeleteManyArgs} args - Arguments to filter Predator_types to delete.
     * @example
     * // Delete a few Predator_types
     * const { count } = await prisma.predator_types.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends predator_typesDeleteManyArgs>(args?: SelectSubset<T, predator_typesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Predator_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {predator_typesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Predator_types
     * const predator_types = await prisma.predator_types.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends predator_typesUpdateManyArgs>(args: SelectSubset<T, predator_typesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Predator_types and returns the data updated in the database.
     * @param {predator_typesUpdateManyAndReturnArgs} args - Arguments to update many Predator_types.
     * @example
     * // Update many Predator_types
     * const predator_types = await prisma.predator_types.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Predator_types and only return the `id`
     * const predator_typesWithIdOnly = await prisma.predator_types.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends predator_typesUpdateManyAndReturnArgs>(args: SelectSubset<T, predator_typesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$predator_typesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Predator_types.
     * @param {predator_typesUpsertArgs} args - Arguments to update or create a Predator_types.
     * @example
     * // Update or create a Predator_types
     * const predator_types = await prisma.predator_types.upsert({
     *   create: {
     *     // ... data to create a Predator_types
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Predator_types we want to update
     *   }
     * })
     */
    upsert<T extends predator_typesUpsertArgs>(args: SelectSubset<T, predator_typesUpsertArgs<ExtArgs>>): Prisma__predator_typesClient<$Result.GetResult<Prisma.$predator_typesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Predator_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {predator_typesCountArgs} args - Arguments to filter Predator_types to count.
     * @example
     * // Count the number of Predator_types
     * const count = await prisma.predator_types.count({
     *   where: {
     *     // ... the filter for the Predator_types we want to count
     *   }
     * })
    **/
    count<T extends predator_typesCountArgs>(
      args?: Subset<T, predator_typesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Predator_typesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Predator_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Predator_typesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Predator_typesAggregateArgs>(args: Subset<T, Predator_typesAggregateArgs>): Prisma.PrismaPromise<GetPredator_typesAggregateType<T>>

    /**
     * Group by Predator_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {predator_typesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends predator_typesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: predator_typesGroupByArgs['orderBy'] }
        : { orderBy?: predator_typesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, predator_typesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPredator_typesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the predator_types model
   */
  readonly fields: predator_typesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for predator_types.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__predator_typesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    characters<T extends predator_types$charactersArgs<ExtArgs> = {}>(args?: Subset<T, predator_types$charactersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$charactersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the predator_types model
   */
  interface predator_typesFieldRefs {
    readonly id: FieldRef<"predator_types", 'String'>
    readonly name: FieldRef<"predator_types", 'String'>
    readonly description: FieldRef<"predator_types", 'String'>
    readonly dice_pool: FieldRef<"predator_types", 'String'>
    readonly benefits: FieldRef<"predator_types", 'String'>
  }
    

  // Custom InputTypes
  /**
   * predator_types findUnique
   */
  export type predator_typesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the predator_types
     */
    select?: predator_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the predator_types
     */
    omit?: predator_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: predator_typesInclude<ExtArgs> | null
    /**
     * Filter, which predator_types to fetch.
     */
    where: predator_typesWhereUniqueInput
  }

  /**
   * predator_types findUniqueOrThrow
   */
  export type predator_typesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the predator_types
     */
    select?: predator_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the predator_types
     */
    omit?: predator_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: predator_typesInclude<ExtArgs> | null
    /**
     * Filter, which predator_types to fetch.
     */
    where: predator_typesWhereUniqueInput
  }

  /**
   * predator_types findFirst
   */
  export type predator_typesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the predator_types
     */
    select?: predator_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the predator_types
     */
    omit?: predator_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: predator_typesInclude<ExtArgs> | null
    /**
     * Filter, which predator_types to fetch.
     */
    where?: predator_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of predator_types to fetch.
     */
    orderBy?: predator_typesOrderByWithRelationInput | predator_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for predator_types.
     */
    cursor?: predator_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` predator_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` predator_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of predator_types.
     */
    distinct?: Predator_typesScalarFieldEnum | Predator_typesScalarFieldEnum[]
  }

  /**
   * predator_types findFirstOrThrow
   */
  export type predator_typesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the predator_types
     */
    select?: predator_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the predator_types
     */
    omit?: predator_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: predator_typesInclude<ExtArgs> | null
    /**
     * Filter, which predator_types to fetch.
     */
    where?: predator_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of predator_types to fetch.
     */
    orderBy?: predator_typesOrderByWithRelationInput | predator_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for predator_types.
     */
    cursor?: predator_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` predator_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` predator_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of predator_types.
     */
    distinct?: Predator_typesScalarFieldEnum | Predator_typesScalarFieldEnum[]
  }

  /**
   * predator_types findMany
   */
  export type predator_typesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the predator_types
     */
    select?: predator_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the predator_types
     */
    omit?: predator_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: predator_typesInclude<ExtArgs> | null
    /**
     * Filter, which predator_types to fetch.
     */
    where?: predator_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of predator_types to fetch.
     */
    orderBy?: predator_typesOrderByWithRelationInput | predator_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing predator_types.
     */
    cursor?: predator_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` predator_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` predator_types.
     */
    skip?: number
    distinct?: Predator_typesScalarFieldEnum | Predator_typesScalarFieldEnum[]
  }

  /**
   * predator_types create
   */
  export type predator_typesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the predator_types
     */
    select?: predator_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the predator_types
     */
    omit?: predator_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: predator_typesInclude<ExtArgs> | null
    /**
     * The data needed to create a predator_types.
     */
    data: XOR<predator_typesCreateInput, predator_typesUncheckedCreateInput>
  }

  /**
   * predator_types createMany
   */
  export type predator_typesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many predator_types.
     */
    data: predator_typesCreateManyInput | predator_typesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * predator_types createManyAndReturn
   */
  export type predator_typesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the predator_types
     */
    select?: predator_typesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the predator_types
     */
    omit?: predator_typesOmit<ExtArgs> | null
    /**
     * The data used to create many predator_types.
     */
    data: predator_typesCreateManyInput | predator_typesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * predator_types update
   */
  export type predator_typesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the predator_types
     */
    select?: predator_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the predator_types
     */
    omit?: predator_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: predator_typesInclude<ExtArgs> | null
    /**
     * The data needed to update a predator_types.
     */
    data: XOR<predator_typesUpdateInput, predator_typesUncheckedUpdateInput>
    /**
     * Choose, which predator_types to update.
     */
    where: predator_typesWhereUniqueInput
  }

  /**
   * predator_types updateMany
   */
  export type predator_typesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update predator_types.
     */
    data: XOR<predator_typesUpdateManyMutationInput, predator_typesUncheckedUpdateManyInput>
    /**
     * Filter which predator_types to update
     */
    where?: predator_typesWhereInput
    /**
     * Limit how many predator_types to update.
     */
    limit?: number
  }

  /**
   * predator_types updateManyAndReturn
   */
  export type predator_typesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the predator_types
     */
    select?: predator_typesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the predator_types
     */
    omit?: predator_typesOmit<ExtArgs> | null
    /**
     * The data used to update predator_types.
     */
    data: XOR<predator_typesUpdateManyMutationInput, predator_typesUncheckedUpdateManyInput>
    /**
     * Filter which predator_types to update
     */
    where?: predator_typesWhereInput
    /**
     * Limit how many predator_types to update.
     */
    limit?: number
  }

  /**
   * predator_types upsert
   */
  export type predator_typesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the predator_types
     */
    select?: predator_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the predator_types
     */
    omit?: predator_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: predator_typesInclude<ExtArgs> | null
    /**
     * The filter to search for the predator_types to update in case it exists.
     */
    where: predator_typesWhereUniqueInput
    /**
     * In case the predator_types found by the `where` argument doesn't exist, create a new predator_types with this data.
     */
    create: XOR<predator_typesCreateInput, predator_typesUncheckedCreateInput>
    /**
     * In case the predator_types was found with the provided `where` argument, update it with this data.
     */
    update: XOR<predator_typesUpdateInput, predator_typesUncheckedUpdateInput>
  }

  /**
   * predator_types delete
   */
  export type predator_typesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the predator_types
     */
    select?: predator_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the predator_types
     */
    omit?: predator_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: predator_typesInclude<ExtArgs> | null
    /**
     * Filter which predator_types to delete.
     */
    where: predator_typesWhereUniqueInput
  }

  /**
   * predator_types deleteMany
   */
  export type predator_typesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which predator_types to delete
     */
    where?: predator_typesWhereInput
    /**
     * Limit how many predator_types to delete.
     */
    limit?: number
  }

  /**
   * predator_types.characters
   */
  export type predator_types$charactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characters
     */
    select?: charactersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the characters
     */
    omit?: charactersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: charactersInclude<ExtArgs> | null
    where?: charactersWhereInput
    orderBy?: charactersOrderByWithRelationInput | charactersOrderByWithRelationInput[]
    cursor?: charactersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharactersScalarFieldEnum | CharactersScalarFieldEnum[]
  }

  /**
   * predator_types without action
   */
  export type predator_typesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the predator_types
     */
    select?: predator_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the predator_types
     */
    omit?: predator_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: predator_typesInclude<ExtArgs> | null
  }


  /**
   * Model rituals
   */

  export type AggregateRituals = {
    _count: RitualsCountAggregateOutputType | null
    _avg: RitualsAvgAggregateOutputType | null
    _sum: RitualsSumAggregateOutputType | null
    _min: RitualsMinAggregateOutputType | null
    _max: RitualsMaxAggregateOutputType | null
  }

  export type RitualsAvgAggregateOutputType = {
    level: number | null
  }

  export type RitualsSumAggregateOutputType = {
    level: number | null
  }

  export type RitualsMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    ingridients: string | null
    process: string | null
    system: string | null
    level: number | null
  }

  export type RitualsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    ingridients: string | null
    process: string | null
    system: string | null
    level: number | null
  }

  export type RitualsCountAggregateOutputType = {
    id: number
    name: number
    description: number
    ingridients: number
    process: number
    system: number
    level: number
    _all: number
  }


  export type RitualsAvgAggregateInputType = {
    level?: true
  }

  export type RitualsSumAggregateInputType = {
    level?: true
  }

  export type RitualsMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    ingridients?: true
    process?: true
    system?: true
    level?: true
  }

  export type RitualsMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    ingridients?: true
    process?: true
    system?: true
    level?: true
  }

  export type RitualsCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    ingridients?: true
    process?: true
    system?: true
    level?: true
    _all?: true
  }

  export type RitualsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rituals to aggregate.
     */
    where?: ritualsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rituals to fetch.
     */
    orderBy?: ritualsOrderByWithRelationInput | ritualsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ritualsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rituals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rituals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rituals
    **/
    _count?: true | RitualsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RitualsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RitualsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RitualsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RitualsMaxAggregateInputType
  }

  export type GetRitualsAggregateType<T extends RitualsAggregateArgs> = {
        [P in keyof T & keyof AggregateRituals]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRituals[P]>
      : GetScalarType<T[P], AggregateRituals[P]>
  }




  export type ritualsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ritualsWhereInput
    orderBy?: ritualsOrderByWithAggregationInput | ritualsOrderByWithAggregationInput[]
    by: RitualsScalarFieldEnum[] | RitualsScalarFieldEnum
    having?: ritualsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RitualsCountAggregateInputType | true
    _avg?: RitualsAvgAggregateInputType
    _sum?: RitualsSumAggregateInputType
    _min?: RitualsMinAggregateInputType
    _max?: RitualsMaxAggregateInputType
  }

  export type RitualsGroupByOutputType = {
    id: string
    name: string
    description: string
    ingridients: string
    process: string
    system: string
    level: number
    _count: RitualsCountAggregateOutputType | null
    _avg: RitualsAvgAggregateOutputType | null
    _sum: RitualsSumAggregateOutputType | null
    _min: RitualsMinAggregateOutputType | null
    _max: RitualsMaxAggregateOutputType | null
  }

  type GetRitualsGroupByPayload<T extends ritualsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RitualsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RitualsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RitualsGroupByOutputType[P]>
            : GetScalarType<T[P], RitualsGroupByOutputType[P]>
        }
      >
    >


  export type ritualsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    ingridients?: boolean
    process?: boolean
    system?: boolean
    level?: boolean
    character_rituals?: boolean | rituals$character_ritualsArgs<ExtArgs>
    _count?: boolean | RitualsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rituals"]>

  export type ritualsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    ingridients?: boolean
    process?: boolean
    system?: boolean
    level?: boolean
  }, ExtArgs["result"]["rituals"]>

  export type ritualsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    ingridients?: boolean
    process?: boolean
    system?: boolean
    level?: boolean
  }, ExtArgs["result"]["rituals"]>

  export type ritualsSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    ingridients?: boolean
    process?: boolean
    system?: boolean
    level?: boolean
  }

  export type ritualsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "ingridients" | "process" | "system" | "level", ExtArgs["result"]["rituals"]>
  export type ritualsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character_rituals?: boolean | rituals$character_ritualsArgs<ExtArgs>
    _count?: boolean | RitualsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ritualsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ritualsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ritualsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "rituals"
    objects: {
      character_rituals: Prisma.$character_ritualsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      ingridients: string
      process: string
      system: string
      level: number
    }, ExtArgs["result"]["rituals"]>
    composites: {}
  }

  type ritualsGetPayload<S extends boolean | null | undefined | ritualsDefaultArgs> = $Result.GetResult<Prisma.$ritualsPayload, S>

  type ritualsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ritualsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RitualsCountAggregateInputType | true
    }

  export interface ritualsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['rituals'], meta: { name: 'rituals' } }
    /**
     * Find zero or one Rituals that matches the filter.
     * @param {ritualsFindUniqueArgs} args - Arguments to find a Rituals
     * @example
     * // Get one Rituals
     * const rituals = await prisma.rituals.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ritualsFindUniqueArgs>(args: SelectSubset<T, ritualsFindUniqueArgs<ExtArgs>>): Prisma__ritualsClient<$Result.GetResult<Prisma.$ritualsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Rituals that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ritualsFindUniqueOrThrowArgs} args - Arguments to find a Rituals
     * @example
     * // Get one Rituals
     * const rituals = await prisma.rituals.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ritualsFindUniqueOrThrowArgs>(args: SelectSubset<T, ritualsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ritualsClient<$Result.GetResult<Prisma.$ritualsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rituals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ritualsFindFirstArgs} args - Arguments to find a Rituals
     * @example
     * // Get one Rituals
     * const rituals = await prisma.rituals.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ritualsFindFirstArgs>(args?: SelectSubset<T, ritualsFindFirstArgs<ExtArgs>>): Prisma__ritualsClient<$Result.GetResult<Prisma.$ritualsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Rituals that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ritualsFindFirstOrThrowArgs} args - Arguments to find a Rituals
     * @example
     * // Get one Rituals
     * const rituals = await prisma.rituals.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ritualsFindFirstOrThrowArgs>(args?: SelectSubset<T, ritualsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ritualsClient<$Result.GetResult<Prisma.$ritualsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rituals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ritualsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rituals
     * const rituals = await prisma.rituals.findMany()
     * 
     * // Get first 10 Rituals
     * const rituals = await prisma.rituals.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ritualsWithIdOnly = await prisma.rituals.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ritualsFindManyArgs>(args?: SelectSubset<T, ritualsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ritualsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Rituals.
     * @param {ritualsCreateArgs} args - Arguments to create a Rituals.
     * @example
     * // Create one Rituals
     * const Rituals = await prisma.rituals.create({
     *   data: {
     *     // ... data to create a Rituals
     *   }
     * })
     * 
     */
    create<T extends ritualsCreateArgs>(args: SelectSubset<T, ritualsCreateArgs<ExtArgs>>): Prisma__ritualsClient<$Result.GetResult<Prisma.$ritualsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rituals.
     * @param {ritualsCreateManyArgs} args - Arguments to create many Rituals.
     * @example
     * // Create many Rituals
     * const rituals = await prisma.rituals.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ritualsCreateManyArgs>(args?: SelectSubset<T, ritualsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rituals and returns the data saved in the database.
     * @param {ritualsCreateManyAndReturnArgs} args - Arguments to create many Rituals.
     * @example
     * // Create many Rituals
     * const rituals = await prisma.rituals.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rituals and only return the `id`
     * const ritualsWithIdOnly = await prisma.rituals.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ritualsCreateManyAndReturnArgs>(args?: SelectSubset<T, ritualsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ritualsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Rituals.
     * @param {ritualsDeleteArgs} args - Arguments to delete one Rituals.
     * @example
     * // Delete one Rituals
     * const Rituals = await prisma.rituals.delete({
     *   where: {
     *     // ... filter to delete one Rituals
     *   }
     * })
     * 
     */
    delete<T extends ritualsDeleteArgs>(args: SelectSubset<T, ritualsDeleteArgs<ExtArgs>>): Prisma__ritualsClient<$Result.GetResult<Prisma.$ritualsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Rituals.
     * @param {ritualsUpdateArgs} args - Arguments to update one Rituals.
     * @example
     * // Update one Rituals
     * const rituals = await prisma.rituals.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ritualsUpdateArgs>(args: SelectSubset<T, ritualsUpdateArgs<ExtArgs>>): Prisma__ritualsClient<$Result.GetResult<Prisma.$ritualsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rituals.
     * @param {ritualsDeleteManyArgs} args - Arguments to filter Rituals to delete.
     * @example
     * // Delete a few Rituals
     * const { count } = await prisma.rituals.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ritualsDeleteManyArgs>(args?: SelectSubset<T, ritualsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rituals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ritualsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rituals
     * const rituals = await prisma.rituals.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ritualsUpdateManyArgs>(args: SelectSubset<T, ritualsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rituals and returns the data updated in the database.
     * @param {ritualsUpdateManyAndReturnArgs} args - Arguments to update many Rituals.
     * @example
     * // Update many Rituals
     * const rituals = await prisma.rituals.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Rituals and only return the `id`
     * const ritualsWithIdOnly = await prisma.rituals.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ritualsUpdateManyAndReturnArgs>(args: SelectSubset<T, ritualsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ritualsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Rituals.
     * @param {ritualsUpsertArgs} args - Arguments to update or create a Rituals.
     * @example
     * // Update or create a Rituals
     * const rituals = await prisma.rituals.upsert({
     *   create: {
     *     // ... data to create a Rituals
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rituals we want to update
     *   }
     * })
     */
    upsert<T extends ritualsUpsertArgs>(args: SelectSubset<T, ritualsUpsertArgs<ExtArgs>>): Prisma__ritualsClient<$Result.GetResult<Prisma.$ritualsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rituals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ritualsCountArgs} args - Arguments to filter Rituals to count.
     * @example
     * // Count the number of Rituals
     * const count = await prisma.rituals.count({
     *   where: {
     *     // ... the filter for the Rituals we want to count
     *   }
     * })
    **/
    count<T extends ritualsCountArgs>(
      args?: Subset<T, ritualsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RitualsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rituals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RitualsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RitualsAggregateArgs>(args: Subset<T, RitualsAggregateArgs>): Prisma.PrismaPromise<GetRitualsAggregateType<T>>

    /**
     * Group by Rituals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ritualsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ritualsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ritualsGroupByArgs['orderBy'] }
        : { orderBy?: ritualsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ritualsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRitualsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the rituals model
   */
  readonly fields: ritualsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for rituals.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ritualsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    character_rituals<T extends rituals$character_ritualsArgs<ExtArgs> = {}>(args?: Subset<T, rituals$character_ritualsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_ritualsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the rituals model
   */
  interface ritualsFieldRefs {
    readonly id: FieldRef<"rituals", 'String'>
    readonly name: FieldRef<"rituals", 'String'>
    readonly description: FieldRef<"rituals", 'String'>
    readonly ingridients: FieldRef<"rituals", 'String'>
    readonly process: FieldRef<"rituals", 'String'>
    readonly system: FieldRef<"rituals", 'String'>
    readonly level: FieldRef<"rituals", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * rituals findUnique
   */
  export type ritualsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rituals
     */
    select?: ritualsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rituals
     */
    omit?: ritualsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ritualsInclude<ExtArgs> | null
    /**
     * Filter, which rituals to fetch.
     */
    where: ritualsWhereUniqueInput
  }

  /**
   * rituals findUniqueOrThrow
   */
  export type ritualsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rituals
     */
    select?: ritualsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rituals
     */
    omit?: ritualsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ritualsInclude<ExtArgs> | null
    /**
     * Filter, which rituals to fetch.
     */
    where: ritualsWhereUniqueInput
  }

  /**
   * rituals findFirst
   */
  export type ritualsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rituals
     */
    select?: ritualsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rituals
     */
    omit?: ritualsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ritualsInclude<ExtArgs> | null
    /**
     * Filter, which rituals to fetch.
     */
    where?: ritualsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rituals to fetch.
     */
    orderBy?: ritualsOrderByWithRelationInput | ritualsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rituals.
     */
    cursor?: ritualsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rituals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rituals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rituals.
     */
    distinct?: RitualsScalarFieldEnum | RitualsScalarFieldEnum[]
  }

  /**
   * rituals findFirstOrThrow
   */
  export type ritualsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rituals
     */
    select?: ritualsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rituals
     */
    omit?: ritualsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ritualsInclude<ExtArgs> | null
    /**
     * Filter, which rituals to fetch.
     */
    where?: ritualsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rituals to fetch.
     */
    orderBy?: ritualsOrderByWithRelationInput | ritualsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rituals.
     */
    cursor?: ritualsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rituals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rituals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rituals.
     */
    distinct?: RitualsScalarFieldEnum | RitualsScalarFieldEnum[]
  }

  /**
   * rituals findMany
   */
  export type ritualsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rituals
     */
    select?: ritualsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rituals
     */
    omit?: ritualsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ritualsInclude<ExtArgs> | null
    /**
     * Filter, which rituals to fetch.
     */
    where?: ritualsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rituals to fetch.
     */
    orderBy?: ritualsOrderByWithRelationInput | ritualsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rituals.
     */
    cursor?: ritualsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rituals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rituals.
     */
    skip?: number
    distinct?: RitualsScalarFieldEnum | RitualsScalarFieldEnum[]
  }

  /**
   * rituals create
   */
  export type ritualsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rituals
     */
    select?: ritualsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rituals
     */
    omit?: ritualsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ritualsInclude<ExtArgs> | null
    /**
     * The data needed to create a rituals.
     */
    data: XOR<ritualsCreateInput, ritualsUncheckedCreateInput>
  }

  /**
   * rituals createMany
   */
  export type ritualsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rituals.
     */
    data: ritualsCreateManyInput | ritualsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * rituals createManyAndReturn
   */
  export type ritualsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rituals
     */
    select?: ritualsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the rituals
     */
    omit?: ritualsOmit<ExtArgs> | null
    /**
     * The data used to create many rituals.
     */
    data: ritualsCreateManyInput | ritualsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * rituals update
   */
  export type ritualsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rituals
     */
    select?: ritualsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rituals
     */
    omit?: ritualsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ritualsInclude<ExtArgs> | null
    /**
     * The data needed to update a rituals.
     */
    data: XOR<ritualsUpdateInput, ritualsUncheckedUpdateInput>
    /**
     * Choose, which rituals to update.
     */
    where: ritualsWhereUniqueInput
  }

  /**
   * rituals updateMany
   */
  export type ritualsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rituals.
     */
    data: XOR<ritualsUpdateManyMutationInput, ritualsUncheckedUpdateManyInput>
    /**
     * Filter which rituals to update
     */
    where?: ritualsWhereInput
    /**
     * Limit how many rituals to update.
     */
    limit?: number
  }

  /**
   * rituals updateManyAndReturn
   */
  export type ritualsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rituals
     */
    select?: ritualsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the rituals
     */
    omit?: ritualsOmit<ExtArgs> | null
    /**
     * The data used to update rituals.
     */
    data: XOR<ritualsUpdateManyMutationInput, ritualsUncheckedUpdateManyInput>
    /**
     * Filter which rituals to update
     */
    where?: ritualsWhereInput
    /**
     * Limit how many rituals to update.
     */
    limit?: number
  }

  /**
   * rituals upsert
   */
  export type ritualsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rituals
     */
    select?: ritualsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rituals
     */
    omit?: ritualsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ritualsInclude<ExtArgs> | null
    /**
     * The filter to search for the rituals to update in case it exists.
     */
    where: ritualsWhereUniqueInput
    /**
     * In case the rituals found by the `where` argument doesn't exist, create a new rituals with this data.
     */
    create: XOR<ritualsCreateInput, ritualsUncheckedCreateInput>
    /**
     * In case the rituals was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ritualsUpdateInput, ritualsUncheckedUpdateInput>
  }

  /**
   * rituals delete
   */
  export type ritualsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rituals
     */
    select?: ritualsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rituals
     */
    omit?: ritualsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ritualsInclude<ExtArgs> | null
    /**
     * Filter which rituals to delete.
     */
    where: ritualsWhereUniqueInput
  }

  /**
   * rituals deleteMany
   */
  export type ritualsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rituals to delete
     */
    where?: ritualsWhereInput
    /**
     * Limit how many rituals to delete.
     */
    limit?: number
  }

  /**
   * rituals.character_rituals
   */
  export type rituals$character_ritualsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_rituals
     */
    select?: character_ritualsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_rituals
     */
    omit?: character_ritualsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_ritualsInclude<ExtArgs> | null
    where?: character_ritualsWhereInput
    orderBy?: character_ritualsOrderByWithRelationInput | character_ritualsOrderByWithRelationInput[]
    cursor?: character_ritualsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Character_ritualsScalarFieldEnum | Character_ritualsScalarFieldEnum[]
  }

  /**
   * rituals without action
   */
  export type ritualsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rituals
     */
    select?: ritualsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the rituals
     */
    omit?: ritualsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ritualsInclude<ExtArgs> | null
  }


  /**
   * Model sects
   */

  export type AggregateSects = {
    _count: SectsCountAggregateOutputType | null
    _min: SectsMinAggregateOutputType | null
    _max: SectsMaxAggregateOutputType | null
  }

  export type SectsMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
  }

  export type SectsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
  }

  export type SectsCountAggregateOutputType = {
    id: number
    name: number
    description: number
    _all: number
  }


  export type SectsMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type SectsMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type SectsCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type SectsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sects to aggregate.
     */
    where?: sectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sects to fetch.
     */
    orderBy?: sectsOrderByWithRelationInput | sectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sects
    **/
    _count?: true | SectsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SectsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SectsMaxAggregateInputType
  }

  export type GetSectsAggregateType<T extends SectsAggregateArgs> = {
        [P in keyof T & keyof AggregateSects]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSects[P]>
      : GetScalarType<T[P], AggregateSects[P]>
  }




  export type sectsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sectsWhereInput
    orderBy?: sectsOrderByWithAggregationInput | sectsOrderByWithAggregationInput[]
    by: SectsScalarFieldEnum[] | SectsScalarFieldEnum
    having?: sectsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SectsCountAggregateInputType | true
    _min?: SectsMinAggregateInputType
    _max?: SectsMaxAggregateInputType
  }

  export type SectsGroupByOutputType = {
    id: string
    name: string
    description: string
    _count: SectsCountAggregateOutputType | null
    _min: SectsMinAggregateOutputType | null
    _max: SectsMaxAggregateOutputType | null
  }

  type GetSectsGroupByPayload<T extends sectsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SectsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SectsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SectsGroupByOutputType[P]>
            : GetScalarType<T[P], SectsGroupByOutputType[P]>
        }
      >
    >


  export type sectsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    advantages?: boolean | sects$advantagesArgs<ExtArgs>
    characters?: boolean | sects$charactersArgs<ExtArgs>
    _count?: boolean | SectsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sects"]>

  export type sectsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["sects"]>

  export type sectsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["sects"]>

  export type sectsSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
  }

  export type sectsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description", ExtArgs["result"]["sects"]>
  export type sectsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    advantages?: boolean | sects$advantagesArgs<ExtArgs>
    characters?: boolean | sects$charactersArgs<ExtArgs>
    _count?: boolean | SectsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type sectsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type sectsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $sectsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sects"
    objects: {
      advantages: Prisma.$advantagesPayload<ExtArgs>[]
      characters: Prisma.$charactersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
    }, ExtArgs["result"]["sects"]>
    composites: {}
  }

  type sectsGetPayload<S extends boolean | null | undefined | sectsDefaultArgs> = $Result.GetResult<Prisma.$sectsPayload, S>

  type sectsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sectsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SectsCountAggregateInputType | true
    }

  export interface sectsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sects'], meta: { name: 'sects' } }
    /**
     * Find zero or one Sects that matches the filter.
     * @param {sectsFindUniqueArgs} args - Arguments to find a Sects
     * @example
     * // Get one Sects
     * const sects = await prisma.sects.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sectsFindUniqueArgs>(args: SelectSubset<T, sectsFindUniqueArgs<ExtArgs>>): Prisma__sectsClient<$Result.GetResult<Prisma.$sectsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sects that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sectsFindUniqueOrThrowArgs} args - Arguments to find a Sects
     * @example
     * // Get one Sects
     * const sects = await prisma.sects.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sectsFindUniqueOrThrowArgs>(args: SelectSubset<T, sectsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sectsClient<$Result.GetResult<Prisma.$sectsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sectsFindFirstArgs} args - Arguments to find a Sects
     * @example
     * // Get one Sects
     * const sects = await prisma.sects.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sectsFindFirstArgs>(args?: SelectSubset<T, sectsFindFirstArgs<ExtArgs>>): Prisma__sectsClient<$Result.GetResult<Prisma.$sectsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sects that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sectsFindFirstOrThrowArgs} args - Arguments to find a Sects
     * @example
     * // Get one Sects
     * const sects = await prisma.sects.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sectsFindFirstOrThrowArgs>(args?: SelectSubset<T, sectsFindFirstOrThrowArgs<ExtArgs>>): Prisma__sectsClient<$Result.GetResult<Prisma.$sectsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sectsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sects
     * const sects = await prisma.sects.findMany()
     * 
     * // Get first 10 Sects
     * const sects = await prisma.sects.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sectsWithIdOnly = await prisma.sects.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends sectsFindManyArgs>(args?: SelectSubset<T, sectsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sectsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sects.
     * @param {sectsCreateArgs} args - Arguments to create a Sects.
     * @example
     * // Create one Sects
     * const Sects = await prisma.sects.create({
     *   data: {
     *     // ... data to create a Sects
     *   }
     * })
     * 
     */
    create<T extends sectsCreateArgs>(args: SelectSubset<T, sectsCreateArgs<ExtArgs>>): Prisma__sectsClient<$Result.GetResult<Prisma.$sectsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sects.
     * @param {sectsCreateManyArgs} args - Arguments to create many Sects.
     * @example
     * // Create many Sects
     * const sects = await prisma.sects.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sectsCreateManyArgs>(args?: SelectSubset<T, sectsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sects and returns the data saved in the database.
     * @param {sectsCreateManyAndReturnArgs} args - Arguments to create many Sects.
     * @example
     * // Create many Sects
     * const sects = await prisma.sects.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sects and only return the `id`
     * const sectsWithIdOnly = await prisma.sects.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends sectsCreateManyAndReturnArgs>(args?: SelectSubset<T, sectsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sectsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sects.
     * @param {sectsDeleteArgs} args - Arguments to delete one Sects.
     * @example
     * // Delete one Sects
     * const Sects = await prisma.sects.delete({
     *   where: {
     *     // ... filter to delete one Sects
     *   }
     * })
     * 
     */
    delete<T extends sectsDeleteArgs>(args: SelectSubset<T, sectsDeleteArgs<ExtArgs>>): Prisma__sectsClient<$Result.GetResult<Prisma.$sectsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sects.
     * @param {sectsUpdateArgs} args - Arguments to update one Sects.
     * @example
     * // Update one Sects
     * const sects = await prisma.sects.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sectsUpdateArgs>(args: SelectSubset<T, sectsUpdateArgs<ExtArgs>>): Prisma__sectsClient<$Result.GetResult<Prisma.$sectsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sects.
     * @param {sectsDeleteManyArgs} args - Arguments to filter Sects to delete.
     * @example
     * // Delete a few Sects
     * const { count } = await prisma.sects.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sectsDeleteManyArgs>(args?: SelectSubset<T, sectsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sectsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sects
     * const sects = await prisma.sects.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sectsUpdateManyArgs>(args: SelectSubset<T, sectsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sects and returns the data updated in the database.
     * @param {sectsUpdateManyAndReturnArgs} args - Arguments to update many Sects.
     * @example
     * // Update many Sects
     * const sects = await prisma.sects.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sects and only return the `id`
     * const sectsWithIdOnly = await prisma.sects.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends sectsUpdateManyAndReturnArgs>(args: SelectSubset<T, sectsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sectsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sects.
     * @param {sectsUpsertArgs} args - Arguments to update or create a Sects.
     * @example
     * // Update or create a Sects
     * const sects = await prisma.sects.upsert({
     *   create: {
     *     // ... data to create a Sects
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sects we want to update
     *   }
     * })
     */
    upsert<T extends sectsUpsertArgs>(args: SelectSubset<T, sectsUpsertArgs<ExtArgs>>): Prisma__sectsClient<$Result.GetResult<Prisma.$sectsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sectsCountArgs} args - Arguments to filter Sects to count.
     * @example
     * // Count the number of Sects
     * const count = await prisma.sects.count({
     *   where: {
     *     // ... the filter for the Sects we want to count
     *   }
     * })
    **/
    count<T extends sectsCountArgs>(
      args?: Subset<T, sectsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SectsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SectsAggregateArgs>(args: Subset<T, SectsAggregateArgs>): Prisma.PrismaPromise<GetSectsAggregateType<T>>

    /**
     * Group by Sects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sectsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sectsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sectsGroupByArgs['orderBy'] }
        : { orderBy?: sectsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sectsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSectsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sects model
   */
  readonly fields: sectsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sects.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sectsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    advantages<T extends sects$advantagesArgs<ExtArgs> = {}>(args?: Subset<T, sects$advantagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$advantagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    characters<T extends sects$charactersArgs<ExtArgs> = {}>(args?: Subset<T, sects$charactersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$charactersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sects model
   */
  interface sectsFieldRefs {
    readonly id: FieldRef<"sects", 'String'>
    readonly name: FieldRef<"sects", 'String'>
    readonly description: FieldRef<"sects", 'String'>
  }
    

  // Custom InputTypes
  /**
   * sects findUnique
   */
  export type sectsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sects
     */
    select?: sectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sects
     */
    omit?: sectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectsInclude<ExtArgs> | null
    /**
     * Filter, which sects to fetch.
     */
    where: sectsWhereUniqueInput
  }

  /**
   * sects findUniqueOrThrow
   */
  export type sectsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sects
     */
    select?: sectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sects
     */
    omit?: sectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectsInclude<ExtArgs> | null
    /**
     * Filter, which sects to fetch.
     */
    where: sectsWhereUniqueInput
  }

  /**
   * sects findFirst
   */
  export type sectsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sects
     */
    select?: sectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sects
     */
    omit?: sectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectsInclude<ExtArgs> | null
    /**
     * Filter, which sects to fetch.
     */
    where?: sectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sects to fetch.
     */
    orderBy?: sectsOrderByWithRelationInput | sectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sects.
     */
    cursor?: sectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sects.
     */
    distinct?: SectsScalarFieldEnum | SectsScalarFieldEnum[]
  }

  /**
   * sects findFirstOrThrow
   */
  export type sectsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sects
     */
    select?: sectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sects
     */
    omit?: sectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectsInclude<ExtArgs> | null
    /**
     * Filter, which sects to fetch.
     */
    where?: sectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sects to fetch.
     */
    orderBy?: sectsOrderByWithRelationInput | sectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sects.
     */
    cursor?: sectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sects.
     */
    distinct?: SectsScalarFieldEnum | SectsScalarFieldEnum[]
  }

  /**
   * sects findMany
   */
  export type sectsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sects
     */
    select?: sectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sects
     */
    omit?: sectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectsInclude<ExtArgs> | null
    /**
     * Filter, which sects to fetch.
     */
    where?: sectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sects to fetch.
     */
    orderBy?: sectsOrderByWithRelationInput | sectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sects.
     */
    cursor?: sectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sects.
     */
    skip?: number
    distinct?: SectsScalarFieldEnum | SectsScalarFieldEnum[]
  }

  /**
   * sects create
   */
  export type sectsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sects
     */
    select?: sectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sects
     */
    omit?: sectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectsInclude<ExtArgs> | null
    /**
     * The data needed to create a sects.
     */
    data: XOR<sectsCreateInput, sectsUncheckedCreateInput>
  }

  /**
   * sects createMany
   */
  export type sectsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sects.
     */
    data: sectsCreateManyInput | sectsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sects createManyAndReturn
   */
  export type sectsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sects
     */
    select?: sectsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the sects
     */
    omit?: sectsOmit<ExtArgs> | null
    /**
     * The data used to create many sects.
     */
    data: sectsCreateManyInput | sectsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sects update
   */
  export type sectsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sects
     */
    select?: sectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sects
     */
    omit?: sectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectsInclude<ExtArgs> | null
    /**
     * The data needed to update a sects.
     */
    data: XOR<sectsUpdateInput, sectsUncheckedUpdateInput>
    /**
     * Choose, which sects to update.
     */
    where: sectsWhereUniqueInput
  }

  /**
   * sects updateMany
   */
  export type sectsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sects.
     */
    data: XOR<sectsUpdateManyMutationInput, sectsUncheckedUpdateManyInput>
    /**
     * Filter which sects to update
     */
    where?: sectsWhereInput
    /**
     * Limit how many sects to update.
     */
    limit?: number
  }

  /**
   * sects updateManyAndReturn
   */
  export type sectsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sects
     */
    select?: sectsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the sects
     */
    omit?: sectsOmit<ExtArgs> | null
    /**
     * The data used to update sects.
     */
    data: XOR<sectsUpdateManyMutationInput, sectsUncheckedUpdateManyInput>
    /**
     * Filter which sects to update
     */
    where?: sectsWhereInput
    /**
     * Limit how many sects to update.
     */
    limit?: number
  }

  /**
   * sects upsert
   */
  export type sectsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sects
     */
    select?: sectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sects
     */
    omit?: sectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectsInclude<ExtArgs> | null
    /**
     * The filter to search for the sects to update in case it exists.
     */
    where: sectsWhereUniqueInput
    /**
     * In case the sects found by the `where` argument doesn't exist, create a new sects with this data.
     */
    create: XOR<sectsCreateInput, sectsUncheckedCreateInput>
    /**
     * In case the sects was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sectsUpdateInput, sectsUncheckedUpdateInput>
  }

  /**
   * sects delete
   */
  export type sectsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sects
     */
    select?: sectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sects
     */
    omit?: sectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectsInclude<ExtArgs> | null
    /**
     * Filter which sects to delete.
     */
    where: sectsWhereUniqueInput
  }

  /**
   * sects deleteMany
   */
  export type sectsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sects to delete
     */
    where?: sectsWhereInput
    /**
     * Limit how many sects to delete.
     */
    limit?: number
  }

  /**
   * sects.advantages
   */
  export type sects$advantagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the advantages
     */
    select?: advantagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the advantages
     */
    omit?: advantagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: advantagesInclude<ExtArgs> | null
    where?: advantagesWhereInput
    orderBy?: advantagesOrderByWithRelationInput | advantagesOrderByWithRelationInput[]
    cursor?: advantagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdvantagesScalarFieldEnum | AdvantagesScalarFieldEnum[]
  }

  /**
   * sects.characters
   */
  export type sects$charactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characters
     */
    select?: charactersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the characters
     */
    omit?: charactersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: charactersInclude<ExtArgs> | null
    where?: charactersWhereInput
    orderBy?: charactersOrderByWithRelationInput | charactersOrderByWithRelationInput[]
    cursor?: charactersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharactersScalarFieldEnum | CharactersScalarFieldEnum[]
  }

  /**
   * sects without action
   */
  export type sectsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sects
     */
    select?: sectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sects
     */
    omit?: sectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sectsInclude<ExtArgs> | null
  }


  /**
   * Model skills
   */

  export type AggregateSkills = {
    _count: SkillsCountAggregateOutputType | null
    _min: SkillsMinAggregateOutputType | null
    _max: SkillsMaxAggregateOutputType | null
  }

  export type SkillsMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
  }

  export type SkillsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
  }

  export type SkillsCountAggregateOutputType = {
    id: number
    name: number
    description: number
    _all: number
  }


  export type SkillsMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type SkillsMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type SkillsCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type SkillsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which skills to aggregate.
     */
    where?: skillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skills to fetch.
     */
    orderBy?: skillsOrderByWithRelationInput | skillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: skillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned skills
    **/
    _count?: true | SkillsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkillsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkillsMaxAggregateInputType
  }

  export type GetSkillsAggregateType<T extends SkillsAggregateArgs> = {
        [P in keyof T & keyof AggregateSkills]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkills[P]>
      : GetScalarType<T[P], AggregateSkills[P]>
  }




  export type skillsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: skillsWhereInput
    orderBy?: skillsOrderByWithAggregationInput | skillsOrderByWithAggregationInput[]
    by: SkillsScalarFieldEnum[] | SkillsScalarFieldEnum
    having?: skillsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkillsCountAggregateInputType | true
    _min?: SkillsMinAggregateInputType
    _max?: SkillsMaxAggregateInputType
  }

  export type SkillsGroupByOutputType = {
    id: string
    name: string
    description: string
    _count: SkillsCountAggregateOutputType | null
    _min: SkillsMinAggregateOutputType | null
    _max: SkillsMaxAggregateOutputType | null
  }

  type GetSkillsGroupByPayload<T extends skillsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkillsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkillsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkillsGroupByOutputType[P]>
            : GetScalarType<T[P], SkillsGroupByOutputType[P]>
        }
      >
    >


  export type skillsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    character_skills?: boolean | skills$character_skillsArgs<ExtArgs>
    character_specialties?: boolean | skills$character_specialtiesArgs<ExtArgs>
    _count?: boolean | SkillsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skills"]>

  export type skillsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["skills"]>

  export type skillsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["skills"]>

  export type skillsSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
  }

  export type skillsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description", ExtArgs["result"]["skills"]>
  export type skillsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character_skills?: boolean | skills$character_skillsArgs<ExtArgs>
    character_specialties?: boolean | skills$character_specialtiesArgs<ExtArgs>
    _count?: boolean | SkillsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type skillsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type skillsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $skillsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "skills"
    objects: {
      character_skills: Prisma.$character_skillsPayload<ExtArgs>[]
      character_specialties: Prisma.$character_specialtiesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
    }, ExtArgs["result"]["skills"]>
    composites: {}
  }

  type skillsGetPayload<S extends boolean | null | undefined | skillsDefaultArgs> = $Result.GetResult<Prisma.$skillsPayload, S>

  type skillsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<skillsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SkillsCountAggregateInputType | true
    }

  export interface skillsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['skills'], meta: { name: 'skills' } }
    /**
     * Find zero or one Skills that matches the filter.
     * @param {skillsFindUniqueArgs} args - Arguments to find a Skills
     * @example
     * // Get one Skills
     * const skills = await prisma.skills.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends skillsFindUniqueArgs>(args: SelectSubset<T, skillsFindUniqueArgs<ExtArgs>>): Prisma__skillsClient<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Skills that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {skillsFindUniqueOrThrowArgs} args - Arguments to find a Skills
     * @example
     * // Get one Skills
     * const skills = await prisma.skills.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends skillsFindUniqueOrThrowArgs>(args: SelectSubset<T, skillsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__skillsClient<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Skills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillsFindFirstArgs} args - Arguments to find a Skills
     * @example
     * // Get one Skills
     * const skills = await prisma.skills.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends skillsFindFirstArgs>(args?: SelectSubset<T, skillsFindFirstArgs<ExtArgs>>): Prisma__skillsClient<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Skills that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillsFindFirstOrThrowArgs} args - Arguments to find a Skills
     * @example
     * // Get one Skills
     * const skills = await prisma.skills.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends skillsFindFirstOrThrowArgs>(args?: SelectSubset<T, skillsFindFirstOrThrowArgs<ExtArgs>>): Prisma__skillsClient<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Skills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Skills
     * const skills = await prisma.skills.findMany()
     * 
     * // Get first 10 Skills
     * const skills = await prisma.skills.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skillsWithIdOnly = await prisma.skills.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends skillsFindManyArgs>(args?: SelectSubset<T, skillsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Skills.
     * @param {skillsCreateArgs} args - Arguments to create a Skills.
     * @example
     * // Create one Skills
     * const Skills = await prisma.skills.create({
     *   data: {
     *     // ... data to create a Skills
     *   }
     * })
     * 
     */
    create<T extends skillsCreateArgs>(args: SelectSubset<T, skillsCreateArgs<ExtArgs>>): Prisma__skillsClient<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Skills.
     * @param {skillsCreateManyArgs} args - Arguments to create many Skills.
     * @example
     * // Create many Skills
     * const skills = await prisma.skills.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends skillsCreateManyArgs>(args?: SelectSubset<T, skillsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Skills and returns the data saved in the database.
     * @param {skillsCreateManyAndReturnArgs} args - Arguments to create many Skills.
     * @example
     * // Create many Skills
     * const skills = await prisma.skills.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Skills and only return the `id`
     * const skillsWithIdOnly = await prisma.skills.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends skillsCreateManyAndReturnArgs>(args?: SelectSubset<T, skillsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Skills.
     * @param {skillsDeleteArgs} args - Arguments to delete one Skills.
     * @example
     * // Delete one Skills
     * const Skills = await prisma.skills.delete({
     *   where: {
     *     // ... filter to delete one Skills
     *   }
     * })
     * 
     */
    delete<T extends skillsDeleteArgs>(args: SelectSubset<T, skillsDeleteArgs<ExtArgs>>): Prisma__skillsClient<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Skills.
     * @param {skillsUpdateArgs} args - Arguments to update one Skills.
     * @example
     * // Update one Skills
     * const skills = await prisma.skills.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends skillsUpdateArgs>(args: SelectSubset<T, skillsUpdateArgs<ExtArgs>>): Prisma__skillsClient<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Skills.
     * @param {skillsDeleteManyArgs} args - Arguments to filter Skills to delete.
     * @example
     * // Delete a few Skills
     * const { count } = await prisma.skills.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends skillsDeleteManyArgs>(args?: SelectSubset<T, skillsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Skills
     * const skills = await prisma.skills.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends skillsUpdateManyArgs>(args: SelectSubset<T, skillsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skills and returns the data updated in the database.
     * @param {skillsUpdateManyAndReturnArgs} args - Arguments to update many Skills.
     * @example
     * // Update many Skills
     * const skills = await prisma.skills.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Skills and only return the `id`
     * const skillsWithIdOnly = await prisma.skills.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends skillsUpdateManyAndReturnArgs>(args: SelectSubset<T, skillsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Skills.
     * @param {skillsUpsertArgs} args - Arguments to update or create a Skills.
     * @example
     * // Update or create a Skills
     * const skills = await prisma.skills.upsert({
     *   create: {
     *     // ... data to create a Skills
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Skills we want to update
     *   }
     * })
     */
    upsert<T extends skillsUpsertArgs>(args: SelectSubset<T, skillsUpsertArgs<ExtArgs>>): Prisma__skillsClient<$Result.GetResult<Prisma.$skillsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillsCountArgs} args - Arguments to filter Skills to count.
     * @example
     * // Count the number of Skills
     * const count = await prisma.skills.count({
     *   where: {
     *     // ... the filter for the Skills we want to count
     *   }
     * })
    **/
    count<T extends skillsCountArgs>(
      args?: Subset<T, skillsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkillsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkillsAggregateArgs>(args: Subset<T, SkillsAggregateArgs>): Prisma.PrismaPromise<GetSkillsAggregateType<T>>

    /**
     * Group by Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {skillsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends skillsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: skillsGroupByArgs['orderBy'] }
        : { orderBy?: skillsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, skillsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkillsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the skills model
   */
  readonly fields: skillsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for skills.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__skillsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    character_skills<T extends skills$character_skillsArgs<ExtArgs> = {}>(args?: Subset<T, skills$character_skillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_skillsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    character_specialties<T extends skills$character_specialtiesArgs<ExtArgs> = {}>(args?: Subset<T, skills$character_specialtiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$character_specialtiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the skills model
   */
  interface skillsFieldRefs {
    readonly id: FieldRef<"skills", 'String'>
    readonly name: FieldRef<"skills", 'String'>
    readonly description: FieldRef<"skills", 'String'>
  }
    

  // Custom InputTypes
  /**
   * skills findUnique
   */
  export type skillsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skills
     */
    omit?: skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillsInclude<ExtArgs> | null
    /**
     * Filter, which skills to fetch.
     */
    where: skillsWhereUniqueInput
  }

  /**
   * skills findUniqueOrThrow
   */
  export type skillsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skills
     */
    omit?: skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillsInclude<ExtArgs> | null
    /**
     * Filter, which skills to fetch.
     */
    where: skillsWhereUniqueInput
  }

  /**
   * skills findFirst
   */
  export type skillsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skills
     */
    omit?: skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillsInclude<ExtArgs> | null
    /**
     * Filter, which skills to fetch.
     */
    where?: skillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skills to fetch.
     */
    orderBy?: skillsOrderByWithRelationInput | skillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for skills.
     */
    cursor?: skillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of skills.
     */
    distinct?: SkillsScalarFieldEnum | SkillsScalarFieldEnum[]
  }

  /**
   * skills findFirstOrThrow
   */
  export type skillsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skills
     */
    omit?: skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillsInclude<ExtArgs> | null
    /**
     * Filter, which skills to fetch.
     */
    where?: skillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skills to fetch.
     */
    orderBy?: skillsOrderByWithRelationInput | skillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for skills.
     */
    cursor?: skillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of skills.
     */
    distinct?: SkillsScalarFieldEnum | SkillsScalarFieldEnum[]
  }

  /**
   * skills findMany
   */
  export type skillsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skills
     */
    omit?: skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillsInclude<ExtArgs> | null
    /**
     * Filter, which skills to fetch.
     */
    where?: skillsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of skills to fetch.
     */
    orderBy?: skillsOrderByWithRelationInput | skillsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing skills.
     */
    cursor?: skillsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` skills.
     */
    skip?: number
    distinct?: SkillsScalarFieldEnum | SkillsScalarFieldEnum[]
  }

  /**
   * skills create
   */
  export type skillsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skills
     */
    omit?: skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillsInclude<ExtArgs> | null
    /**
     * The data needed to create a skills.
     */
    data: XOR<skillsCreateInput, skillsUncheckedCreateInput>
  }

  /**
   * skills createMany
   */
  export type skillsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many skills.
     */
    data: skillsCreateManyInput | skillsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * skills createManyAndReturn
   */
  export type skillsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the skills
     */
    omit?: skillsOmit<ExtArgs> | null
    /**
     * The data used to create many skills.
     */
    data: skillsCreateManyInput | skillsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * skills update
   */
  export type skillsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skills
     */
    omit?: skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillsInclude<ExtArgs> | null
    /**
     * The data needed to update a skills.
     */
    data: XOR<skillsUpdateInput, skillsUncheckedUpdateInput>
    /**
     * Choose, which skills to update.
     */
    where: skillsWhereUniqueInput
  }

  /**
   * skills updateMany
   */
  export type skillsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update skills.
     */
    data: XOR<skillsUpdateManyMutationInput, skillsUncheckedUpdateManyInput>
    /**
     * Filter which skills to update
     */
    where?: skillsWhereInput
    /**
     * Limit how many skills to update.
     */
    limit?: number
  }

  /**
   * skills updateManyAndReturn
   */
  export type skillsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the skills
     */
    omit?: skillsOmit<ExtArgs> | null
    /**
     * The data used to update skills.
     */
    data: XOR<skillsUpdateManyMutationInput, skillsUncheckedUpdateManyInput>
    /**
     * Filter which skills to update
     */
    where?: skillsWhereInput
    /**
     * Limit how many skills to update.
     */
    limit?: number
  }

  /**
   * skills upsert
   */
  export type skillsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skills
     */
    omit?: skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillsInclude<ExtArgs> | null
    /**
     * The filter to search for the skills to update in case it exists.
     */
    where: skillsWhereUniqueInput
    /**
     * In case the skills found by the `where` argument doesn't exist, create a new skills with this data.
     */
    create: XOR<skillsCreateInput, skillsUncheckedCreateInput>
    /**
     * In case the skills was found with the provided `where` argument, update it with this data.
     */
    update: XOR<skillsUpdateInput, skillsUncheckedUpdateInput>
  }

  /**
   * skills delete
   */
  export type skillsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skills
     */
    omit?: skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillsInclude<ExtArgs> | null
    /**
     * Filter which skills to delete.
     */
    where: skillsWhereUniqueInput
  }

  /**
   * skills deleteMany
   */
  export type skillsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which skills to delete
     */
    where?: skillsWhereInput
    /**
     * Limit how many skills to delete.
     */
    limit?: number
  }

  /**
   * skills.character_skills
   */
  export type skills$character_skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_skills
     */
    select?: character_skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_skills
     */
    omit?: character_skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_skillsInclude<ExtArgs> | null
    where?: character_skillsWhereInput
    orderBy?: character_skillsOrderByWithRelationInput | character_skillsOrderByWithRelationInput[]
    cursor?: character_skillsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Character_skillsScalarFieldEnum | Character_skillsScalarFieldEnum[]
  }

  /**
   * skills.character_specialties
   */
  export type skills$character_specialtiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the character_specialties
     */
    select?: character_specialtiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the character_specialties
     */
    omit?: character_specialtiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: character_specialtiesInclude<ExtArgs> | null
    where?: character_specialtiesWhereInput
    orderBy?: character_specialtiesOrderByWithRelationInput | character_specialtiesOrderByWithRelationInput[]
    cursor?: character_specialtiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Character_specialtiesScalarFieldEnum | Character_specialtiesScalarFieldEnum[]
  }

  /**
   * skills without action
   */
  export type skillsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the skills
     */
    select?: skillsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the skills
     */
    omit?: skillsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: skillsInclude<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    clerk_user_id: string | null
    email: string | null
    name: string | null
    image_url: string | null
    deleted_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    clerk_user_id: string | null
    email: string | null
    name: string | null
    image_url: string | null
    deleted_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    clerk_user_id: number
    email: number
    name: number
    image_url: number
    deleted_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UsersMinAggregateInputType = {
    id?: true
    clerk_user_id?: true
    email?: true
    name?: true
    image_url?: true
    deleted_at?: true
    created_at?: true
    updated_at?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    clerk_user_id?: true
    email?: true
    name?: true
    image_url?: true
    deleted_at?: true
    created_at?: true
    updated_at?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    clerk_user_id?: true
    email?: true
    name?: true
    image_url?: true
    deleted_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: string
    clerk_user_id: string
    email: string
    name: string
    image_url: string | null
    deleted_at: Date | null
    created_at: Date
    updated_at: Date
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clerk_user_id?: boolean
    email?: boolean
    name?: boolean
    image_url?: boolean
    deleted_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    char_groups?: boolean | users$char_groupsArgs<ExtArgs>
    characters?: boolean | users$charactersArgs<ExtArgs>
    chronicles?: boolean | users$chroniclesArgs<ExtArgs>
    exp_logs?: boolean | users$exp_logsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clerk_user_id?: boolean
    email?: boolean
    name?: boolean
    image_url?: boolean
    deleted_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clerk_user_id?: boolean
    email?: boolean
    name?: boolean
    image_url?: boolean
    deleted_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    id?: boolean
    clerk_user_id?: boolean
    email?: boolean
    name?: boolean
    image_url?: boolean
    deleted_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clerk_user_id" | "email" | "name" | "image_url" | "deleted_at" | "created_at" | "updated_at", ExtArgs["result"]["users"]>
  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    char_groups?: boolean | users$char_groupsArgs<ExtArgs>
    characters?: boolean | users$charactersArgs<ExtArgs>
    chronicles?: boolean | users$chroniclesArgs<ExtArgs>
    exp_logs?: boolean | users$exp_logsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type usersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      char_groups: Prisma.$char_groupsPayload<ExtArgs>[]
      characters: Prisma.$charactersPayload<ExtArgs>[]
      chronicles: Prisma.$chroniclesPayload<ExtArgs>[]
      exp_logs: Prisma.$exp_logsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clerk_user_id: string
      email: string
      name: string
      image_url: string | null
      deleted_at: Date | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {usersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends usersUpdateManyAndReturnArgs>(args: SelectSubset<T, usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    char_groups<T extends users$char_groupsArgs<ExtArgs> = {}>(args?: Subset<T, users$char_groupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$char_groupsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    characters<T extends users$charactersArgs<ExtArgs> = {}>(args?: Subset<T, users$charactersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$charactersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chronicles<T extends users$chroniclesArgs<ExtArgs> = {}>(args?: Subset<T, users$chroniclesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chroniclesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    exp_logs<T extends users$exp_logsArgs<ExtArgs> = {}>(args?: Subset<T, users$exp_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$exp_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'String'>
    readonly clerk_user_id: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly name: FieldRef<"users", 'String'>
    readonly image_url: FieldRef<"users", 'String'>
    readonly deleted_at: FieldRef<"users", 'DateTime'>
    readonly created_at: FieldRef<"users", 'DateTime'>
    readonly updated_at: FieldRef<"users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users updateManyAndReturn
   */
  export type usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users.char_groups
   */
  export type users$char_groupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the char_groups
     */
    select?: char_groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the char_groups
     */
    omit?: char_groupsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: char_groupsInclude<ExtArgs> | null
    where?: char_groupsWhereInput
    orderBy?: char_groupsOrderByWithRelationInput | char_groupsOrderByWithRelationInput[]
    cursor?: char_groupsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Char_groupsScalarFieldEnum | Char_groupsScalarFieldEnum[]
  }

  /**
   * users.characters
   */
  export type users$charactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the characters
     */
    select?: charactersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the characters
     */
    omit?: charactersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: charactersInclude<ExtArgs> | null
    where?: charactersWhereInput
    orderBy?: charactersOrderByWithRelationInput | charactersOrderByWithRelationInput[]
    cursor?: charactersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharactersScalarFieldEnum | CharactersScalarFieldEnum[]
  }

  /**
   * users.chronicles
   */
  export type users$chroniclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chronicles
     */
    select?: chroniclesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chronicles
     */
    omit?: chroniclesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chroniclesInclude<ExtArgs> | null
    where?: chroniclesWhereInput
    orderBy?: chroniclesOrderByWithRelationInput | chroniclesOrderByWithRelationInput[]
    cursor?: chroniclesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChroniclesScalarFieldEnum | ChroniclesScalarFieldEnum[]
  }

  /**
   * users.exp_logs
   */
  export type users$exp_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exp_logs
     */
    select?: exp_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exp_logs
     */
    omit?: exp_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exp_logsInclude<ExtArgs> | null
    where?: exp_logsWhereInput
    orderBy?: exp_logsOrderByWithRelationInput | exp_logsOrderByWithRelationInput[]
    cursor?: exp_logsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Exp_logsScalarFieldEnum | Exp_logsScalarFieldEnum[]
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AdvantagesScalarFieldEnum: {
    id: 'id',
    parent_name: 'parent_name',
    name: 'name',
    description: 'description',
    type: 'type',
    level: 'level',
    for: 'for',
    clan_req: 'clan_req',
    sect_req: 'sect_req'
  };

  export type AdvantagesScalarFieldEnum = (typeof AdvantagesScalarFieldEnum)[keyof typeof AdvantagesScalarFieldEnum]


  export const Alchemy_powersScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    ingridients: 'ingridients',
    activation: 'activation',
    dice_pool: 'dice_pool',
    system: 'system',
    duration: 'duration',
    level: 'level'
  };

  export type Alchemy_powersScalarFieldEnum = (typeof Alchemy_powersScalarFieldEnum)[keyof typeof Alchemy_powersScalarFieldEnum]


  export const AttributesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    category: 'category'
  };

  export type AttributesScalarFieldEnum = (typeof AttributesScalarFieldEnum)[keyof typeof AttributesScalarFieldEnum]


  export const Blood_potencyScalarFieldEnum: {
    id: 'id',
    level: 'level',
    description: 'description',
    blood_surge: 'blood_surge',
    damage_mend: 'damage_mend',
    power_bonus: 'power_bonus',
    rc_reroll: 'rc_reroll',
    bane_severity: 'bane_severity',
    feeding_penalty: 'feeding_penalty'
  };

  export type Blood_potencyScalarFieldEnum = (typeof Blood_potencyScalarFieldEnum)[keyof typeof Blood_potencyScalarFieldEnum]


  export const Char_groupsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    parent_id: 'parent_id',
    name: 'name',
    description: 'description'
  };

  export type Char_groupsScalarFieldEnum = (typeof Char_groupsScalarFieldEnum)[keyof typeof Char_groupsScalarFieldEnum]


  export const Character_advantagesScalarFieldEnum: {
    id: 'id',
    char_id: 'char_id',
    advantage_id: 'advantage_id'
  };

  export type Character_advantagesScalarFieldEnum = (typeof Character_advantagesScalarFieldEnum)[keyof typeof Character_advantagesScalarFieldEnum]


  export const Character_alchemy_powersScalarFieldEnum: {
    id: 'id',
    char_id: 'char_id',
    alchemy_power_id: 'alchemy_power_id'
  };

  export type Character_alchemy_powersScalarFieldEnum = (typeof Character_alchemy_powersScalarFieldEnum)[keyof typeof Character_alchemy_powersScalarFieldEnum]


  export const Character_attributesScalarFieldEnum: {
    id: 'id',
    char_id: 'char_id',
    attribute_id: 'attribute_id',
    level: 'level'
  };

  export type Character_attributesScalarFieldEnum = (typeof Character_attributesScalarFieldEnum)[keyof typeof Character_attributesScalarFieldEnum]


  export const Character_bloodpotenciesScalarFieldEnum: {
    id: 'id',
    char_id: 'char_id',
    blood_potency_level: 'blood_potency_level',
    blood_surge: 'blood_surge',
    bane_severity: 'bane_severity',
    power_bonus: 'power_bonus',
    feeding_penalty: 'feeding_penalty',
    mend_amount: 'mend_amount',
    rc_reroll: 'rc_reroll',
    clane_bane: 'clane_bane',
    clan_compulsion: 'clan_compulsion'
  };

  export type Character_bloodpotenciesScalarFieldEnum = (typeof Character_bloodpotenciesScalarFieldEnum)[keyof typeof Character_bloodpotenciesScalarFieldEnum]


  export const Character_discipline_powersScalarFieldEnum: {
    id: 'id',
    char_id: 'char_id',
    discipline_power_id: 'discipline_power_id'
  };

  export type Character_discipline_powersScalarFieldEnum = (typeof Character_discipline_powersScalarFieldEnum)[keyof typeof Character_discipline_powersScalarFieldEnum]


  export const Character_disciplinesScalarFieldEnum: {
    id: 'id',
    char_id: 'char_id',
    discipline_id: 'discipline_id'
  };

  export type Character_disciplinesScalarFieldEnum = (typeof Character_disciplinesScalarFieldEnum)[keyof typeof Character_disciplinesScalarFieldEnum]


  export const Character_healthsScalarFieldEnum: {
    id: 'id',
    char_id: 'char_id',
    max_health: 'max_health',
    current_aggravated: 'current_aggravated',
    current_superficial: 'current_superficial'
  };

  export type Character_healthsScalarFieldEnum = (typeof Character_healthsScalarFieldEnum)[keyof typeof Character_healthsScalarFieldEnum]


  export const Character_humanityScalarFieldEnum: {
    id: 'id',
    char_id: 'char_id',
    level: 'level',
    stain_count: 'stain_count'
  };

  export type Character_humanityScalarFieldEnum = (typeof Character_humanityScalarFieldEnum)[keyof typeof Character_humanityScalarFieldEnum]


  export const Character_profileScalarFieldEnum: {
    id: 'id',
    char_id: 'char_id',
    description: 'description',
    birthday: 'birthday',
    notes: 'notes',
    age: 'age',
    embraced_at: 'embraced_at',
    apparent_age: 'apparent_age',
    concept: 'concept'
  };

  export type Character_profileScalarFieldEnum = (typeof Character_profileScalarFieldEnum)[keyof typeof Character_profileScalarFieldEnum]


  export const Character_ritualsScalarFieldEnum: {
    id: 'id',
    char_id: 'char_id',
    ritual_id: 'ritual_id'
  };

  export type Character_ritualsScalarFieldEnum = (typeof Character_ritualsScalarFieldEnum)[keyof typeof Character_ritualsScalarFieldEnum]


  export const Character_skillsScalarFieldEnum: {
    id: 'id',
    char_id: 'char_id',
    skill_id: 'skill_id',
    level: 'level'
  };

  export type Character_skillsScalarFieldEnum = (typeof Character_skillsScalarFieldEnum)[keyof typeof Character_skillsScalarFieldEnum]


  export const Character_specialtiesScalarFieldEnum: {
    id: 'id',
    char_id: 'char_id',
    skill_id: 'skill_id',
    specialty_name: 'specialty_name'
  };

  export type Character_specialtiesScalarFieldEnum = (typeof Character_specialtiesScalarFieldEnum)[keyof typeof Character_specialtiesScalarFieldEnum]


  export const Character_willpowersScalarFieldEnum: {
    id: 'id',
    char_id: 'char_id',
    max_willpower: 'max_willpower',
    current_aggravated: 'current_aggravated',
    current_superficial: 'current_superficial'
  };

  export type Character_willpowersScalarFieldEnum = (typeof Character_willpowersScalarFieldEnum)[keyof typeof Character_willpowersScalarFieldEnum]


  export const CharactersScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    name: 'name',
    clan_id: 'clan_id',
    clan_bane: 'clan_bane',
    clan_compulsion: 'clan_compulsion',
    sect_id: 'sect_id',
    player: 'player',
    predator_type: 'predator_type',
    generation: 'generation',
    chronicle_id: 'chronicle_id',
    custom_chronicle: 'custom_chronicle',
    ambition: 'ambition',
    desire: 'desire',
    sire: 'sire',
    total_experience: 'total_experience',
    chronicle_tenets: 'chronicle_tenets',
    group_id: 'group_id',
    type: 'type'
  };

  export type CharactersScalarFieldEnum = (typeof CharactersScalarFieldEnum)[keyof typeof CharactersScalarFieldEnum]


  export const ChroniclesScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    name: 'name',
    description: 'description',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ChroniclesScalarFieldEnum = (typeof ChroniclesScalarFieldEnum)[keyof typeof ChroniclesScalarFieldEnum]


  export const Clan_banesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    clan_id: 'clan_id',
    description: 'description'
  };

  export type Clan_banesScalarFieldEnum = (typeof Clan_banesScalarFieldEnum)[keyof typeof Clan_banesScalarFieldEnum]


  export const Clan_compulsionsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    clan_id: 'clan_id',
    description: 'description'
  };

  export type Clan_compulsionsScalarFieldEnum = (typeof Clan_compulsionsScalarFieldEnum)[keyof typeof Clan_compulsionsScalarFieldEnum]


  export const ClansScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type ClansScalarFieldEnum = (typeof ClansScalarFieldEnum)[keyof typeof ClansScalarFieldEnum]


  export const Discipline_powersScalarFieldEnum: {
    id: 'id',
    discipline_id: 'discipline_id',
    name: 'name',
    level: 'level',
    description: 'description',
    dice_pool: 'dice_pool',
    cost: 'cost',
    prerequisites: 'prerequisites',
    amalgam: 'amalgam',
    system: 'system',
    duration: 'duration'
  };

  export type Discipline_powersScalarFieldEnum = (typeof Discipline_powersScalarFieldEnum)[keyof typeof Discipline_powersScalarFieldEnum]


  export const DisciplinesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    nicknames: 'nicknames',
    characteristics: 'characteristics',
    type: 'type',
    masquerade_threat: 'masquerade_threat',
    blood_resonance: 'blood_resonance'
  };

  export type DisciplinesScalarFieldEnum = (typeof DisciplinesScalarFieldEnum)[keyof typeof DisciplinesScalarFieldEnum]


  export const Exp_logsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    char_id: 'char_id',
    section: 'section',
    name: 'name',
    prev_level: 'prev_level',
    new_level: 'new_level',
    expanditure: 'expanditure',
    created_at: 'created_at'
  };

  export type Exp_logsScalarFieldEnum = (typeof Exp_logsScalarFieldEnum)[keyof typeof Exp_logsScalarFieldEnum]


  export const HumanityScalarFieldEnum: {
    id: 'id',
    description: 'description',
    level: 'level'
  };

  export type HumanityScalarFieldEnum = (typeof HumanityScalarFieldEnum)[keyof typeof HumanityScalarFieldEnum]


  export const Predator_typesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    dice_pool: 'dice_pool',
    benefits: 'benefits'
  };

  export type Predator_typesScalarFieldEnum = (typeof Predator_typesScalarFieldEnum)[keyof typeof Predator_typesScalarFieldEnum]


  export const RitualsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    ingridients: 'ingridients',
    process: 'process',
    system: 'system',
    level: 'level'
  };

  export type RitualsScalarFieldEnum = (typeof RitualsScalarFieldEnum)[keyof typeof RitualsScalarFieldEnum]


  export const SectsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type SectsScalarFieldEnum = (typeof SectsScalarFieldEnum)[keyof typeof SectsScalarFieldEnum]


  export const SkillsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type SkillsScalarFieldEnum = (typeof SkillsScalarFieldEnum)[keyof typeof SkillsScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    clerk_user_id: 'clerk_user_id',
    email: 'email',
    name: 'name',
    image_url: 'image_url',
    deleted_at: 'deleted_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'type'
   */
  export type EnumtypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'type'>
    


  /**
   * Reference to a field of type 'type[]'
   */
  export type ListEnumtypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'type[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'forWhom'
   */
  export type EnumforWhomFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'forWhom'>
    


  /**
   * Reference to a field of type 'forWhom[]'
   */
  export type ListEnumforWhomFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'forWhom[]'>
    


  /**
   * Reference to a field of type 'category'
   */
  export type EnumcategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'category'>
    


  /**
   * Reference to a field of type 'category[]'
   */
  export type ListEnumcategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'category[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Entity'
   */
  export type EnumEntityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Entity'>
    


  /**
   * Reference to a field of type 'Entity[]'
   */
  export type ListEnumEntityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Entity[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type advantagesWhereInput = {
    AND?: advantagesWhereInput | advantagesWhereInput[]
    OR?: advantagesWhereInput[]
    NOT?: advantagesWhereInput | advantagesWhereInput[]
    id?: UuidFilter<"advantages"> | string
    parent_name?: StringNullableFilter<"advantages"> | string | null
    name?: StringFilter<"advantages"> | string
    description?: StringFilter<"advantages"> | string
    type?: EnumtypeFilter<"advantages"> | $Enums.type
    level?: IntFilter<"advantages"> | number
    for?: EnumforWhomFilter<"advantages"> | $Enums.forWhom
    clan_req?: UuidNullableFilter<"advantages"> | string | null
    sect_req?: UuidNullableFilter<"advantages"> | string | null
    clans?: XOR<ClansNullableScalarRelationFilter, clansWhereInput> | null
    sects?: XOR<SectsNullableScalarRelationFilter, sectsWhereInput> | null
    character_advantages?: Character_advantagesListRelationFilter
  }

  export type advantagesOrderByWithRelationInput = {
    id?: SortOrder
    parent_name?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    level?: SortOrder
    for?: SortOrder
    clan_req?: SortOrderInput | SortOrder
    sect_req?: SortOrderInput | SortOrder
    clans?: clansOrderByWithRelationInput
    sects?: sectsOrderByWithRelationInput
    character_advantages?: character_advantagesOrderByRelationAggregateInput
  }

  export type advantagesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: advantagesWhereInput | advantagesWhereInput[]
    OR?: advantagesWhereInput[]
    NOT?: advantagesWhereInput | advantagesWhereInput[]
    parent_name?: StringNullableFilter<"advantages"> | string | null
    name?: StringFilter<"advantages"> | string
    description?: StringFilter<"advantages"> | string
    type?: EnumtypeFilter<"advantages"> | $Enums.type
    level?: IntFilter<"advantages"> | number
    for?: EnumforWhomFilter<"advantages"> | $Enums.forWhom
    clan_req?: UuidNullableFilter<"advantages"> | string | null
    sect_req?: UuidNullableFilter<"advantages"> | string | null
    clans?: XOR<ClansNullableScalarRelationFilter, clansWhereInput> | null
    sects?: XOR<SectsNullableScalarRelationFilter, sectsWhereInput> | null
    character_advantages?: Character_advantagesListRelationFilter
  }, "id">

  export type advantagesOrderByWithAggregationInput = {
    id?: SortOrder
    parent_name?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    level?: SortOrder
    for?: SortOrder
    clan_req?: SortOrderInput | SortOrder
    sect_req?: SortOrderInput | SortOrder
    _count?: advantagesCountOrderByAggregateInput
    _avg?: advantagesAvgOrderByAggregateInput
    _max?: advantagesMaxOrderByAggregateInput
    _min?: advantagesMinOrderByAggregateInput
    _sum?: advantagesSumOrderByAggregateInput
  }

  export type advantagesScalarWhereWithAggregatesInput = {
    AND?: advantagesScalarWhereWithAggregatesInput | advantagesScalarWhereWithAggregatesInput[]
    OR?: advantagesScalarWhereWithAggregatesInput[]
    NOT?: advantagesScalarWhereWithAggregatesInput | advantagesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"advantages"> | string
    parent_name?: StringNullableWithAggregatesFilter<"advantages"> | string | null
    name?: StringWithAggregatesFilter<"advantages"> | string
    description?: StringWithAggregatesFilter<"advantages"> | string
    type?: EnumtypeWithAggregatesFilter<"advantages"> | $Enums.type
    level?: IntWithAggregatesFilter<"advantages"> | number
    for?: EnumforWhomWithAggregatesFilter<"advantages"> | $Enums.forWhom
    clan_req?: UuidNullableWithAggregatesFilter<"advantages"> | string | null
    sect_req?: UuidNullableWithAggregatesFilter<"advantages"> | string | null
  }

  export type alchemy_powersWhereInput = {
    AND?: alchemy_powersWhereInput | alchemy_powersWhereInput[]
    OR?: alchemy_powersWhereInput[]
    NOT?: alchemy_powersWhereInput | alchemy_powersWhereInput[]
    id?: UuidFilter<"alchemy_powers"> | string
    name?: StringFilter<"alchemy_powers"> | string
    description?: StringNullableFilter<"alchemy_powers"> | string | null
    ingridients?: StringNullableFilter<"alchemy_powers"> | string | null
    activation?: StringNullableFilter<"alchemy_powers"> | string | null
    dice_pool?: StringNullableFilter<"alchemy_powers"> | string | null
    system?: StringNullableFilter<"alchemy_powers"> | string | null
    duration?: StringNullableFilter<"alchemy_powers"> | string | null
    level?: IntNullableFilter<"alchemy_powers"> | number | null
    character_alchemy_powers?: Character_alchemy_powersListRelationFilter
  }

  export type alchemy_powersOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    ingridients?: SortOrderInput | SortOrder
    activation?: SortOrderInput | SortOrder
    dice_pool?: SortOrderInput | SortOrder
    system?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    character_alchemy_powers?: character_alchemy_powersOrderByRelationAggregateInput
  }

  export type alchemy_powersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: alchemy_powersWhereInput | alchemy_powersWhereInput[]
    OR?: alchemy_powersWhereInput[]
    NOT?: alchemy_powersWhereInput | alchemy_powersWhereInput[]
    name?: StringFilter<"alchemy_powers"> | string
    description?: StringNullableFilter<"alchemy_powers"> | string | null
    ingridients?: StringNullableFilter<"alchemy_powers"> | string | null
    activation?: StringNullableFilter<"alchemy_powers"> | string | null
    dice_pool?: StringNullableFilter<"alchemy_powers"> | string | null
    system?: StringNullableFilter<"alchemy_powers"> | string | null
    duration?: StringNullableFilter<"alchemy_powers"> | string | null
    level?: IntNullableFilter<"alchemy_powers"> | number | null
    character_alchemy_powers?: Character_alchemy_powersListRelationFilter
  }, "id">

  export type alchemy_powersOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    ingridients?: SortOrderInput | SortOrder
    activation?: SortOrderInput | SortOrder
    dice_pool?: SortOrderInput | SortOrder
    system?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    _count?: alchemy_powersCountOrderByAggregateInput
    _avg?: alchemy_powersAvgOrderByAggregateInput
    _max?: alchemy_powersMaxOrderByAggregateInput
    _min?: alchemy_powersMinOrderByAggregateInput
    _sum?: alchemy_powersSumOrderByAggregateInput
  }

  export type alchemy_powersScalarWhereWithAggregatesInput = {
    AND?: alchemy_powersScalarWhereWithAggregatesInput | alchemy_powersScalarWhereWithAggregatesInput[]
    OR?: alchemy_powersScalarWhereWithAggregatesInput[]
    NOT?: alchemy_powersScalarWhereWithAggregatesInput | alchemy_powersScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"alchemy_powers"> | string
    name?: StringWithAggregatesFilter<"alchemy_powers"> | string
    description?: StringNullableWithAggregatesFilter<"alchemy_powers"> | string | null
    ingridients?: StringNullableWithAggregatesFilter<"alchemy_powers"> | string | null
    activation?: StringNullableWithAggregatesFilter<"alchemy_powers"> | string | null
    dice_pool?: StringNullableWithAggregatesFilter<"alchemy_powers"> | string | null
    system?: StringNullableWithAggregatesFilter<"alchemy_powers"> | string | null
    duration?: StringNullableWithAggregatesFilter<"alchemy_powers"> | string | null
    level?: IntNullableWithAggregatesFilter<"alchemy_powers"> | number | null
  }

  export type attributesWhereInput = {
    AND?: attributesWhereInput | attributesWhereInput[]
    OR?: attributesWhereInput[]
    NOT?: attributesWhereInput | attributesWhereInput[]
    id?: UuidFilter<"attributes"> | string
    name?: StringFilter<"attributes"> | string
    description?: StringFilter<"attributes"> | string
    category?: EnumcategoryFilter<"attributes"> | $Enums.category
    character_attributes?: Character_attributesListRelationFilter
  }

  export type attributesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    character_attributes?: character_attributesOrderByRelationAggregateInput
  }

  export type attributesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: attributesWhereInput | attributesWhereInput[]
    OR?: attributesWhereInput[]
    NOT?: attributesWhereInput | attributesWhereInput[]
    name?: StringFilter<"attributes"> | string
    description?: StringFilter<"attributes"> | string
    category?: EnumcategoryFilter<"attributes"> | $Enums.category
    character_attributes?: Character_attributesListRelationFilter
  }, "id">

  export type attributesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    _count?: attributesCountOrderByAggregateInput
    _max?: attributesMaxOrderByAggregateInput
    _min?: attributesMinOrderByAggregateInput
  }

  export type attributesScalarWhereWithAggregatesInput = {
    AND?: attributesScalarWhereWithAggregatesInput | attributesScalarWhereWithAggregatesInput[]
    OR?: attributesScalarWhereWithAggregatesInput[]
    NOT?: attributesScalarWhereWithAggregatesInput | attributesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"attributes"> | string
    name?: StringWithAggregatesFilter<"attributes"> | string
    description?: StringWithAggregatesFilter<"attributes"> | string
    category?: EnumcategoryWithAggregatesFilter<"attributes"> | $Enums.category
  }

  export type blood_potencyWhereInput = {
    AND?: blood_potencyWhereInput | blood_potencyWhereInput[]
    OR?: blood_potencyWhereInput[]
    NOT?: blood_potencyWhereInput | blood_potencyWhereInput[]
    id?: UuidFilter<"blood_potency"> | string
    level?: IntFilter<"blood_potency"> | number
    description?: StringNullableFilter<"blood_potency"> | string | null
    blood_surge?: StringNullableFilter<"blood_potency"> | string | null
    damage_mend?: StringNullableFilter<"blood_potency"> | string | null
    power_bonus?: StringNullableFilter<"blood_potency"> | string | null
    rc_reroll?: StringNullableFilter<"blood_potency"> | string | null
    bane_severity?: IntNullableFilter<"blood_potency"> | number | null
    feeding_penalty?: StringNullableFilter<"blood_potency"> | string | null
    character_bloodpotencies?: Character_bloodpotenciesListRelationFilter
  }

  export type blood_potencyOrderByWithRelationInput = {
    id?: SortOrder
    level?: SortOrder
    description?: SortOrderInput | SortOrder
    blood_surge?: SortOrderInput | SortOrder
    damage_mend?: SortOrderInput | SortOrder
    power_bonus?: SortOrderInput | SortOrder
    rc_reroll?: SortOrderInput | SortOrder
    bane_severity?: SortOrderInput | SortOrder
    feeding_penalty?: SortOrderInput | SortOrder
    character_bloodpotencies?: character_bloodpotenciesOrderByRelationAggregateInput
  }

  export type blood_potencyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: blood_potencyWhereInput | blood_potencyWhereInput[]
    OR?: blood_potencyWhereInput[]
    NOT?: blood_potencyWhereInput | blood_potencyWhereInput[]
    level?: IntFilter<"blood_potency"> | number
    description?: StringNullableFilter<"blood_potency"> | string | null
    blood_surge?: StringNullableFilter<"blood_potency"> | string | null
    damage_mend?: StringNullableFilter<"blood_potency"> | string | null
    power_bonus?: StringNullableFilter<"blood_potency"> | string | null
    rc_reroll?: StringNullableFilter<"blood_potency"> | string | null
    bane_severity?: IntNullableFilter<"blood_potency"> | number | null
    feeding_penalty?: StringNullableFilter<"blood_potency"> | string | null
    character_bloodpotencies?: Character_bloodpotenciesListRelationFilter
  }, "id">

  export type blood_potencyOrderByWithAggregationInput = {
    id?: SortOrder
    level?: SortOrder
    description?: SortOrderInput | SortOrder
    blood_surge?: SortOrderInput | SortOrder
    damage_mend?: SortOrderInput | SortOrder
    power_bonus?: SortOrderInput | SortOrder
    rc_reroll?: SortOrderInput | SortOrder
    bane_severity?: SortOrderInput | SortOrder
    feeding_penalty?: SortOrderInput | SortOrder
    _count?: blood_potencyCountOrderByAggregateInput
    _avg?: blood_potencyAvgOrderByAggregateInput
    _max?: blood_potencyMaxOrderByAggregateInput
    _min?: blood_potencyMinOrderByAggregateInput
    _sum?: blood_potencySumOrderByAggregateInput
  }

  export type blood_potencyScalarWhereWithAggregatesInput = {
    AND?: blood_potencyScalarWhereWithAggregatesInput | blood_potencyScalarWhereWithAggregatesInput[]
    OR?: blood_potencyScalarWhereWithAggregatesInput[]
    NOT?: blood_potencyScalarWhereWithAggregatesInput | blood_potencyScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"blood_potency"> | string
    level?: IntWithAggregatesFilter<"blood_potency"> | number
    description?: StringNullableWithAggregatesFilter<"blood_potency"> | string | null
    blood_surge?: StringNullableWithAggregatesFilter<"blood_potency"> | string | null
    damage_mend?: StringNullableWithAggregatesFilter<"blood_potency"> | string | null
    power_bonus?: StringNullableWithAggregatesFilter<"blood_potency"> | string | null
    rc_reroll?: StringNullableWithAggregatesFilter<"blood_potency"> | string | null
    bane_severity?: IntNullableWithAggregatesFilter<"blood_potency"> | number | null
    feeding_penalty?: StringNullableWithAggregatesFilter<"blood_potency"> | string | null
  }

  export type char_groupsWhereInput = {
    AND?: char_groupsWhereInput | char_groupsWhereInput[]
    OR?: char_groupsWhereInput[]
    NOT?: char_groupsWhereInput | char_groupsWhereInput[]
    id?: UuidFilter<"char_groups"> | string
    user_id?: UuidFilter<"char_groups"> | string
    parent_id?: UuidNullableFilter<"char_groups"> | string | null
    name?: StringFilter<"char_groups"> | string
    description?: StringFilter<"char_groups"> | string
    char_groups?: XOR<Char_groupsNullableScalarRelationFilter, char_groupsWhereInput> | null
    other_char_groups?: Char_groupsListRelationFilter
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    characters?: CharactersListRelationFilter
  }

  export type char_groupsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    parent_id?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrder
    char_groups?: char_groupsOrderByWithRelationInput
    other_char_groups?: char_groupsOrderByRelationAggregateInput
    users?: usersOrderByWithRelationInput
    characters?: charactersOrderByRelationAggregateInput
  }

  export type char_groupsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: char_groupsWhereInput | char_groupsWhereInput[]
    OR?: char_groupsWhereInput[]
    NOT?: char_groupsWhereInput | char_groupsWhereInput[]
    user_id?: UuidFilter<"char_groups"> | string
    parent_id?: UuidNullableFilter<"char_groups"> | string | null
    name?: StringFilter<"char_groups"> | string
    description?: StringFilter<"char_groups"> | string
    char_groups?: XOR<Char_groupsNullableScalarRelationFilter, char_groupsWhereInput> | null
    other_char_groups?: Char_groupsListRelationFilter
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    characters?: CharactersListRelationFilter
  }, "id">

  export type char_groupsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    parent_id?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrder
    _count?: char_groupsCountOrderByAggregateInput
    _max?: char_groupsMaxOrderByAggregateInput
    _min?: char_groupsMinOrderByAggregateInput
  }

  export type char_groupsScalarWhereWithAggregatesInput = {
    AND?: char_groupsScalarWhereWithAggregatesInput | char_groupsScalarWhereWithAggregatesInput[]
    OR?: char_groupsScalarWhereWithAggregatesInput[]
    NOT?: char_groupsScalarWhereWithAggregatesInput | char_groupsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"char_groups"> | string
    user_id?: UuidWithAggregatesFilter<"char_groups"> | string
    parent_id?: UuidNullableWithAggregatesFilter<"char_groups"> | string | null
    name?: StringWithAggregatesFilter<"char_groups"> | string
    description?: StringWithAggregatesFilter<"char_groups"> | string
  }

  export type character_advantagesWhereInput = {
    AND?: character_advantagesWhereInput | character_advantagesWhereInput[]
    OR?: character_advantagesWhereInput[]
    NOT?: character_advantagesWhereInput | character_advantagesWhereInput[]
    id?: UuidFilter<"character_advantages"> | string
    char_id?: UuidFilter<"character_advantages"> | string
    advantage_id?: UuidFilter<"character_advantages"> | string
    advantages?: XOR<AdvantagesScalarRelationFilter, advantagesWhereInput>
    characters?: XOR<CharactersScalarRelationFilter, charactersWhereInput>
  }

  export type character_advantagesOrderByWithRelationInput = {
    id?: SortOrder
    char_id?: SortOrder
    advantage_id?: SortOrder
    advantages?: advantagesOrderByWithRelationInput
    characters?: charactersOrderByWithRelationInput
  }

  export type character_advantagesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: character_advantagesWhereInput | character_advantagesWhereInput[]
    OR?: character_advantagesWhereInput[]
    NOT?: character_advantagesWhereInput | character_advantagesWhereInput[]
    char_id?: UuidFilter<"character_advantages"> | string
    advantage_id?: UuidFilter<"character_advantages"> | string
    advantages?: XOR<AdvantagesScalarRelationFilter, advantagesWhereInput>
    characters?: XOR<CharactersScalarRelationFilter, charactersWhereInput>
  }, "id">

  export type character_advantagesOrderByWithAggregationInput = {
    id?: SortOrder
    char_id?: SortOrder
    advantage_id?: SortOrder
    _count?: character_advantagesCountOrderByAggregateInput
    _max?: character_advantagesMaxOrderByAggregateInput
    _min?: character_advantagesMinOrderByAggregateInput
  }

  export type character_advantagesScalarWhereWithAggregatesInput = {
    AND?: character_advantagesScalarWhereWithAggregatesInput | character_advantagesScalarWhereWithAggregatesInput[]
    OR?: character_advantagesScalarWhereWithAggregatesInput[]
    NOT?: character_advantagesScalarWhereWithAggregatesInput | character_advantagesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"character_advantages"> | string
    char_id?: UuidWithAggregatesFilter<"character_advantages"> | string
    advantage_id?: UuidWithAggregatesFilter<"character_advantages"> | string
  }

  export type character_alchemy_powersWhereInput = {
    AND?: character_alchemy_powersWhereInput | character_alchemy_powersWhereInput[]
    OR?: character_alchemy_powersWhereInput[]
    NOT?: character_alchemy_powersWhereInput | character_alchemy_powersWhereInput[]
    id?: UuidFilter<"character_alchemy_powers"> | string
    char_id?: UuidFilter<"character_alchemy_powers"> | string
    alchemy_power_id?: UuidFilter<"character_alchemy_powers"> | string
    alchemy_powers?: XOR<Alchemy_powersScalarRelationFilter, alchemy_powersWhereInput>
    characters?: XOR<CharactersScalarRelationFilter, charactersWhereInput>
  }

  export type character_alchemy_powersOrderByWithRelationInput = {
    id?: SortOrder
    char_id?: SortOrder
    alchemy_power_id?: SortOrder
    alchemy_powers?: alchemy_powersOrderByWithRelationInput
    characters?: charactersOrderByWithRelationInput
  }

  export type character_alchemy_powersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: character_alchemy_powersWhereInput | character_alchemy_powersWhereInput[]
    OR?: character_alchemy_powersWhereInput[]
    NOT?: character_alchemy_powersWhereInput | character_alchemy_powersWhereInput[]
    char_id?: UuidFilter<"character_alchemy_powers"> | string
    alchemy_power_id?: UuidFilter<"character_alchemy_powers"> | string
    alchemy_powers?: XOR<Alchemy_powersScalarRelationFilter, alchemy_powersWhereInput>
    characters?: XOR<CharactersScalarRelationFilter, charactersWhereInput>
  }, "id">

  export type character_alchemy_powersOrderByWithAggregationInput = {
    id?: SortOrder
    char_id?: SortOrder
    alchemy_power_id?: SortOrder
    _count?: character_alchemy_powersCountOrderByAggregateInput
    _max?: character_alchemy_powersMaxOrderByAggregateInput
    _min?: character_alchemy_powersMinOrderByAggregateInput
  }

  export type character_alchemy_powersScalarWhereWithAggregatesInput = {
    AND?: character_alchemy_powersScalarWhereWithAggregatesInput | character_alchemy_powersScalarWhereWithAggregatesInput[]
    OR?: character_alchemy_powersScalarWhereWithAggregatesInput[]
    NOT?: character_alchemy_powersScalarWhereWithAggregatesInput | character_alchemy_powersScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"character_alchemy_powers"> | string
    char_id?: UuidWithAggregatesFilter<"character_alchemy_powers"> | string
    alchemy_power_id?: UuidWithAggregatesFilter<"character_alchemy_powers"> | string
  }

  export type character_attributesWhereInput = {
    AND?: character_attributesWhereInput | character_attributesWhereInput[]
    OR?: character_attributesWhereInput[]
    NOT?: character_attributesWhereInput | character_attributesWhereInput[]
    id?: UuidFilter<"character_attributes"> | string
    char_id?: UuidFilter<"character_attributes"> | string
    attribute_id?: UuidFilter<"character_attributes"> | string
    level?: IntFilter<"character_attributes"> | number
    attributes?: XOR<AttributesScalarRelationFilter, attributesWhereInput>
    characters?: XOR<CharactersScalarRelationFilter, charactersWhereInput>
  }

  export type character_attributesOrderByWithRelationInput = {
    id?: SortOrder
    char_id?: SortOrder
    attribute_id?: SortOrder
    level?: SortOrder
    attributes?: attributesOrderByWithRelationInput
    characters?: charactersOrderByWithRelationInput
  }

  export type character_attributesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: character_attributesWhereInput | character_attributesWhereInput[]
    OR?: character_attributesWhereInput[]
    NOT?: character_attributesWhereInput | character_attributesWhereInput[]
    char_id?: UuidFilter<"character_attributes"> | string
    attribute_id?: UuidFilter<"character_attributes"> | string
    level?: IntFilter<"character_attributes"> | number
    attributes?: XOR<AttributesScalarRelationFilter, attributesWhereInput>
    characters?: XOR<CharactersScalarRelationFilter, charactersWhereInput>
  }, "id">

  export type character_attributesOrderByWithAggregationInput = {
    id?: SortOrder
    char_id?: SortOrder
    attribute_id?: SortOrder
    level?: SortOrder
    _count?: character_attributesCountOrderByAggregateInput
    _avg?: character_attributesAvgOrderByAggregateInput
    _max?: character_attributesMaxOrderByAggregateInput
    _min?: character_attributesMinOrderByAggregateInput
    _sum?: character_attributesSumOrderByAggregateInput
  }

  export type character_attributesScalarWhereWithAggregatesInput = {
    AND?: character_attributesScalarWhereWithAggregatesInput | character_attributesScalarWhereWithAggregatesInput[]
    OR?: character_attributesScalarWhereWithAggregatesInput[]
    NOT?: character_attributesScalarWhereWithAggregatesInput | character_attributesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"character_attributes"> | string
    char_id?: UuidWithAggregatesFilter<"character_attributes"> | string
    attribute_id?: UuidWithAggregatesFilter<"character_attributes"> | string
    level?: IntWithAggregatesFilter<"character_attributes"> | number
  }

  export type character_bloodpotenciesWhereInput = {
    AND?: character_bloodpotenciesWhereInput | character_bloodpotenciesWhereInput[]
    OR?: character_bloodpotenciesWhereInput[]
    NOT?: character_bloodpotenciesWhereInput | character_bloodpotenciesWhereInput[]
    id?: UuidFilter<"character_bloodpotencies"> | string
    char_id?: UuidFilter<"character_bloodpotencies"> | string
    blood_potency_level?: UuidNullableFilter<"character_bloodpotencies"> | string | null
    blood_surge?: StringNullableFilter<"character_bloodpotencies"> | string | null
    bane_severity?: IntNullableFilter<"character_bloodpotencies"> | number | null
    power_bonus?: StringNullableFilter<"character_bloodpotencies"> | string | null
    feeding_penalty?: StringNullableFilter<"character_bloodpotencies"> | string | null
    mend_amount?: IntNullableFilter<"character_bloodpotencies"> | number | null
    rc_reroll?: StringNullableFilter<"character_bloodpotencies"> | string | null
    clane_bane?: UuidNullableFilter<"character_bloodpotencies"> | string | null
    clan_compulsion?: UuidNullableFilter<"character_bloodpotencies"> | string | null
    blood_potency?: XOR<Blood_potencyNullableScalarRelationFilter, blood_potencyWhereInput> | null
    characters?: XOR<CharactersScalarRelationFilter, charactersWhereInput>
    clan_compulsions?: XOR<Clan_compulsionsNullableScalarRelationFilter, clan_compulsionsWhereInput> | null
    clan_banes?: XOR<Clan_banesNullableScalarRelationFilter, clan_banesWhereInput> | null
  }

  export type character_bloodpotenciesOrderByWithRelationInput = {
    id?: SortOrder
    char_id?: SortOrder
    blood_potency_level?: SortOrderInput | SortOrder
    blood_surge?: SortOrderInput | SortOrder
    bane_severity?: SortOrderInput | SortOrder
    power_bonus?: SortOrderInput | SortOrder
    feeding_penalty?: SortOrderInput | SortOrder
    mend_amount?: SortOrderInput | SortOrder
    rc_reroll?: SortOrderInput | SortOrder
    clane_bane?: SortOrderInput | SortOrder
    clan_compulsion?: SortOrderInput | SortOrder
    blood_potency?: blood_potencyOrderByWithRelationInput
    characters?: charactersOrderByWithRelationInput
    clan_compulsions?: clan_compulsionsOrderByWithRelationInput
    clan_banes?: clan_banesOrderByWithRelationInput
  }

  export type character_bloodpotenciesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: character_bloodpotenciesWhereInput | character_bloodpotenciesWhereInput[]
    OR?: character_bloodpotenciesWhereInput[]
    NOT?: character_bloodpotenciesWhereInput | character_bloodpotenciesWhereInput[]
    char_id?: UuidFilter<"character_bloodpotencies"> | string
    blood_potency_level?: UuidNullableFilter<"character_bloodpotencies"> | string | null
    blood_surge?: StringNullableFilter<"character_bloodpotencies"> | string | null
    bane_severity?: IntNullableFilter<"character_bloodpotencies"> | number | null
    power_bonus?: StringNullableFilter<"character_bloodpotencies"> | string | null
    feeding_penalty?: StringNullableFilter<"character_bloodpotencies"> | string | null
    mend_amount?: IntNullableFilter<"character_bloodpotencies"> | number | null
    rc_reroll?: StringNullableFilter<"character_bloodpotencies"> | string | null
    clane_bane?: UuidNullableFilter<"character_bloodpotencies"> | string | null
    clan_compulsion?: UuidNullableFilter<"character_bloodpotencies"> | string | null
    blood_potency?: XOR<Blood_potencyNullableScalarRelationFilter, blood_potencyWhereInput> | null
    characters?: XOR<CharactersScalarRelationFilter, charactersWhereInput>
    clan_compulsions?: XOR<Clan_compulsionsNullableScalarRelationFilter, clan_compulsionsWhereInput> | null
    clan_banes?: XOR<Clan_banesNullableScalarRelationFilter, clan_banesWhereInput> | null
  }, "id">

  export type character_bloodpotenciesOrderByWithAggregationInput = {
    id?: SortOrder
    char_id?: SortOrder
    blood_potency_level?: SortOrderInput | SortOrder
    blood_surge?: SortOrderInput | SortOrder
    bane_severity?: SortOrderInput | SortOrder
    power_bonus?: SortOrderInput | SortOrder
    feeding_penalty?: SortOrderInput | SortOrder
    mend_amount?: SortOrderInput | SortOrder
    rc_reroll?: SortOrderInput | SortOrder
    clane_bane?: SortOrderInput | SortOrder
    clan_compulsion?: SortOrderInput | SortOrder
    _count?: character_bloodpotenciesCountOrderByAggregateInput
    _avg?: character_bloodpotenciesAvgOrderByAggregateInput
    _max?: character_bloodpotenciesMaxOrderByAggregateInput
    _min?: character_bloodpotenciesMinOrderByAggregateInput
    _sum?: character_bloodpotenciesSumOrderByAggregateInput
  }

  export type character_bloodpotenciesScalarWhereWithAggregatesInput = {
    AND?: character_bloodpotenciesScalarWhereWithAggregatesInput | character_bloodpotenciesScalarWhereWithAggregatesInput[]
    OR?: character_bloodpotenciesScalarWhereWithAggregatesInput[]
    NOT?: character_bloodpotenciesScalarWhereWithAggregatesInput | character_bloodpotenciesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"character_bloodpotencies"> | string
    char_id?: UuidWithAggregatesFilter<"character_bloodpotencies"> | string
    blood_potency_level?: UuidNullableWithAggregatesFilter<"character_bloodpotencies"> | string | null
    blood_surge?: StringNullableWithAggregatesFilter<"character_bloodpotencies"> | string | null
    bane_severity?: IntNullableWithAggregatesFilter<"character_bloodpotencies"> | number | null
    power_bonus?: StringNullableWithAggregatesFilter<"character_bloodpotencies"> | string | null
    feeding_penalty?: StringNullableWithAggregatesFilter<"character_bloodpotencies"> | string | null
    mend_amount?: IntNullableWithAggregatesFilter<"character_bloodpotencies"> | number | null
    rc_reroll?: StringNullableWithAggregatesFilter<"character_bloodpotencies"> | string | null
    clane_bane?: UuidNullableWithAggregatesFilter<"character_bloodpotencies"> | string | null
    clan_compulsion?: UuidNullableWithAggregatesFilter<"character_bloodpotencies"> | string | null
  }

  export type character_discipline_powersWhereInput = {
    AND?: character_discipline_powersWhereInput | character_discipline_powersWhereInput[]
    OR?: character_discipline_powersWhereInput[]
    NOT?: character_discipline_powersWhereInput | character_discipline_powersWhereInput[]
    id?: UuidFilter<"character_discipline_powers"> | string
    char_id?: UuidFilter<"character_discipline_powers"> | string
    discipline_power_id?: UuidFilter<"character_discipline_powers"> | string
    characters?: XOR<CharactersScalarRelationFilter, charactersWhereInput>
    discipline_powers?: XOR<Discipline_powersScalarRelationFilter, discipline_powersWhereInput>
  }

  export type character_discipline_powersOrderByWithRelationInput = {
    id?: SortOrder
    char_id?: SortOrder
    discipline_power_id?: SortOrder
    characters?: charactersOrderByWithRelationInput
    discipline_powers?: discipline_powersOrderByWithRelationInput
  }

  export type character_discipline_powersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: character_discipline_powersWhereInput | character_discipline_powersWhereInput[]
    OR?: character_discipline_powersWhereInput[]
    NOT?: character_discipline_powersWhereInput | character_discipline_powersWhereInput[]
    char_id?: UuidFilter<"character_discipline_powers"> | string
    discipline_power_id?: UuidFilter<"character_discipline_powers"> | string
    characters?: XOR<CharactersScalarRelationFilter, charactersWhereInput>
    discipline_powers?: XOR<Discipline_powersScalarRelationFilter, discipline_powersWhereInput>
  }, "id">

  export type character_discipline_powersOrderByWithAggregationInput = {
    id?: SortOrder
    char_id?: SortOrder
    discipline_power_id?: SortOrder
    _count?: character_discipline_powersCountOrderByAggregateInput
    _max?: character_discipline_powersMaxOrderByAggregateInput
    _min?: character_discipline_powersMinOrderByAggregateInput
  }

  export type character_discipline_powersScalarWhereWithAggregatesInput = {
    AND?: character_discipline_powersScalarWhereWithAggregatesInput | character_discipline_powersScalarWhereWithAggregatesInput[]
    OR?: character_discipline_powersScalarWhereWithAggregatesInput[]
    NOT?: character_discipline_powersScalarWhereWithAggregatesInput | character_discipline_powersScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"character_discipline_powers"> | string
    char_id?: UuidWithAggregatesFilter<"character_discipline_powers"> | string
    discipline_power_id?: UuidWithAggregatesFilter<"character_discipline_powers"> | string
  }

  export type character_disciplinesWhereInput = {
    AND?: character_disciplinesWhereInput | character_disciplinesWhereInput[]
    OR?: character_disciplinesWhereInput[]
    NOT?: character_disciplinesWhereInput | character_disciplinesWhereInput[]
    id?: UuidFilter<"character_disciplines"> | string
    char_id?: UuidFilter<"character_disciplines"> | string
    discipline_id?: UuidFilter<"character_disciplines"> | string
    characters?: XOR<CharactersScalarRelationFilter, charactersWhereInput>
    disciplines?: XOR<DisciplinesScalarRelationFilter, disciplinesWhereInput>
  }

  export type character_disciplinesOrderByWithRelationInput = {
    id?: SortOrder
    char_id?: SortOrder
    discipline_id?: SortOrder
    characters?: charactersOrderByWithRelationInput
    disciplines?: disciplinesOrderByWithRelationInput
  }

  export type character_disciplinesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: character_disciplinesWhereInput | character_disciplinesWhereInput[]
    OR?: character_disciplinesWhereInput[]
    NOT?: character_disciplinesWhereInput | character_disciplinesWhereInput[]
    char_id?: UuidFilter<"character_disciplines"> | string
    discipline_id?: UuidFilter<"character_disciplines"> | string
    characters?: XOR<CharactersScalarRelationFilter, charactersWhereInput>
    disciplines?: XOR<DisciplinesScalarRelationFilter, disciplinesWhereInput>
  }, "id">

  export type character_disciplinesOrderByWithAggregationInput = {
    id?: SortOrder
    char_id?: SortOrder
    discipline_id?: SortOrder
    _count?: character_disciplinesCountOrderByAggregateInput
    _max?: character_disciplinesMaxOrderByAggregateInput
    _min?: character_disciplinesMinOrderByAggregateInput
  }

  export type character_disciplinesScalarWhereWithAggregatesInput = {
    AND?: character_disciplinesScalarWhereWithAggregatesInput | character_disciplinesScalarWhereWithAggregatesInput[]
    OR?: character_disciplinesScalarWhereWithAggregatesInput[]
    NOT?: character_disciplinesScalarWhereWithAggregatesInput | character_disciplinesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"character_disciplines"> | string
    char_id?: UuidWithAggregatesFilter<"character_disciplines"> | string
    discipline_id?: UuidWithAggregatesFilter<"character_disciplines"> | string
  }

  export type character_healthsWhereInput = {
    AND?: character_healthsWhereInput | character_healthsWhereInput[]
    OR?: character_healthsWhereInput[]
    NOT?: character_healthsWhereInput | character_healthsWhereInput[]
    id?: UuidFilter<"character_healths"> | string
    char_id?: UuidFilter<"character_healths"> | string
    max_health?: IntFilter<"character_healths"> | number
    current_aggravated?: IntFilter<"character_healths"> | number
    current_superficial?: IntFilter<"character_healths"> | number
    characters?: XOR<CharactersScalarRelationFilter, charactersWhereInput>
  }

  export type character_healthsOrderByWithRelationInput = {
    id?: SortOrder
    char_id?: SortOrder
    max_health?: SortOrder
    current_aggravated?: SortOrder
    current_superficial?: SortOrder
    characters?: charactersOrderByWithRelationInput
  }

  export type character_healthsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: character_healthsWhereInput | character_healthsWhereInput[]
    OR?: character_healthsWhereInput[]
    NOT?: character_healthsWhereInput | character_healthsWhereInput[]
    char_id?: UuidFilter<"character_healths"> | string
    max_health?: IntFilter<"character_healths"> | number
    current_aggravated?: IntFilter<"character_healths"> | number
    current_superficial?: IntFilter<"character_healths"> | number
    characters?: XOR<CharactersScalarRelationFilter, charactersWhereInput>
  }, "id">

  export type character_healthsOrderByWithAggregationInput = {
    id?: SortOrder
    char_id?: SortOrder
    max_health?: SortOrder
    current_aggravated?: SortOrder
    current_superficial?: SortOrder
    _count?: character_healthsCountOrderByAggregateInput
    _avg?: character_healthsAvgOrderByAggregateInput
    _max?: character_healthsMaxOrderByAggregateInput
    _min?: character_healthsMinOrderByAggregateInput
    _sum?: character_healthsSumOrderByAggregateInput
  }

  export type character_healthsScalarWhereWithAggregatesInput = {
    AND?: character_healthsScalarWhereWithAggregatesInput | character_healthsScalarWhereWithAggregatesInput[]
    OR?: character_healthsScalarWhereWithAggregatesInput[]
    NOT?: character_healthsScalarWhereWithAggregatesInput | character_healthsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"character_healths"> | string
    char_id?: UuidWithAggregatesFilter<"character_healths"> | string
    max_health?: IntWithAggregatesFilter<"character_healths"> | number
    current_aggravated?: IntWithAggregatesFilter<"character_healths"> | number
    current_superficial?: IntWithAggregatesFilter<"character_healths"> | number
  }

  export type character_humanityWhereInput = {
    AND?: character_humanityWhereInput | character_humanityWhereInput[]
    OR?: character_humanityWhereInput[]
    NOT?: character_humanityWhereInput | character_humanityWhereInput[]
    id?: UuidFilter<"character_humanity"> | string
    char_id?: UuidFilter<"character_humanity"> | string
    level?: IntFilter<"character_humanity"> | number
    stain_count?: IntFilter<"character_humanity"> | number
    characters?: XOR<CharactersScalarRelationFilter, charactersWhereInput>
  }

  export type character_humanityOrderByWithRelationInput = {
    id?: SortOrder
    char_id?: SortOrder
    level?: SortOrder
    stain_count?: SortOrder
    characters?: charactersOrderByWithRelationInput
  }

  export type character_humanityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: character_humanityWhereInput | character_humanityWhereInput[]
    OR?: character_humanityWhereInput[]
    NOT?: character_humanityWhereInput | character_humanityWhereInput[]
    char_id?: UuidFilter<"character_humanity"> | string
    level?: IntFilter<"character_humanity"> | number
    stain_count?: IntFilter<"character_humanity"> | number
    characters?: XOR<CharactersScalarRelationFilter, charactersWhereInput>
  }, "id">

  export type character_humanityOrderByWithAggregationInput = {
    id?: SortOrder
    char_id?: SortOrder
    level?: SortOrder
    stain_count?: SortOrder
    _count?: character_humanityCountOrderByAggregateInput
    _avg?: character_humanityAvgOrderByAggregateInput
    _max?: character_humanityMaxOrderByAggregateInput
    _min?: character_humanityMinOrderByAggregateInput
    _sum?: character_humanitySumOrderByAggregateInput
  }

  export type character_humanityScalarWhereWithAggregatesInput = {
    AND?: character_humanityScalarWhereWithAggregatesInput | character_humanityScalarWhereWithAggregatesInput[]
    OR?: character_humanityScalarWhereWithAggregatesInput[]
    NOT?: character_humanityScalarWhereWithAggregatesInput | character_humanityScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"character_humanity"> | string
    char_id?: UuidWithAggregatesFilter<"character_humanity"> | string
    level?: IntWithAggregatesFilter<"character_humanity"> | number
    stain_count?: IntWithAggregatesFilter<"character_humanity"> | number
  }

  export type character_profileWhereInput = {
    AND?: character_profileWhereInput | character_profileWhereInput[]
    OR?: character_profileWhereInput[]
    NOT?: character_profileWhereInput | character_profileWhereInput[]
    id?: UuidFilter<"character_profile"> | string
    char_id?: UuidFilter<"character_profile"> | string
    description?: StringFilter<"character_profile"> | string
    birthday?: DateTimeFilter<"character_profile"> | Date | string
    notes?: StringNullableFilter<"character_profile"> | string | null
    age?: IntFilter<"character_profile"> | number
    embraced_at?: DateTimeFilter<"character_profile"> | Date | string
    apparent_age?: IntFilter<"character_profile"> | number
    concept?: StringNullableFilter<"character_profile"> | string | null
    characters?: XOR<CharactersScalarRelationFilter, charactersWhereInput>
  }

  export type character_profileOrderByWithRelationInput = {
    id?: SortOrder
    char_id?: SortOrder
    description?: SortOrder
    birthday?: SortOrder
    notes?: SortOrderInput | SortOrder
    age?: SortOrder
    embraced_at?: SortOrder
    apparent_age?: SortOrder
    concept?: SortOrderInput | SortOrder
    characters?: charactersOrderByWithRelationInput
  }

  export type character_profileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: character_profileWhereInput | character_profileWhereInput[]
    OR?: character_profileWhereInput[]
    NOT?: character_profileWhereInput | character_profileWhereInput[]
    char_id?: UuidFilter<"character_profile"> | string
    description?: StringFilter<"character_profile"> | string
    birthday?: DateTimeFilter<"character_profile"> | Date | string
    notes?: StringNullableFilter<"character_profile"> | string | null
    age?: IntFilter<"character_profile"> | number
    embraced_at?: DateTimeFilter<"character_profile"> | Date | string
    apparent_age?: IntFilter<"character_profile"> | number
    concept?: StringNullableFilter<"character_profile"> | string | null
    characters?: XOR<CharactersScalarRelationFilter, charactersWhereInput>
  }, "id">

  export type character_profileOrderByWithAggregationInput = {
    id?: SortOrder
    char_id?: SortOrder
    description?: SortOrder
    birthday?: SortOrder
    notes?: SortOrderInput | SortOrder
    age?: SortOrder
    embraced_at?: SortOrder
    apparent_age?: SortOrder
    concept?: SortOrderInput | SortOrder
    _count?: character_profileCountOrderByAggregateInput
    _avg?: character_profileAvgOrderByAggregateInput
    _max?: character_profileMaxOrderByAggregateInput
    _min?: character_profileMinOrderByAggregateInput
    _sum?: character_profileSumOrderByAggregateInput
  }

  export type character_profileScalarWhereWithAggregatesInput = {
    AND?: character_profileScalarWhereWithAggregatesInput | character_profileScalarWhereWithAggregatesInput[]
    OR?: character_profileScalarWhereWithAggregatesInput[]
    NOT?: character_profileScalarWhereWithAggregatesInput | character_profileScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"character_profile"> | string
    char_id?: UuidWithAggregatesFilter<"character_profile"> | string
    description?: StringWithAggregatesFilter<"character_profile"> | string
    birthday?: DateTimeWithAggregatesFilter<"character_profile"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"character_profile"> | string | null
    age?: IntWithAggregatesFilter<"character_profile"> | number
    embraced_at?: DateTimeWithAggregatesFilter<"character_profile"> | Date | string
    apparent_age?: IntWithAggregatesFilter<"character_profile"> | number
    concept?: StringNullableWithAggregatesFilter<"character_profile"> | string | null
  }

  export type character_ritualsWhereInput = {
    AND?: character_ritualsWhereInput | character_ritualsWhereInput[]
    OR?: character_ritualsWhereInput[]
    NOT?: character_ritualsWhereInput | character_ritualsWhereInput[]
    id?: UuidFilter<"character_rituals"> | string
    char_id?: UuidFilter<"character_rituals"> | string
    ritual_id?: UuidFilter<"character_rituals"> | string
    characters?: XOR<CharactersScalarRelationFilter, charactersWhereInput>
    rituals?: XOR<RitualsScalarRelationFilter, ritualsWhereInput>
  }

  export type character_ritualsOrderByWithRelationInput = {
    id?: SortOrder
    char_id?: SortOrder
    ritual_id?: SortOrder
    characters?: charactersOrderByWithRelationInput
    rituals?: ritualsOrderByWithRelationInput
  }

  export type character_ritualsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: character_ritualsWhereInput | character_ritualsWhereInput[]
    OR?: character_ritualsWhereInput[]
    NOT?: character_ritualsWhereInput | character_ritualsWhereInput[]
    char_id?: UuidFilter<"character_rituals"> | string
    ritual_id?: UuidFilter<"character_rituals"> | string
    characters?: XOR<CharactersScalarRelationFilter, charactersWhereInput>
    rituals?: XOR<RitualsScalarRelationFilter, ritualsWhereInput>
  }, "id">

  export type character_ritualsOrderByWithAggregationInput = {
    id?: SortOrder
    char_id?: SortOrder
    ritual_id?: SortOrder
    _count?: character_ritualsCountOrderByAggregateInput
    _max?: character_ritualsMaxOrderByAggregateInput
    _min?: character_ritualsMinOrderByAggregateInput
  }

  export type character_ritualsScalarWhereWithAggregatesInput = {
    AND?: character_ritualsScalarWhereWithAggregatesInput | character_ritualsScalarWhereWithAggregatesInput[]
    OR?: character_ritualsScalarWhereWithAggregatesInput[]
    NOT?: character_ritualsScalarWhereWithAggregatesInput | character_ritualsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"character_rituals"> | string
    char_id?: UuidWithAggregatesFilter<"character_rituals"> | string
    ritual_id?: UuidWithAggregatesFilter<"character_rituals"> | string
  }

  export type character_skillsWhereInput = {
    AND?: character_skillsWhereInput | character_skillsWhereInput[]
    OR?: character_skillsWhereInput[]
    NOT?: character_skillsWhereInput | character_skillsWhereInput[]
    id?: UuidFilter<"character_skills"> | string
    char_id?: UuidFilter<"character_skills"> | string
    skill_id?: UuidFilter<"character_skills"> | string
    level?: IntFilter<"character_skills"> | number
    characters?: XOR<CharactersScalarRelationFilter, charactersWhereInput>
    skills?: XOR<SkillsScalarRelationFilter, skillsWhereInput>
  }

  export type character_skillsOrderByWithRelationInput = {
    id?: SortOrder
    char_id?: SortOrder
    skill_id?: SortOrder
    level?: SortOrder
    characters?: charactersOrderByWithRelationInput
    skills?: skillsOrderByWithRelationInput
  }

  export type character_skillsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: character_skillsWhereInput | character_skillsWhereInput[]
    OR?: character_skillsWhereInput[]
    NOT?: character_skillsWhereInput | character_skillsWhereInput[]
    char_id?: UuidFilter<"character_skills"> | string
    skill_id?: UuidFilter<"character_skills"> | string
    level?: IntFilter<"character_skills"> | number
    characters?: XOR<CharactersScalarRelationFilter, charactersWhereInput>
    skills?: XOR<SkillsScalarRelationFilter, skillsWhereInput>
  }, "id">

  export type character_skillsOrderByWithAggregationInput = {
    id?: SortOrder
    char_id?: SortOrder
    skill_id?: SortOrder
    level?: SortOrder
    _count?: character_skillsCountOrderByAggregateInput
    _avg?: character_skillsAvgOrderByAggregateInput
    _max?: character_skillsMaxOrderByAggregateInput
    _min?: character_skillsMinOrderByAggregateInput
    _sum?: character_skillsSumOrderByAggregateInput
  }

  export type character_skillsScalarWhereWithAggregatesInput = {
    AND?: character_skillsScalarWhereWithAggregatesInput | character_skillsScalarWhereWithAggregatesInput[]
    OR?: character_skillsScalarWhereWithAggregatesInput[]
    NOT?: character_skillsScalarWhereWithAggregatesInput | character_skillsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"character_skills"> | string
    char_id?: UuidWithAggregatesFilter<"character_skills"> | string
    skill_id?: UuidWithAggregatesFilter<"character_skills"> | string
    level?: IntWithAggregatesFilter<"character_skills"> | number
  }

  export type character_specialtiesWhereInput = {
    AND?: character_specialtiesWhereInput | character_specialtiesWhereInput[]
    OR?: character_specialtiesWhereInput[]
    NOT?: character_specialtiesWhereInput | character_specialtiesWhereInput[]
    id?: UuidFilter<"character_specialties"> | string
    char_id?: UuidFilter<"character_specialties"> | string
    skill_id?: UuidFilter<"character_specialties"> | string
    specialty_name?: StringFilter<"character_specialties"> | string
    characters?: XOR<CharactersScalarRelationFilter, charactersWhereInput>
    skills?: XOR<SkillsScalarRelationFilter, skillsWhereInput>
  }

  export type character_specialtiesOrderByWithRelationInput = {
    id?: SortOrder
    char_id?: SortOrder
    skill_id?: SortOrder
    specialty_name?: SortOrder
    characters?: charactersOrderByWithRelationInput
    skills?: skillsOrderByWithRelationInput
  }

  export type character_specialtiesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: character_specialtiesWhereInput | character_specialtiesWhereInput[]
    OR?: character_specialtiesWhereInput[]
    NOT?: character_specialtiesWhereInput | character_specialtiesWhereInput[]
    char_id?: UuidFilter<"character_specialties"> | string
    skill_id?: UuidFilter<"character_specialties"> | string
    specialty_name?: StringFilter<"character_specialties"> | string
    characters?: XOR<CharactersScalarRelationFilter, charactersWhereInput>
    skills?: XOR<SkillsScalarRelationFilter, skillsWhereInput>
  }, "id">

  export type character_specialtiesOrderByWithAggregationInput = {
    id?: SortOrder
    char_id?: SortOrder
    skill_id?: SortOrder
    specialty_name?: SortOrder
    _count?: character_specialtiesCountOrderByAggregateInput
    _max?: character_specialtiesMaxOrderByAggregateInput
    _min?: character_specialtiesMinOrderByAggregateInput
  }

  export type character_specialtiesScalarWhereWithAggregatesInput = {
    AND?: character_specialtiesScalarWhereWithAggregatesInput | character_specialtiesScalarWhereWithAggregatesInput[]
    OR?: character_specialtiesScalarWhereWithAggregatesInput[]
    NOT?: character_specialtiesScalarWhereWithAggregatesInput | character_specialtiesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"character_specialties"> | string
    char_id?: UuidWithAggregatesFilter<"character_specialties"> | string
    skill_id?: UuidWithAggregatesFilter<"character_specialties"> | string
    specialty_name?: StringWithAggregatesFilter<"character_specialties"> | string
  }

  export type character_willpowersWhereInput = {
    AND?: character_willpowersWhereInput | character_willpowersWhereInput[]
    OR?: character_willpowersWhereInput[]
    NOT?: character_willpowersWhereInput | character_willpowersWhereInput[]
    id?: UuidFilter<"character_willpowers"> | string
    char_id?: UuidFilter<"character_willpowers"> | string
    max_willpower?: IntFilter<"character_willpowers"> | number
    current_aggravated?: IntFilter<"character_willpowers"> | number
    current_superficial?: IntFilter<"character_willpowers"> | number
    characters?: XOR<CharactersScalarRelationFilter, charactersWhereInput>
  }

  export type character_willpowersOrderByWithRelationInput = {
    id?: SortOrder
    char_id?: SortOrder
    max_willpower?: SortOrder
    current_aggravated?: SortOrder
    current_superficial?: SortOrder
    characters?: charactersOrderByWithRelationInput
  }

  export type character_willpowersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: character_willpowersWhereInput | character_willpowersWhereInput[]
    OR?: character_willpowersWhereInput[]
    NOT?: character_willpowersWhereInput | character_willpowersWhereInput[]
    char_id?: UuidFilter<"character_willpowers"> | string
    max_willpower?: IntFilter<"character_willpowers"> | number
    current_aggravated?: IntFilter<"character_willpowers"> | number
    current_superficial?: IntFilter<"character_willpowers"> | number
    characters?: XOR<CharactersScalarRelationFilter, charactersWhereInput>
  }, "id">

  export type character_willpowersOrderByWithAggregationInput = {
    id?: SortOrder
    char_id?: SortOrder
    max_willpower?: SortOrder
    current_aggravated?: SortOrder
    current_superficial?: SortOrder
    _count?: character_willpowersCountOrderByAggregateInput
    _avg?: character_willpowersAvgOrderByAggregateInput
    _max?: character_willpowersMaxOrderByAggregateInput
    _min?: character_willpowersMinOrderByAggregateInput
    _sum?: character_willpowersSumOrderByAggregateInput
  }

  export type character_willpowersScalarWhereWithAggregatesInput = {
    AND?: character_willpowersScalarWhereWithAggregatesInput | character_willpowersScalarWhereWithAggregatesInput[]
    OR?: character_willpowersScalarWhereWithAggregatesInput[]
    NOT?: character_willpowersScalarWhereWithAggregatesInput | character_willpowersScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"character_willpowers"> | string
    char_id?: UuidWithAggregatesFilter<"character_willpowers"> | string
    max_willpower?: IntWithAggregatesFilter<"character_willpowers"> | number
    current_aggravated?: IntWithAggregatesFilter<"character_willpowers"> | number
    current_superficial?: IntWithAggregatesFilter<"character_willpowers"> | number
  }

  export type charactersWhereInput = {
    AND?: charactersWhereInput | charactersWhereInput[]
    OR?: charactersWhereInput[]
    NOT?: charactersWhereInput | charactersWhereInput[]
    id?: UuidFilter<"characters"> | string
    user_id?: UuidFilter<"characters"> | string
    name?: StringFilter<"characters"> | string
    clan_id?: UuidNullableFilter<"characters"> | string | null
    clan_bane?: UuidNullableFilter<"characters"> | string | null
    clan_compulsion?: UuidNullableFilter<"characters"> | string | null
    sect_id?: UuidNullableFilter<"characters"> | string | null
    player?: StringFilter<"characters"> | string
    predator_type?: UuidFilter<"characters"> | string
    generation?: IntFilter<"characters"> | number
    chronicle_id?: UuidNullableFilter<"characters"> | string | null
    custom_chronicle?: StringNullableFilter<"characters"> | string | null
    ambition?: StringFilter<"characters"> | string
    desire?: StringFilter<"characters"> | string
    sire?: StringFilter<"characters"> | string
    total_experience?: IntFilter<"characters"> | number
    chronicle_tenets?: StringFilter<"characters"> | string
    group_id?: UuidFilter<"characters"> | string
    type?: EnumEntityFilter<"characters"> | $Enums.Entity
    character_advantages?: Character_advantagesListRelationFilter
    character_alchemy_powers?: Character_alchemy_powersListRelationFilter
    character_attributes?: Character_attributesListRelationFilter
    character_bloodpotencies?: Character_bloodpotenciesListRelationFilter
    character_discipline_powers?: Character_discipline_powersListRelationFilter
    character_disciplines?: Character_disciplinesListRelationFilter
    character_healths?: Character_healthsListRelationFilter
    character_humanity?: Character_humanityListRelationFilter
    character_profile?: Character_profileListRelationFilter
    character_rituals?: Character_ritualsListRelationFilter
    character_skills?: Character_skillsListRelationFilter
    character_specialties?: Character_specialtiesListRelationFilter
    character_willpowers?: Character_willpowersListRelationFilter
    chronicles?: XOR<ChroniclesNullableScalarRelationFilter, chroniclesWhereInput> | null
    clan_banes?: XOR<Clan_banesNullableScalarRelationFilter, clan_banesWhereInput> | null
    clan_compulsions?: XOR<Clan_compulsionsNullableScalarRelationFilter, clan_compulsionsWhereInput> | null
    clans?: XOR<ClansNullableScalarRelationFilter, clansWhereInput> | null
    char_groups?: XOR<Char_groupsScalarRelationFilter, char_groupsWhereInput>
    predator_types?: XOR<Predator_typesScalarRelationFilter, predator_typesWhereInput>
    sects?: XOR<SectsNullableScalarRelationFilter, sectsWhereInput> | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    exp_logs?: Exp_logsListRelationFilter
  }

  export type charactersOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    clan_id?: SortOrderInput | SortOrder
    clan_bane?: SortOrderInput | SortOrder
    clan_compulsion?: SortOrderInput | SortOrder
    sect_id?: SortOrderInput | SortOrder
    player?: SortOrder
    predator_type?: SortOrder
    generation?: SortOrder
    chronicle_id?: SortOrderInput | SortOrder
    custom_chronicle?: SortOrderInput | SortOrder
    ambition?: SortOrder
    desire?: SortOrder
    sire?: SortOrder
    total_experience?: SortOrder
    chronicle_tenets?: SortOrder
    group_id?: SortOrder
    type?: SortOrder
    character_advantages?: character_advantagesOrderByRelationAggregateInput
    character_alchemy_powers?: character_alchemy_powersOrderByRelationAggregateInput
    character_attributes?: character_attributesOrderByRelationAggregateInput
    character_bloodpotencies?: character_bloodpotenciesOrderByRelationAggregateInput
    character_discipline_powers?: character_discipline_powersOrderByRelationAggregateInput
    character_disciplines?: character_disciplinesOrderByRelationAggregateInput
    character_healths?: character_healthsOrderByRelationAggregateInput
    character_humanity?: character_humanityOrderByRelationAggregateInput
    character_profile?: character_profileOrderByRelationAggregateInput
    character_rituals?: character_ritualsOrderByRelationAggregateInput
    character_skills?: character_skillsOrderByRelationAggregateInput
    character_specialties?: character_specialtiesOrderByRelationAggregateInput
    character_willpowers?: character_willpowersOrderByRelationAggregateInput
    chronicles?: chroniclesOrderByWithRelationInput
    clan_banes?: clan_banesOrderByWithRelationInput
    clan_compulsions?: clan_compulsionsOrderByWithRelationInput
    clans?: clansOrderByWithRelationInput
    char_groups?: char_groupsOrderByWithRelationInput
    predator_types?: predator_typesOrderByWithRelationInput
    sects?: sectsOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
    exp_logs?: exp_logsOrderByRelationAggregateInput
  }

  export type charactersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: charactersWhereInput | charactersWhereInput[]
    OR?: charactersWhereInput[]
    NOT?: charactersWhereInput | charactersWhereInput[]
    user_id?: UuidFilter<"characters"> | string
    name?: StringFilter<"characters"> | string
    clan_id?: UuidNullableFilter<"characters"> | string | null
    clan_bane?: UuidNullableFilter<"characters"> | string | null
    clan_compulsion?: UuidNullableFilter<"characters"> | string | null
    sect_id?: UuidNullableFilter<"characters"> | string | null
    player?: StringFilter<"characters"> | string
    predator_type?: UuidFilter<"characters"> | string
    generation?: IntFilter<"characters"> | number
    chronicle_id?: UuidNullableFilter<"characters"> | string | null
    custom_chronicle?: StringNullableFilter<"characters"> | string | null
    ambition?: StringFilter<"characters"> | string
    desire?: StringFilter<"characters"> | string
    sire?: StringFilter<"characters"> | string
    total_experience?: IntFilter<"characters"> | number
    chronicle_tenets?: StringFilter<"characters"> | string
    group_id?: UuidFilter<"characters"> | string
    type?: EnumEntityFilter<"characters"> | $Enums.Entity
    character_advantages?: Character_advantagesListRelationFilter
    character_alchemy_powers?: Character_alchemy_powersListRelationFilter
    character_attributes?: Character_attributesListRelationFilter
    character_bloodpotencies?: Character_bloodpotenciesListRelationFilter
    character_discipline_powers?: Character_discipline_powersListRelationFilter
    character_disciplines?: Character_disciplinesListRelationFilter
    character_healths?: Character_healthsListRelationFilter
    character_humanity?: Character_humanityListRelationFilter
    character_profile?: Character_profileListRelationFilter
    character_rituals?: Character_ritualsListRelationFilter
    character_skills?: Character_skillsListRelationFilter
    character_specialties?: Character_specialtiesListRelationFilter
    character_willpowers?: Character_willpowersListRelationFilter
    chronicles?: XOR<ChroniclesNullableScalarRelationFilter, chroniclesWhereInput> | null
    clan_banes?: XOR<Clan_banesNullableScalarRelationFilter, clan_banesWhereInput> | null
    clan_compulsions?: XOR<Clan_compulsionsNullableScalarRelationFilter, clan_compulsionsWhereInput> | null
    clans?: XOR<ClansNullableScalarRelationFilter, clansWhereInput> | null
    char_groups?: XOR<Char_groupsScalarRelationFilter, char_groupsWhereInput>
    predator_types?: XOR<Predator_typesScalarRelationFilter, predator_typesWhereInput>
    sects?: XOR<SectsNullableScalarRelationFilter, sectsWhereInput> | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    exp_logs?: Exp_logsListRelationFilter
  }, "id">

  export type charactersOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    clan_id?: SortOrderInput | SortOrder
    clan_bane?: SortOrderInput | SortOrder
    clan_compulsion?: SortOrderInput | SortOrder
    sect_id?: SortOrderInput | SortOrder
    player?: SortOrder
    predator_type?: SortOrder
    generation?: SortOrder
    chronicle_id?: SortOrderInput | SortOrder
    custom_chronicle?: SortOrderInput | SortOrder
    ambition?: SortOrder
    desire?: SortOrder
    sire?: SortOrder
    total_experience?: SortOrder
    chronicle_tenets?: SortOrder
    group_id?: SortOrder
    type?: SortOrder
    _count?: charactersCountOrderByAggregateInput
    _avg?: charactersAvgOrderByAggregateInput
    _max?: charactersMaxOrderByAggregateInput
    _min?: charactersMinOrderByAggregateInput
    _sum?: charactersSumOrderByAggregateInput
  }

  export type charactersScalarWhereWithAggregatesInput = {
    AND?: charactersScalarWhereWithAggregatesInput | charactersScalarWhereWithAggregatesInput[]
    OR?: charactersScalarWhereWithAggregatesInput[]
    NOT?: charactersScalarWhereWithAggregatesInput | charactersScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"characters"> | string
    user_id?: UuidWithAggregatesFilter<"characters"> | string
    name?: StringWithAggregatesFilter<"characters"> | string
    clan_id?: UuidNullableWithAggregatesFilter<"characters"> | string | null
    clan_bane?: UuidNullableWithAggregatesFilter<"characters"> | string | null
    clan_compulsion?: UuidNullableWithAggregatesFilter<"characters"> | string | null
    sect_id?: UuidNullableWithAggregatesFilter<"characters"> | string | null
    player?: StringWithAggregatesFilter<"characters"> | string
    predator_type?: UuidWithAggregatesFilter<"characters"> | string
    generation?: IntWithAggregatesFilter<"characters"> | number
    chronicle_id?: UuidNullableWithAggregatesFilter<"characters"> | string | null
    custom_chronicle?: StringNullableWithAggregatesFilter<"characters"> | string | null
    ambition?: StringWithAggregatesFilter<"characters"> | string
    desire?: StringWithAggregatesFilter<"characters"> | string
    sire?: StringWithAggregatesFilter<"characters"> | string
    total_experience?: IntWithAggregatesFilter<"characters"> | number
    chronicle_tenets?: StringWithAggregatesFilter<"characters"> | string
    group_id?: UuidWithAggregatesFilter<"characters"> | string
    type?: EnumEntityWithAggregatesFilter<"characters"> | $Enums.Entity
  }

  export type chroniclesWhereInput = {
    AND?: chroniclesWhereInput | chroniclesWhereInput[]
    OR?: chroniclesWhereInput[]
    NOT?: chroniclesWhereInput | chroniclesWhereInput[]
    id?: UuidFilter<"chronicles"> | string
    user_id?: UuidFilter<"chronicles"> | string
    name?: StringFilter<"chronicles"> | string
    description?: StringFilter<"chronicles"> | string
    created_at?: DateTimeFilter<"chronicles"> | Date | string
    updated_at?: DateTimeFilter<"chronicles"> | Date | string
    characters?: CharactersListRelationFilter
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type chroniclesOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    characters?: charactersOrderByRelationAggregateInput
    users?: usersOrderByWithRelationInput
  }

  export type chroniclesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: chroniclesWhereInput | chroniclesWhereInput[]
    OR?: chroniclesWhereInput[]
    NOT?: chroniclesWhereInput | chroniclesWhereInput[]
    user_id?: UuidFilter<"chronicles"> | string
    name?: StringFilter<"chronicles"> | string
    description?: StringFilter<"chronicles"> | string
    created_at?: DateTimeFilter<"chronicles"> | Date | string
    updated_at?: DateTimeFilter<"chronicles"> | Date | string
    characters?: CharactersListRelationFilter
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type chroniclesOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: chroniclesCountOrderByAggregateInput
    _max?: chroniclesMaxOrderByAggregateInput
    _min?: chroniclesMinOrderByAggregateInput
  }

  export type chroniclesScalarWhereWithAggregatesInput = {
    AND?: chroniclesScalarWhereWithAggregatesInput | chroniclesScalarWhereWithAggregatesInput[]
    OR?: chroniclesScalarWhereWithAggregatesInput[]
    NOT?: chroniclesScalarWhereWithAggregatesInput | chroniclesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"chronicles"> | string
    user_id?: UuidWithAggregatesFilter<"chronicles"> | string
    name?: StringWithAggregatesFilter<"chronicles"> | string
    description?: StringWithAggregatesFilter<"chronicles"> | string
    created_at?: DateTimeWithAggregatesFilter<"chronicles"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"chronicles"> | Date | string
  }

  export type clan_banesWhereInput = {
    AND?: clan_banesWhereInput | clan_banesWhereInput[]
    OR?: clan_banesWhereInput[]
    NOT?: clan_banesWhereInput | clan_banesWhereInput[]
    id?: UuidFilter<"clan_banes"> | string
    name?: StringFilter<"clan_banes"> | string
    clan_id?: UuidFilter<"clan_banes"> | string
    description?: StringFilter<"clan_banes"> | string
    character_bloodpotencies?: Character_bloodpotenciesListRelationFilter
    characters?: CharactersListRelationFilter
    clans?: XOR<ClansScalarRelationFilter, clansWhereInput>
  }

  export type clan_banesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    clan_id?: SortOrder
    description?: SortOrder
    character_bloodpotencies?: character_bloodpotenciesOrderByRelationAggregateInput
    characters?: charactersOrderByRelationAggregateInput
    clans?: clansOrderByWithRelationInput
  }

  export type clan_banesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: clan_banesWhereInput | clan_banesWhereInput[]
    OR?: clan_banesWhereInput[]
    NOT?: clan_banesWhereInput | clan_banesWhereInput[]
    name?: StringFilter<"clan_banes"> | string
    clan_id?: UuidFilter<"clan_banes"> | string
    description?: StringFilter<"clan_banes"> | string
    character_bloodpotencies?: Character_bloodpotenciesListRelationFilter
    characters?: CharactersListRelationFilter
    clans?: XOR<ClansScalarRelationFilter, clansWhereInput>
  }, "id">

  export type clan_banesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    clan_id?: SortOrder
    description?: SortOrder
    _count?: clan_banesCountOrderByAggregateInput
    _max?: clan_banesMaxOrderByAggregateInput
    _min?: clan_banesMinOrderByAggregateInput
  }

  export type clan_banesScalarWhereWithAggregatesInput = {
    AND?: clan_banesScalarWhereWithAggregatesInput | clan_banesScalarWhereWithAggregatesInput[]
    OR?: clan_banesScalarWhereWithAggregatesInput[]
    NOT?: clan_banesScalarWhereWithAggregatesInput | clan_banesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"clan_banes"> | string
    name?: StringWithAggregatesFilter<"clan_banes"> | string
    clan_id?: UuidWithAggregatesFilter<"clan_banes"> | string
    description?: StringWithAggregatesFilter<"clan_banes"> | string
  }

  export type clan_compulsionsWhereInput = {
    AND?: clan_compulsionsWhereInput | clan_compulsionsWhereInput[]
    OR?: clan_compulsionsWhereInput[]
    NOT?: clan_compulsionsWhereInput | clan_compulsionsWhereInput[]
    id?: UuidFilter<"clan_compulsions"> | string
    name?: StringFilter<"clan_compulsions"> | string
    clan_id?: UuidFilter<"clan_compulsions"> | string
    description?: StringFilter<"clan_compulsions"> | string
    character_bloodpotencies?: Character_bloodpotenciesListRelationFilter
    characters?: CharactersListRelationFilter
    clans?: XOR<ClansScalarRelationFilter, clansWhereInput>
  }

  export type clan_compulsionsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    clan_id?: SortOrder
    description?: SortOrder
    character_bloodpotencies?: character_bloodpotenciesOrderByRelationAggregateInput
    characters?: charactersOrderByRelationAggregateInput
    clans?: clansOrderByWithRelationInput
  }

  export type clan_compulsionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: clan_compulsionsWhereInput | clan_compulsionsWhereInput[]
    OR?: clan_compulsionsWhereInput[]
    NOT?: clan_compulsionsWhereInput | clan_compulsionsWhereInput[]
    name?: StringFilter<"clan_compulsions"> | string
    clan_id?: UuidFilter<"clan_compulsions"> | string
    description?: StringFilter<"clan_compulsions"> | string
    character_bloodpotencies?: Character_bloodpotenciesListRelationFilter
    characters?: CharactersListRelationFilter
    clans?: XOR<ClansScalarRelationFilter, clansWhereInput>
  }, "id">

  export type clan_compulsionsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    clan_id?: SortOrder
    description?: SortOrder
    _count?: clan_compulsionsCountOrderByAggregateInput
    _max?: clan_compulsionsMaxOrderByAggregateInput
    _min?: clan_compulsionsMinOrderByAggregateInput
  }

  export type clan_compulsionsScalarWhereWithAggregatesInput = {
    AND?: clan_compulsionsScalarWhereWithAggregatesInput | clan_compulsionsScalarWhereWithAggregatesInput[]
    OR?: clan_compulsionsScalarWhereWithAggregatesInput[]
    NOT?: clan_compulsionsScalarWhereWithAggregatesInput | clan_compulsionsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"clan_compulsions"> | string
    name?: StringWithAggregatesFilter<"clan_compulsions"> | string
    clan_id?: UuidWithAggregatesFilter<"clan_compulsions"> | string
    description?: StringWithAggregatesFilter<"clan_compulsions"> | string
  }

  export type clansWhereInput = {
    AND?: clansWhereInput | clansWhereInput[]
    OR?: clansWhereInput[]
    NOT?: clansWhereInput | clansWhereInput[]
    id?: UuidFilter<"clans"> | string
    name?: StringFilter<"clans"> | string
    description?: StringFilter<"clans"> | string
    advantages?: AdvantagesListRelationFilter
    characters?: CharactersListRelationFilter
    clan_banes?: Clan_banesListRelationFilter
    clan_compulsions?: Clan_compulsionsListRelationFilter
  }

  export type clansOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    advantages?: advantagesOrderByRelationAggregateInput
    characters?: charactersOrderByRelationAggregateInput
    clan_banes?: clan_banesOrderByRelationAggregateInput
    clan_compulsions?: clan_compulsionsOrderByRelationAggregateInput
  }

  export type clansWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: clansWhereInput | clansWhereInput[]
    OR?: clansWhereInput[]
    NOT?: clansWhereInput | clansWhereInput[]
    name?: StringFilter<"clans"> | string
    description?: StringFilter<"clans"> | string
    advantages?: AdvantagesListRelationFilter
    characters?: CharactersListRelationFilter
    clan_banes?: Clan_banesListRelationFilter
    clan_compulsions?: Clan_compulsionsListRelationFilter
  }, "id">

  export type clansOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    _count?: clansCountOrderByAggregateInput
    _max?: clansMaxOrderByAggregateInput
    _min?: clansMinOrderByAggregateInput
  }

  export type clansScalarWhereWithAggregatesInput = {
    AND?: clansScalarWhereWithAggregatesInput | clansScalarWhereWithAggregatesInput[]
    OR?: clansScalarWhereWithAggregatesInput[]
    NOT?: clansScalarWhereWithAggregatesInput | clansScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"clans"> | string
    name?: StringWithAggregatesFilter<"clans"> | string
    description?: StringWithAggregatesFilter<"clans"> | string
  }

  export type discipline_powersWhereInput = {
    AND?: discipline_powersWhereInput | discipline_powersWhereInput[]
    OR?: discipline_powersWhereInput[]
    NOT?: discipline_powersWhereInput | discipline_powersWhereInput[]
    id?: UuidFilter<"discipline_powers"> | string
    discipline_id?: UuidFilter<"discipline_powers"> | string
    name?: StringFilter<"discipline_powers"> | string
    level?: IntFilter<"discipline_powers"> | number
    description?: StringFilter<"discipline_powers"> | string
    dice_pool?: StringFilter<"discipline_powers"> | string
    cost?: StringFilter<"discipline_powers"> | string
    prerequisites?: StringFilter<"discipline_powers"> | string
    amalgam?: StringFilter<"discipline_powers"> | string
    system?: StringFilter<"discipline_powers"> | string
    duration?: StringFilter<"discipline_powers"> | string
    character_discipline_powers?: Character_discipline_powersListRelationFilter
    disciplines?: XOR<DisciplinesScalarRelationFilter, disciplinesWhereInput>
  }

  export type discipline_powersOrderByWithRelationInput = {
    id?: SortOrder
    discipline_id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    description?: SortOrder
    dice_pool?: SortOrder
    cost?: SortOrder
    prerequisites?: SortOrder
    amalgam?: SortOrder
    system?: SortOrder
    duration?: SortOrder
    character_discipline_powers?: character_discipline_powersOrderByRelationAggregateInput
    disciplines?: disciplinesOrderByWithRelationInput
  }

  export type discipline_powersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: discipline_powersWhereInput | discipline_powersWhereInput[]
    OR?: discipline_powersWhereInput[]
    NOT?: discipline_powersWhereInput | discipline_powersWhereInput[]
    discipline_id?: UuidFilter<"discipline_powers"> | string
    name?: StringFilter<"discipline_powers"> | string
    level?: IntFilter<"discipline_powers"> | number
    description?: StringFilter<"discipline_powers"> | string
    dice_pool?: StringFilter<"discipline_powers"> | string
    cost?: StringFilter<"discipline_powers"> | string
    prerequisites?: StringFilter<"discipline_powers"> | string
    amalgam?: StringFilter<"discipline_powers"> | string
    system?: StringFilter<"discipline_powers"> | string
    duration?: StringFilter<"discipline_powers"> | string
    character_discipline_powers?: Character_discipline_powersListRelationFilter
    disciplines?: XOR<DisciplinesScalarRelationFilter, disciplinesWhereInput>
  }, "id">

  export type discipline_powersOrderByWithAggregationInput = {
    id?: SortOrder
    discipline_id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    description?: SortOrder
    dice_pool?: SortOrder
    cost?: SortOrder
    prerequisites?: SortOrder
    amalgam?: SortOrder
    system?: SortOrder
    duration?: SortOrder
    _count?: discipline_powersCountOrderByAggregateInput
    _avg?: discipline_powersAvgOrderByAggregateInput
    _max?: discipline_powersMaxOrderByAggregateInput
    _min?: discipline_powersMinOrderByAggregateInput
    _sum?: discipline_powersSumOrderByAggregateInput
  }

  export type discipline_powersScalarWhereWithAggregatesInput = {
    AND?: discipline_powersScalarWhereWithAggregatesInput | discipline_powersScalarWhereWithAggregatesInput[]
    OR?: discipline_powersScalarWhereWithAggregatesInput[]
    NOT?: discipline_powersScalarWhereWithAggregatesInput | discipline_powersScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"discipline_powers"> | string
    discipline_id?: UuidWithAggregatesFilter<"discipline_powers"> | string
    name?: StringWithAggregatesFilter<"discipline_powers"> | string
    level?: IntWithAggregatesFilter<"discipline_powers"> | number
    description?: StringWithAggregatesFilter<"discipline_powers"> | string
    dice_pool?: StringWithAggregatesFilter<"discipline_powers"> | string
    cost?: StringWithAggregatesFilter<"discipline_powers"> | string
    prerequisites?: StringWithAggregatesFilter<"discipline_powers"> | string
    amalgam?: StringWithAggregatesFilter<"discipline_powers"> | string
    system?: StringWithAggregatesFilter<"discipline_powers"> | string
    duration?: StringWithAggregatesFilter<"discipline_powers"> | string
  }

  export type disciplinesWhereInput = {
    AND?: disciplinesWhereInput | disciplinesWhereInput[]
    OR?: disciplinesWhereInput[]
    NOT?: disciplinesWhereInput | disciplinesWhereInput[]
    id?: UuidFilter<"disciplines"> | string
    name?: StringFilter<"disciplines"> | string
    description?: StringFilter<"disciplines"> | string
    nicknames?: StringFilter<"disciplines"> | string
    characteristics?: StringFilter<"disciplines"> | string
    type?: StringFilter<"disciplines"> | string
    masquerade_threat?: StringFilter<"disciplines"> | string
    blood_resonance?: StringFilter<"disciplines"> | string
    character_disciplines?: Character_disciplinesListRelationFilter
    discipline_powers?: Discipline_powersListRelationFilter
  }

  export type disciplinesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    nicknames?: SortOrder
    characteristics?: SortOrder
    type?: SortOrder
    masquerade_threat?: SortOrder
    blood_resonance?: SortOrder
    character_disciplines?: character_disciplinesOrderByRelationAggregateInput
    discipline_powers?: discipline_powersOrderByRelationAggregateInput
  }

  export type disciplinesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: disciplinesWhereInput | disciplinesWhereInput[]
    OR?: disciplinesWhereInput[]
    NOT?: disciplinesWhereInput | disciplinesWhereInput[]
    name?: StringFilter<"disciplines"> | string
    description?: StringFilter<"disciplines"> | string
    nicknames?: StringFilter<"disciplines"> | string
    characteristics?: StringFilter<"disciplines"> | string
    type?: StringFilter<"disciplines"> | string
    masquerade_threat?: StringFilter<"disciplines"> | string
    blood_resonance?: StringFilter<"disciplines"> | string
    character_disciplines?: Character_disciplinesListRelationFilter
    discipline_powers?: Discipline_powersListRelationFilter
  }, "id">

  export type disciplinesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    nicknames?: SortOrder
    characteristics?: SortOrder
    type?: SortOrder
    masquerade_threat?: SortOrder
    blood_resonance?: SortOrder
    _count?: disciplinesCountOrderByAggregateInput
    _max?: disciplinesMaxOrderByAggregateInput
    _min?: disciplinesMinOrderByAggregateInput
  }

  export type disciplinesScalarWhereWithAggregatesInput = {
    AND?: disciplinesScalarWhereWithAggregatesInput | disciplinesScalarWhereWithAggregatesInput[]
    OR?: disciplinesScalarWhereWithAggregatesInput[]
    NOT?: disciplinesScalarWhereWithAggregatesInput | disciplinesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"disciplines"> | string
    name?: StringWithAggregatesFilter<"disciplines"> | string
    description?: StringWithAggregatesFilter<"disciplines"> | string
    nicknames?: StringWithAggregatesFilter<"disciplines"> | string
    characteristics?: StringWithAggregatesFilter<"disciplines"> | string
    type?: StringWithAggregatesFilter<"disciplines"> | string
    masquerade_threat?: StringWithAggregatesFilter<"disciplines"> | string
    blood_resonance?: StringWithAggregatesFilter<"disciplines"> | string
  }

  export type exp_logsWhereInput = {
    AND?: exp_logsWhereInput | exp_logsWhereInput[]
    OR?: exp_logsWhereInput[]
    NOT?: exp_logsWhereInput | exp_logsWhereInput[]
    id?: UuidFilter<"exp_logs"> | string
    user_id?: UuidFilter<"exp_logs"> | string
    char_id?: UuidFilter<"exp_logs"> | string
    section?: StringNullableFilter<"exp_logs"> | string | null
    name?: StringNullableFilter<"exp_logs"> | string | null
    prev_level?: IntNullableFilter<"exp_logs"> | number | null
    new_level?: IntNullableFilter<"exp_logs"> | number | null
    expanditure?: IntNullableFilter<"exp_logs"> | number | null
    created_at?: DateTimeFilter<"exp_logs"> | Date | string
    characters?: XOR<CharactersScalarRelationFilter, charactersWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type exp_logsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    char_id?: SortOrder
    section?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    prev_level?: SortOrderInput | SortOrder
    new_level?: SortOrderInput | SortOrder
    expanditure?: SortOrderInput | SortOrder
    created_at?: SortOrder
    characters?: charactersOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type exp_logsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: exp_logsWhereInput | exp_logsWhereInput[]
    OR?: exp_logsWhereInput[]
    NOT?: exp_logsWhereInput | exp_logsWhereInput[]
    user_id?: UuidFilter<"exp_logs"> | string
    char_id?: UuidFilter<"exp_logs"> | string
    section?: StringNullableFilter<"exp_logs"> | string | null
    name?: StringNullableFilter<"exp_logs"> | string | null
    prev_level?: IntNullableFilter<"exp_logs"> | number | null
    new_level?: IntNullableFilter<"exp_logs"> | number | null
    expanditure?: IntNullableFilter<"exp_logs"> | number | null
    created_at?: DateTimeFilter<"exp_logs"> | Date | string
    characters?: XOR<CharactersScalarRelationFilter, charactersWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type exp_logsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    char_id?: SortOrder
    section?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    prev_level?: SortOrderInput | SortOrder
    new_level?: SortOrderInput | SortOrder
    expanditure?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: exp_logsCountOrderByAggregateInput
    _avg?: exp_logsAvgOrderByAggregateInput
    _max?: exp_logsMaxOrderByAggregateInput
    _min?: exp_logsMinOrderByAggregateInput
    _sum?: exp_logsSumOrderByAggregateInput
  }

  export type exp_logsScalarWhereWithAggregatesInput = {
    AND?: exp_logsScalarWhereWithAggregatesInput | exp_logsScalarWhereWithAggregatesInput[]
    OR?: exp_logsScalarWhereWithAggregatesInput[]
    NOT?: exp_logsScalarWhereWithAggregatesInput | exp_logsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"exp_logs"> | string
    user_id?: UuidWithAggregatesFilter<"exp_logs"> | string
    char_id?: UuidWithAggregatesFilter<"exp_logs"> | string
    section?: StringNullableWithAggregatesFilter<"exp_logs"> | string | null
    name?: StringNullableWithAggregatesFilter<"exp_logs"> | string | null
    prev_level?: IntNullableWithAggregatesFilter<"exp_logs"> | number | null
    new_level?: IntNullableWithAggregatesFilter<"exp_logs"> | number | null
    expanditure?: IntNullableWithAggregatesFilter<"exp_logs"> | number | null
    created_at?: DateTimeWithAggregatesFilter<"exp_logs"> | Date | string
  }

  export type humanityWhereInput = {
    AND?: humanityWhereInput | humanityWhereInput[]
    OR?: humanityWhereInput[]
    NOT?: humanityWhereInput | humanityWhereInput[]
    id?: UuidFilter<"humanity"> | string
    description?: StringFilter<"humanity"> | string
    level?: IntFilter<"humanity"> | number
  }

  export type humanityOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    level?: SortOrder
  }

  export type humanityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: humanityWhereInput | humanityWhereInput[]
    OR?: humanityWhereInput[]
    NOT?: humanityWhereInput | humanityWhereInput[]
    description?: StringFilter<"humanity"> | string
    level?: IntFilter<"humanity"> | number
  }, "id">

  export type humanityOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    level?: SortOrder
    _count?: humanityCountOrderByAggregateInput
    _avg?: humanityAvgOrderByAggregateInput
    _max?: humanityMaxOrderByAggregateInput
    _min?: humanityMinOrderByAggregateInput
    _sum?: humanitySumOrderByAggregateInput
  }

  export type humanityScalarWhereWithAggregatesInput = {
    AND?: humanityScalarWhereWithAggregatesInput | humanityScalarWhereWithAggregatesInput[]
    OR?: humanityScalarWhereWithAggregatesInput[]
    NOT?: humanityScalarWhereWithAggregatesInput | humanityScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"humanity"> | string
    description?: StringWithAggregatesFilter<"humanity"> | string
    level?: IntWithAggregatesFilter<"humanity"> | number
  }

  export type predator_typesWhereInput = {
    AND?: predator_typesWhereInput | predator_typesWhereInput[]
    OR?: predator_typesWhereInput[]
    NOT?: predator_typesWhereInput | predator_typesWhereInput[]
    id?: UuidFilter<"predator_types"> | string
    name?: StringFilter<"predator_types"> | string
    description?: StringFilter<"predator_types"> | string
    dice_pool?: StringFilter<"predator_types"> | string
    benefits?: StringFilter<"predator_types"> | string
    characters?: CharactersListRelationFilter
  }

  export type predator_typesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    dice_pool?: SortOrder
    benefits?: SortOrder
    characters?: charactersOrderByRelationAggregateInput
  }

  export type predator_typesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: predator_typesWhereInput | predator_typesWhereInput[]
    OR?: predator_typesWhereInput[]
    NOT?: predator_typesWhereInput | predator_typesWhereInput[]
    name?: StringFilter<"predator_types"> | string
    description?: StringFilter<"predator_types"> | string
    dice_pool?: StringFilter<"predator_types"> | string
    benefits?: StringFilter<"predator_types"> | string
    characters?: CharactersListRelationFilter
  }, "id">

  export type predator_typesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    dice_pool?: SortOrder
    benefits?: SortOrder
    _count?: predator_typesCountOrderByAggregateInput
    _max?: predator_typesMaxOrderByAggregateInput
    _min?: predator_typesMinOrderByAggregateInput
  }

  export type predator_typesScalarWhereWithAggregatesInput = {
    AND?: predator_typesScalarWhereWithAggregatesInput | predator_typesScalarWhereWithAggregatesInput[]
    OR?: predator_typesScalarWhereWithAggregatesInput[]
    NOT?: predator_typesScalarWhereWithAggregatesInput | predator_typesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"predator_types"> | string
    name?: StringWithAggregatesFilter<"predator_types"> | string
    description?: StringWithAggregatesFilter<"predator_types"> | string
    dice_pool?: StringWithAggregatesFilter<"predator_types"> | string
    benefits?: StringWithAggregatesFilter<"predator_types"> | string
  }

  export type ritualsWhereInput = {
    AND?: ritualsWhereInput | ritualsWhereInput[]
    OR?: ritualsWhereInput[]
    NOT?: ritualsWhereInput | ritualsWhereInput[]
    id?: UuidFilter<"rituals"> | string
    name?: StringFilter<"rituals"> | string
    description?: StringFilter<"rituals"> | string
    ingridients?: StringFilter<"rituals"> | string
    process?: StringFilter<"rituals"> | string
    system?: StringFilter<"rituals"> | string
    level?: IntFilter<"rituals"> | number
    character_rituals?: Character_ritualsListRelationFilter
  }

  export type ritualsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ingridients?: SortOrder
    process?: SortOrder
    system?: SortOrder
    level?: SortOrder
    character_rituals?: character_ritualsOrderByRelationAggregateInput
  }

  export type ritualsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ritualsWhereInput | ritualsWhereInput[]
    OR?: ritualsWhereInput[]
    NOT?: ritualsWhereInput | ritualsWhereInput[]
    name?: StringFilter<"rituals"> | string
    description?: StringFilter<"rituals"> | string
    ingridients?: StringFilter<"rituals"> | string
    process?: StringFilter<"rituals"> | string
    system?: StringFilter<"rituals"> | string
    level?: IntFilter<"rituals"> | number
    character_rituals?: Character_ritualsListRelationFilter
  }, "id">

  export type ritualsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ingridients?: SortOrder
    process?: SortOrder
    system?: SortOrder
    level?: SortOrder
    _count?: ritualsCountOrderByAggregateInput
    _avg?: ritualsAvgOrderByAggregateInput
    _max?: ritualsMaxOrderByAggregateInput
    _min?: ritualsMinOrderByAggregateInput
    _sum?: ritualsSumOrderByAggregateInput
  }

  export type ritualsScalarWhereWithAggregatesInput = {
    AND?: ritualsScalarWhereWithAggregatesInput | ritualsScalarWhereWithAggregatesInput[]
    OR?: ritualsScalarWhereWithAggregatesInput[]
    NOT?: ritualsScalarWhereWithAggregatesInput | ritualsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"rituals"> | string
    name?: StringWithAggregatesFilter<"rituals"> | string
    description?: StringWithAggregatesFilter<"rituals"> | string
    ingridients?: StringWithAggregatesFilter<"rituals"> | string
    process?: StringWithAggregatesFilter<"rituals"> | string
    system?: StringWithAggregatesFilter<"rituals"> | string
    level?: IntWithAggregatesFilter<"rituals"> | number
  }

  export type sectsWhereInput = {
    AND?: sectsWhereInput | sectsWhereInput[]
    OR?: sectsWhereInput[]
    NOT?: sectsWhereInput | sectsWhereInput[]
    id?: UuidFilter<"sects"> | string
    name?: StringFilter<"sects"> | string
    description?: StringFilter<"sects"> | string
    advantages?: AdvantagesListRelationFilter
    characters?: CharactersListRelationFilter
  }

  export type sectsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    advantages?: advantagesOrderByRelationAggregateInput
    characters?: charactersOrderByRelationAggregateInput
  }

  export type sectsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: sectsWhereInput | sectsWhereInput[]
    OR?: sectsWhereInput[]
    NOT?: sectsWhereInput | sectsWhereInput[]
    name?: StringFilter<"sects"> | string
    description?: StringFilter<"sects"> | string
    advantages?: AdvantagesListRelationFilter
    characters?: CharactersListRelationFilter
  }, "id">

  export type sectsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    _count?: sectsCountOrderByAggregateInput
    _max?: sectsMaxOrderByAggregateInput
    _min?: sectsMinOrderByAggregateInput
  }

  export type sectsScalarWhereWithAggregatesInput = {
    AND?: sectsScalarWhereWithAggregatesInput | sectsScalarWhereWithAggregatesInput[]
    OR?: sectsScalarWhereWithAggregatesInput[]
    NOT?: sectsScalarWhereWithAggregatesInput | sectsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"sects"> | string
    name?: StringWithAggregatesFilter<"sects"> | string
    description?: StringWithAggregatesFilter<"sects"> | string
  }

  export type skillsWhereInput = {
    AND?: skillsWhereInput | skillsWhereInput[]
    OR?: skillsWhereInput[]
    NOT?: skillsWhereInput | skillsWhereInput[]
    id?: UuidFilter<"skills"> | string
    name?: StringFilter<"skills"> | string
    description?: StringFilter<"skills"> | string
    character_skills?: Character_skillsListRelationFilter
    character_specialties?: Character_specialtiesListRelationFilter
  }

  export type skillsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    character_skills?: character_skillsOrderByRelationAggregateInput
    character_specialties?: character_specialtiesOrderByRelationAggregateInput
  }

  export type skillsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: skillsWhereInput | skillsWhereInput[]
    OR?: skillsWhereInput[]
    NOT?: skillsWhereInput | skillsWhereInput[]
    name?: StringFilter<"skills"> | string
    description?: StringFilter<"skills"> | string
    character_skills?: Character_skillsListRelationFilter
    character_specialties?: Character_specialtiesListRelationFilter
  }, "id">

  export type skillsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    _count?: skillsCountOrderByAggregateInput
    _max?: skillsMaxOrderByAggregateInput
    _min?: skillsMinOrderByAggregateInput
  }

  export type skillsScalarWhereWithAggregatesInput = {
    AND?: skillsScalarWhereWithAggregatesInput | skillsScalarWhereWithAggregatesInput[]
    OR?: skillsScalarWhereWithAggregatesInput[]
    NOT?: skillsScalarWhereWithAggregatesInput | skillsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"skills"> | string
    name?: StringWithAggregatesFilter<"skills"> | string
    description?: StringWithAggregatesFilter<"skills"> | string
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: UuidFilter<"users"> | string
    clerk_user_id?: StringFilter<"users"> | string
    email?: StringFilter<"users"> | string
    name?: StringFilter<"users"> | string
    image_url?: StringNullableFilter<"users"> | string | null
    deleted_at?: DateTimeNullableFilter<"users"> | Date | string | null
    created_at?: DateTimeFilter<"users"> | Date | string
    updated_at?: DateTimeFilter<"users"> | Date | string
    char_groups?: Char_groupsListRelationFilter
    characters?: CharactersListRelationFilter
    chronicles?: ChroniclesListRelationFilter
    exp_logs?: Exp_logsListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    clerk_user_id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    image_url?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    char_groups?: char_groupsOrderByRelationAggregateInput
    characters?: charactersOrderByRelationAggregateInput
    chronicles?: chroniclesOrderByRelationAggregateInput
    exp_logs?: exp_logsOrderByRelationAggregateInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clerk_user_id?: string
    email?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    name?: StringFilter<"users"> | string
    image_url?: StringNullableFilter<"users"> | string | null
    deleted_at?: DateTimeNullableFilter<"users"> | Date | string | null
    created_at?: DateTimeFilter<"users"> | Date | string
    updated_at?: DateTimeFilter<"users"> | Date | string
    char_groups?: Char_groupsListRelationFilter
    characters?: CharactersListRelationFilter
    chronicles?: ChroniclesListRelationFilter
    exp_logs?: Exp_logsListRelationFilter
  }, "id" | "clerk_user_id" | "email">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    clerk_user_id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    image_url?: SortOrderInput | SortOrder
    deleted_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"users"> | string
    clerk_user_id?: StringWithAggregatesFilter<"users"> | string
    email?: StringWithAggregatesFilter<"users"> | string
    name?: StringWithAggregatesFilter<"users"> | string
    image_url?: StringNullableWithAggregatesFilter<"users"> | string | null
    deleted_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"users"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"users"> | Date | string
  }

  export type advantagesCreateInput = {
    id?: string
    parent_name?: string | null
    name: string
    description: string
    type: $Enums.type
    level: number
    for: $Enums.forWhom
    clans?: clansCreateNestedOneWithoutAdvantagesInput
    sects?: sectsCreateNestedOneWithoutAdvantagesInput
    character_advantages?: character_advantagesCreateNestedManyWithoutAdvantagesInput
  }

  export type advantagesUncheckedCreateInput = {
    id?: string
    parent_name?: string | null
    name: string
    description: string
    type: $Enums.type
    level: number
    for: $Enums.forWhom
    clan_req?: string | null
    sect_req?: string | null
    character_advantages?: character_advantagesUncheckedCreateNestedManyWithoutAdvantagesInput
  }

  export type advantagesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    parent_name?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumtypeFieldUpdateOperationsInput | $Enums.type
    level?: IntFieldUpdateOperationsInput | number
    for?: EnumforWhomFieldUpdateOperationsInput | $Enums.forWhom
    clans?: clansUpdateOneWithoutAdvantagesNestedInput
    sects?: sectsUpdateOneWithoutAdvantagesNestedInput
    character_advantages?: character_advantagesUpdateManyWithoutAdvantagesNestedInput
  }

  export type advantagesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    parent_name?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumtypeFieldUpdateOperationsInput | $Enums.type
    level?: IntFieldUpdateOperationsInput | number
    for?: EnumforWhomFieldUpdateOperationsInput | $Enums.forWhom
    clan_req?: NullableStringFieldUpdateOperationsInput | string | null
    sect_req?: NullableStringFieldUpdateOperationsInput | string | null
    character_advantages?: character_advantagesUncheckedUpdateManyWithoutAdvantagesNestedInput
  }

  export type advantagesCreateManyInput = {
    id?: string
    parent_name?: string | null
    name: string
    description: string
    type: $Enums.type
    level: number
    for: $Enums.forWhom
    clan_req?: string | null
    sect_req?: string | null
  }

  export type advantagesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    parent_name?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumtypeFieldUpdateOperationsInput | $Enums.type
    level?: IntFieldUpdateOperationsInput | number
    for?: EnumforWhomFieldUpdateOperationsInput | $Enums.forWhom
  }

  export type advantagesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    parent_name?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumtypeFieldUpdateOperationsInput | $Enums.type
    level?: IntFieldUpdateOperationsInput | number
    for?: EnumforWhomFieldUpdateOperationsInput | $Enums.forWhom
    clan_req?: NullableStringFieldUpdateOperationsInput | string | null
    sect_req?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type alchemy_powersCreateInput = {
    id?: string
    name: string
    description?: string | null
    ingridients?: string | null
    activation?: string | null
    dice_pool?: string | null
    system?: string | null
    duration?: string | null
    level?: number | null
    character_alchemy_powers?: character_alchemy_powersCreateNestedManyWithoutAlchemy_powersInput
  }

  export type alchemy_powersUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    ingridients?: string | null
    activation?: string | null
    dice_pool?: string | null
    system?: string | null
    duration?: string | null
    level?: number | null
    character_alchemy_powers?: character_alchemy_powersUncheckedCreateNestedManyWithoutAlchemy_powersInput
  }

  export type alchemy_powersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ingridients?: NullableStringFieldUpdateOperationsInput | string | null
    activation?: NullableStringFieldUpdateOperationsInput | string | null
    dice_pool?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    character_alchemy_powers?: character_alchemy_powersUpdateManyWithoutAlchemy_powersNestedInput
  }

  export type alchemy_powersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ingridients?: NullableStringFieldUpdateOperationsInput | string | null
    activation?: NullableStringFieldUpdateOperationsInput | string | null
    dice_pool?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    character_alchemy_powers?: character_alchemy_powersUncheckedUpdateManyWithoutAlchemy_powersNestedInput
  }

  export type alchemy_powersCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    ingridients?: string | null
    activation?: string | null
    dice_pool?: string | null
    system?: string | null
    duration?: string | null
    level?: number | null
  }

  export type alchemy_powersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ingridients?: NullableStringFieldUpdateOperationsInput | string | null
    activation?: NullableStringFieldUpdateOperationsInput | string | null
    dice_pool?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type alchemy_powersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ingridients?: NullableStringFieldUpdateOperationsInput | string | null
    activation?: NullableStringFieldUpdateOperationsInput | string | null
    dice_pool?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type attributesCreateInput = {
    id?: string
    name: string
    description: string
    category: $Enums.category
    character_attributes?: character_attributesCreateNestedManyWithoutAttributesInput
  }

  export type attributesUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    category: $Enums.category
    character_attributes?: character_attributesUncheckedCreateNestedManyWithoutAttributesInput
  }

  export type attributesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumcategoryFieldUpdateOperationsInput | $Enums.category
    character_attributes?: character_attributesUpdateManyWithoutAttributesNestedInput
  }

  export type attributesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumcategoryFieldUpdateOperationsInput | $Enums.category
    character_attributes?: character_attributesUncheckedUpdateManyWithoutAttributesNestedInput
  }

  export type attributesCreateManyInput = {
    id?: string
    name: string
    description: string
    category: $Enums.category
  }

  export type attributesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumcategoryFieldUpdateOperationsInput | $Enums.category
  }

  export type attributesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumcategoryFieldUpdateOperationsInput | $Enums.category
  }

  export type blood_potencyCreateInput = {
    id?: string
    level: number
    description?: string | null
    blood_surge?: string | null
    damage_mend?: string | null
    power_bonus?: string | null
    rc_reroll?: string | null
    bane_severity?: number | null
    feeding_penalty?: string | null
    character_bloodpotencies?: character_bloodpotenciesCreateNestedManyWithoutBlood_potencyInput
  }

  export type blood_potencyUncheckedCreateInput = {
    id?: string
    level: number
    description?: string | null
    blood_surge?: string | null
    damage_mend?: string | null
    power_bonus?: string | null
    rc_reroll?: string | null
    bane_severity?: number | null
    feeding_penalty?: string | null
    character_bloodpotencies?: character_bloodpotenciesUncheckedCreateNestedManyWithoutBlood_potencyInput
  }

  export type blood_potencyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    blood_surge?: NullableStringFieldUpdateOperationsInput | string | null
    damage_mend?: NullableStringFieldUpdateOperationsInput | string | null
    power_bonus?: NullableStringFieldUpdateOperationsInput | string | null
    rc_reroll?: NullableStringFieldUpdateOperationsInput | string | null
    bane_severity?: NullableIntFieldUpdateOperationsInput | number | null
    feeding_penalty?: NullableStringFieldUpdateOperationsInput | string | null
    character_bloodpotencies?: character_bloodpotenciesUpdateManyWithoutBlood_potencyNestedInput
  }

  export type blood_potencyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    blood_surge?: NullableStringFieldUpdateOperationsInput | string | null
    damage_mend?: NullableStringFieldUpdateOperationsInput | string | null
    power_bonus?: NullableStringFieldUpdateOperationsInput | string | null
    rc_reroll?: NullableStringFieldUpdateOperationsInput | string | null
    bane_severity?: NullableIntFieldUpdateOperationsInput | number | null
    feeding_penalty?: NullableStringFieldUpdateOperationsInput | string | null
    character_bloodpotencies?: character_bloodpotenciesUncheckedUpdateManyWithoutBlood_potencyNestedInput
  }

  export type blood_potencyCreateManyInput = {
    id?: string
    level: number
    description?: string | null
    blood_surge?: string | null
    damage_mend?: string | null
    power_bonus?: string | null
    rc_reroll?: string | null
    bane_severity?: number | null
    feeding_penalty?: string | null
  }

  export type blood_potencyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    blood_surge?: NullableStringFieldUpdateOperationsInput | string | null
    damage_mend?: NullableStringFieldUpdateOperationsInput | string | null
    power_bonus?: NullableStringFieldUpdateOperationsInput | string | null
    rc_reroll?: NullableStringFieldUpdateOperationsInput | string | null
    bane_severity?: NullableIntFieldUpdateOperationsInput | number | null
    feeding_penalty?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type blood_potencyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    blood_surge?: NullableStringFieldUpdateOperationsInput | string | null
    damage_mend?: NullableStringFieldUpdateOperationsInput | string | null
    power_bonus?: NullableStringFieldUpdateOperationsInput | string | null
    rc_reroll?: NullableStringFieldUpdateOperationsInput | string | null
    bane_severity?: NullableIntFieldUpdateOperationsInput | number | null
    feeding_penalty?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type char_groupsCreateInput = {
    id?: string
    name: string
    description: string
    char_groups?: char_groupsCreateNestedOneWithoutOther_char_groupsInput
    other_char_groups?: char_groupsCreateNestedManyWithoutChar_groupsInput
    users: usersCreateNestedOneWithoutChar_groupsInput
    characters?: charactersCreateNestedManyWithoutChar_groupsInput
  }

  export type char_groupsUncheckedCreateInput = {
    id?: string
    user_id: string
    parent_id?: string | null
    name: string
    description: string
    other_char_groups?: char_groupsUncheckedCreateNestedManyWithoutChar_groupsInput
    characters?: charactersUncheckedCreateNestedManyWithoutChar_groupsInput
  }

  export type char_groupsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    char_groups?: char_groupsUpdateOneWithoutOther_char_groupsNestedInput
    other_char_groups?: char_groupsUpdateManyWithoutChar_groupsNestedInput
    users?: usersUpdateOneRequiredWithoutChar_groupsNestedInput
    characters?: charactersUpdateManyWithoutChar_groupsNestedInput
  }

  export type char_groupsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    other_char_groups?: char_groupsUncheckedUpdateManyWithoutChar_groupsNestedInput
    characters?: charactersUncheckedUpdateManyWithoutChar_groupsNestedInput
  }

  export type char_groupsCreateManyInput = {
    id?: string
    user_id: string
    parent_id?: string | null
    name: string
    description: string
  }

  export type char_groupsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type char_groupsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type character_advantagesCreateInput = {
    id?: string
    advantages: advantagesCreateNestedOneWithoutCharacter_advantagesInput
    characters: charactersCreateNestedOneWithoutCharacter_advantagesInput
  }

  export type character_advantagesUncheckedCreateInput = {
    id?: string
    char_id: string
    advantage_id: string
  }

  export type character_advantagesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    advantages?: advantagesUpdateOneRequiredWithoutCharacter_advantagesNestedInput
    characters?: charactersUpdateOneRequiredWithoutCharacter_advantagesNestedInput
  }

  export type character_advantagesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
    advantage_id?: StringFieldUpdateOperationsInput | string
  }

  export type character_advantagesCreateManyInput = {
    id?: string
    char_id: string
    advantage_id: string
  }

  export type character_advantagesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type character_advantagesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
    advantage_id?: StringFieldUpdateOperationsInput | string
  }

  export type character_alchemy_powersCreateInput = {
    id?: string
    alchemy_powers: alchemy_powersCreateNestedOneWithoutCharacter_alchemy_powersInput
    characters: charactersCreateNestedOneWithoutCharacter_alchemy_powersInput
  }

  export type character_alchemy_powersUncheckedCreateInput = {
    id?: string
    char_id: string
    alchemy_power_id: string
  }

  export type character_alchemy_powersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    alchemy_powers?: alchemy_powersUpdateOneRequiredWithoutCharacter_alchemy_powersNestedInput
    characters?: charactersUpdateOneRequiredWithoutCharacter_alchemy_powersNestedInput
  }

  export type character_alchemy_powersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
    alchemy_power_id?: StringFieldUpdateOperationsInput | string
  }

  export type character_alchemy_powersCreateManyInput = {
    id?: string
    char_id: string
    alchemy_power_id: string
  }

  export type character_alchemy_powersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type character_alchemy_powersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
    alchemy_power_id?: StringFieldUpdateOperationsInput | string
  }

  export type character_attributesCreateInput = {
    id?: string
    level?: number
    attributes: attributesCreateNestedOneWithoutCharacter_attributesInput
    characters: charactersCreateNestedOneWithoutCharacter_attributesInput
  }

  export type character_attributesUncheckedCreateInput = {
    id?: string
    char_id: string
    attribute_id: string
    level?: number
  }

  export type character_attributesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    attributes?: attributesUpdateOneRequiredWithoutCharacter_attributesNestedInput
    characters?: charactersUpdateOneRequiredWithoutCharacter_attributesNestedInput
  }

  export type character_attributesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
    attribute_id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
  }

  export type character_attributesCreateManyInput = {
    id?: string
    char_id: string
    attribute_id: string
    level?: number
  }

  export type character_attributesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
  }

  export type character_attributesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
    attribute_id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
  }

  export type character_bloodpotenciesCreateInput = {
    id?: string
    blood_surge?: string | null
    bane_severity?: number | null
    power_bonus?: string | null
    feeding_penalty?: string | null
    mend_amount?: number | null
    rc_reroll?: string | null
    blood_potency?: blood_potencyCreateNestedOneWithoutCharacter_bloodpotenciesInput
    characters: charactersCreateNestedOneWithoutCharacter_bloodpotenciesInput
    clan_compulsions?: clan_compulsionsCreateNestedOneWithoutCharacter_bloodpotenciesInput
    clan_banes?: clan_banesCreateNestedOneWithoutCharacter_bloodpotenciesInput
  }

  export type character_bloodpotenciesUncheckedCreateInput = {
    id?: string
    char_id: string
    blood_potency_level?: string | null
    blood_surge?: string | null
    bane_severity?: number | null
    power_bonus?: string | null
    feeding_penalty?: string | null
    mend_amount?: number | null
    rc_reroll?: string | null
    clane_bane?: string | null
    clan_compulsion?: string | null
  }

  export type character_bloodpotenciesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    blood_surge?: NullableStringFieldUpdateOperationsInput | string | null
    bane_severity?: NullableIntFieldUpdateOperationsInput | number | null
    power_bonus?: NullableStringFieldUpdateOperationsInput | string | null
    feeding_penalty?: NullableStringFieldUpdateOperationsInput | string | null
    mend_amount?: NullableIntFieldUpdateOperationsInput | number | null
    rc_reroll?: NullableStringFieldUpdateOperationsInput | string | null
    blood_potency?: blood_potencyUpdateOneWithoutCharacter_bloodpotenciesNestedInput
    characters?: charactersUpdateOneRequiredWithoutCharacter_bloodpotenciesNestedInput
    clan_compulsions?: clan_compulsionsUpdateOneWithoutCharacter_bloodpotenciesNestedInput
    clan_banes?: clan_banesUpdateOneWithoutCharacter_bloodpotenciesNestedInput
  }

  export type character_bloodpotenciesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
    blood_potency_level?: NullableStringFieldUpdateOperationsInput | string | null
    blood_surge?: NullableStringFieldUpdateOperationsInput | string | null
    bane_severity?: NullableIntFieldUpdateOperationsInput | number | null
    power_bonus?: NullableStringFieldUpdateOperationsInput | string | null
    feeding_penalty?: NullableStringFieldUpdateOperationsInput | string | null
    mend_amount?: NullableIntFieldUpdateOperationsInput | number | null
    rc_reroll?: NullableStringFieldUpdateOperationsInput | string | null
    clane_bane?: NullableStringFieldUpdateOperationsInput | string | null
    clan_compulsion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type character_bloodpotenciesCreateManyInput = {
    id?: string
    char_id: string
    blood_potency_level?: string | null
    blood_surge?: string | null
    bane_severity?: number | null
    power_bonus?: string | null
    feeding_penalty?: string | null
    mend_amount?: number | null
    rc_reroll?: string | null
    clane_bane?: string | null
    clan_compulsion?: string | null
  }

  export type character_bloodpotenciesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    blood_surge?: NullableStringFieldUpdateOperationsInput | string | null
    bane_severity?: NullableIntFieldUpdateOperationsInput | number | null
    power_bonus?: NullableStringFieldUpdateOperationsInput | string | null
    feeding_penalty?: NullableStringFieldUpdateOperationsInput | string | null
    mend_amount?: NullableIntFieldUpdateOperationsInput | number | null
    rc_reroll?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type character_bloodpotenciesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
    blood_potency_level?: NullableStringFieldUpdateOperationsInput | string | null
    blood_surge?: NullableStringFieldUpdateOperationsInput | string | null
    bane_severity?: NullableIntFieldUpdateOperationsInput | number | null
    power_bonus?: NullableStringFieldUpdateOperationsInput | string | null
    feeding_penalty?: NullableStringFieldUpdateOperationsInput | string | null
    mend_amount?: NullableIntFieldUpdateOperationsInput | number | null
    rc_reroll?: NullableStringFieldUpdateOperationsInput | string | null
    clane_bane?: NullableStringFieldUpdateOperationsInput | string | null
    clan_compulsion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type character_discipline_powersCreateInput = {
    id?: string
    characters: charactersCreateNestedOneWithoutCharacter_discipline_powersInput
    discipline_powers: discipline_powersCreateNestedOneWithoutCharacter_discipline_powersInput
  }

  export type character_discipline_powersUncheckedCreateInput = {
    id?: string
    char_id: string
    discipline_power_id: string
  }

  export type character_discipline_powersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    characters?: charactersUpdateOneRequiredWithoutCharacter_discipline_powersNestedInput
    discipline_powers?: discipline_powersUpdateOneRequiredWithoutCharacter_discipline_powersNestedInput
  }

  export type character_discipline_powersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
    discipline_power_id?: StringFieldUpdateOperationsInput | string
  }

  export type character_discipline_powersCreateManyInput = {
    id?: string
    char_id: string
    discipline_power_id: string
  }

  export type character_discipline_powersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type character_discipline_powersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
    discipline_power_id?: StringFieldUpdateOperationsInput | string
  }

  export type character_disciplinesCreateInput = {
    id?: string
    characters: charactersCreateNestedOneWithoutCharacter_disciplinesInput
    disciplines: disciplinesCreateNestedOneWithoutCharacter_disciplinesInput
  }

  export type character_disciplinesUncheckedCreateInput = {
    id?: string
    char_id: string
    discipline_id: string
  }

  export type character_disciplinesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    characters?: charactersUpdateOneRequiredWithoutCharacter_disciplinesNestedInput
    disciplines?: disciplinesUpdateOneRequiredWithoutCharacter_disciplinesNestedInput
  }

  export type character_disciplinesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
    discipline_id?: StringFieldUpdateOperationsInput | string
  }

  export type character_disciplinesCreateManyInput = {
    id?: string
    char_id: string
    discipline_id: string
  }

  export type character_disciplinesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type character_disciplinesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
    discipline_id?: StringFieldUpdateOperationsInput | string
  }

  export type character_healthsCreateInput = {
    id?: string
    max_health: number
    current_aggravated?: number
    current_superficial?: number
    characters: charactersCreateNestedOneWithoutCharacter_healthsInput
  }

  export type character_healthsUncheckedCreateInput = {
    id?: string
    char_id: string
    max_health: number
    current_aggravated?: number
    current_superficial?: number
  }

  export type character_healthsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    max_health?: IntFieldUpdateOperationsInput | number
    current_aggravated?: IntFieldUpdateOperationsInput | number
    current_superficial?: IntFieldUpdateOperationsInput | number
    characters?: charactersUpdateOneRequiredWithoutCharacter_healthsNestedInput
  }

  export type character_healthsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
    max_health?: IntFieldUpdateOperationsInput | number
    current_aggravated?: IntFieldUpdateOperationsInput | number
    current_superficial?: IntFieldUpdateOperationsInput | number
  }

  export type character_healthsCreateManyInput = {
    id?: string
    char_id: string
    max_health: number
    current_aggravated?: number
    current_superficial?: number
  }

  export type character_healthsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    max_health?: IntFieldUpdateOperationsInput | number
    current_aggravated?: IntFieldUpdateOperationsInput | number
    current_superficial?: IntFieldUpdateOperationsInput | number
  }

  export type character_healthsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
    max_health?: IntFieldUpdateOperationsInput | number
    current_aggravated?: IntFieldUpdateOperationsInput | number
    current_superficial?: IntFieldUpdateOperationsInput | number
  }

  export type character_humanityCreateInput = {
    id?: string
    level?: number
    stain_count?: number
    characters: charactersCreateNestedOneWithoutCharacter_humanityInput
  }

  export type character_humanityUncheckedCreateInput = {
    id?: string
    char_id: string
    level?: number
    stain_count?: number
  }

  export type character_humanityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    stain_count?: IntFieldUpdateOperationsInput | number
    characters?: charactersUpdateOneRequiredWithoutCharacter_humanityNestedInput
  }

  export type character_humanityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    stain_count?: IntFieldUpdateOperationsInput | number
  }

  export type character_humanityCreateManyInput = {
    id?: string
    char_id: string
    level?: number
    stain_count?: number
  }

  export type character_humanityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    stain_count?: IntFieldUpdateOperationsInput | number
  }

  export type character_humanityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    stain_count?: IntFieldUpdateOperationsInput | number
  }

  export type character_profileCreateInput = {
    id?: string
    description: string
    birthday: Date | string
    notes?: string | null
    age: number
    embraced_at: Date | string
    apparent_age: number
    concept?: string | null
    characters: charactersCreateNestedOneWithoutCharacter_profileInput
  }

  export type character_profileUncheckedCreateInput = {
    id?: string
    char_id: string
    description: string
    birthday: Date | string
    notes?: string | null
    age: number
    embraced_at: Date | string
    apparent_age: number
    concept?: string | null
  }

  export type character_profileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    birthday?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    age?: IntFieldUpdateOperationsInput | number
    embraced_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apparent_age?: IntFieldUpdateOperationsInput | number
    concept?: NullableStringFieldUpdateOperationsInput | string | null
    characters?: charactersUpdateOneRequiredWithoutCharacter_profileNestedInput
  }

  export type character_profileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    birthday?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    age?: IntFieldUpdateOperationsInput | number
    embraced_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apparent_age?: IntFieldUpdateOperationsInput | number
    concept?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type character_profileCreateManyInput = {
    id?: string
    char_id: string
    description: string
    birthday: Date | string
    notes?: string | null
    age: number
    embraced_at: Date | string
    apparent_age: number
    concept?: string | null
  }

  export type character_profileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    birthday?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    age?: IntFieldUpdateOperationsInput | number
    embraced_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apparent_age?: IntFieldUpdateOperationsInput | number
    concept?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type character_profileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    birthday?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    age?: IntFieldUpdateOperationsInput | number
    embraced_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apparent_age?: IntFieldUpdateOperationsInput | number
    concept?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type character_ritualsCreateInput = {
    id?: string
    characters: charactersCreateNestedOneWithoutCharacter_ritualsInput
    rituals: ritualsCreateNestedOneWithoutCharacter_ritualsInput
  }

  export type character_ritualsUncheckedCreateInput = {
    id?: string
    char_id: string
    ritual_id: string
  }

  export type character_ritualsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    characters?: charactersUpdateOneRequiredWithoutCharacter_ritualsNestedInput
    rituals?: ritualsUpdateOneRequiredWithoutCharacter_ritualsNestedInput
  }

  export type character_ritualsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
    ritual_id?: StringFieldUpdateOperationsInput | string
  }

  export type character_ritualsCreateManyInput = {
    id?: string
    char_id: string
    ritual_id: string
  }

  export type character_ritualsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type character_ritualsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
    ritual_id?: StringFieldUpdateOperationsInput | string
  }

  export type character_skillsCreateInput = {
    id?: string
    level?: number
    characters: charactersCreateNestedOneWithoutCharacter_skillsInput
    skills: skillsCreateNestedOneWithoutCharacter_skillsInput
  }

  export type character_skillsUncheckedCreateInput = {
    id?: string
    char_id: string
    skill_id: string
    level?: number
  }

  export type character_skillsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    characters?: charactersUpdateOneRequiredWithoutCharacter_skillsNestedInput
    skills?: skillsUpdateOneRequiredWithoutCharacter_skillsNestedInput
  }

  export type character_skillsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
    skill_id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
  }

  export type character_skillsCreateManyInput = {
    id?: string
    char_id: string
    skill_id: string
    level?: number
  }

  export type character_skillsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
  }

  export type character_skillsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
    skill_id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
  }

  export type character_specialtiesCreateInput = {
    id?: string
    specialty_name: string
    characters: charactersCreateNestedOneWithoutCharacter_specialtiesInput
    skills: skillsCreateNestedOneWithoutCharacter_specialtiesInput
  }

  export type character_specialtiesUncheckedCreateInput = {
    id?: string
    char_id: string
    skill_id: string
    specialty_name: string
  }

  export type character_specialtiesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialty_name?: StringFieldUpdateOperationsInput | string
    characters?: charactersUpdateOneRequiredWithoutCharacter_specialtiesNestedInput
    skills?: skillsUpdateOneRequiredWithoutCharacter_specialtiesNestedInput
  }

  export type character_specialtiesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
    skill_id?: StringFieldUpdateOperationsInput | string
    specialty_name?: StringFieldUpdateOperationsInput | string
  }

  export type character_specialtiesCreateManyInput = {
    id?: string
    char_id: string
    skill_id: string
    specialty_name: string
  }

  export type character_specialtiesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialty_name?: StringFieldUpdateOperationsInput | string
  }

  export type character_specialtiesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
    skill_id?: StringFieldUpdateOperationsInput | string
    specialty_name?: StringFieldUpdateOperationsInput | string
  }

  export type character_willpowersCreateInput = {
    id?: string
    max_willpower: number
    current_aggravated?: number
    current_superficial?: number
    characters: charactersCreateNestedOneWithoutCharacter_willpowersInput
  }

  export type character_willpowersUncheckedCreateInput = {
    id?: string
    char_id: string
    max_willpower: number
    current_aggravated?: number
    current_superficial?: number
  }

  export type character_willpowersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    max_willpower?: IntFieldUpdateOperationsInput | number
    current_aggravated?: IntFieldUpdateOperationsInput | number
    current_superficial?: IntFieldUpdateOperationsInput | number
    characters?: charactersUpdateOneRequiredWithoutCharacter_willpowersNestedInput
  }

  export type character_willpowersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
    max_willpower?: IntFieldUpdateOperationsInput | number
    current_aggravated?: IntFieldUpdateOperationsInput | number
    current_superficial?: IntFieldUpdateOperationsInput | number
  }

  export type character_willpowersCreateManyInput = {
    id?: string
    char_id: string
    max_willpower: number
    current_aggravated?: number
    current_superficial?: number
  }

  export type character_willpowersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    max_willpower?: IntFieldUpdateOperationsInput | number
    current_aggravated?: IntFieldUpdateOperationsInput | number
    current_superficial?: IntFieldUpdateOperationsInput | number
  }

  export type character_willpowersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
    max_willpower?: IntFieldUpdateOperationsInput | number
    current_aggravated?: IntFieldUpdateOperationsInput | number
    current_superficial?: IntFieldUpdateOperationsInput | number
  }

  export type charactersCreateInput = {
    id?: string
    name: string
    player: string
    generation: number
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesCreateNestedManyWithoutCharactersInput
    character_alchemy_powers?: character_alchemy_powersCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersCreateNestedManyWithoutCharactersInput
    chronicles?: chroniclesCreateNestedOneWithoutCharactersInput
    clan_banes?: clan_banesCreateNestedOneWithoutCharactersInput
    clan_compulsions?: clan_compulsionsCreateNestedOneWithoutCharactersInput
    clans?: clansCreateNestedOneWithoutCharactersInput
    char_groups: char_groupsCreateNestedOneWithoutCharactersInput
    predator_types: predator_typesCreateNestedOneWithoutCharactersInput
    sects?: sectsCreateNestedOneWithoutCharactersInput
    users: usersCreateNestedOneWithoutCharactersInput
    exp_logs?: exp_logsCreateNestedManyWithoutCharactersInput
  }

  export type charactersUncheckedCreateInput = {
    id?: string
    user_id: string
    name: string
    clan_id?: string | null
    clan_bane?: string | null
    clan_compulsion?: string | null
    sect_id?: string | null
    player: string
    predator_type: string
    generation: number
    chronicle_id?: string | null
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    group_id: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesUncheckedCreateNestedManyWithoutCharactersInput
    character_alchemy_powers?: character_alchemy_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesUncheckedCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesUncheckedCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsUncheckedCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityUncheckedCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileUncheckedCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsUncheckedCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsUncheckedCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesUncheckedCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersUncheckedCreateNestedManyWithoutCharactersInput
    exp_logs?: exp_logsUncheckedCreateNestedManyWithoutCharactersInput
  }

  export type charactersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    player?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUpdateManyWithoutCharactersNestedInput
    character_alchemy_powers?: character_alchemy_powersUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUpdateManyWithoutCharactersNestedInput
    chronicles?: chroniclesUpdateOneWithoutCharactersNestedInput
    clan_banes?: clan_banesUpdateOneWithoutCharactersNestedInput
    clan_compulsions?: clan_compulsionsUpdateOneWithoutCharactersNestedInput
    clans?: clansUpdateOneWithoutCharactersNestedInput
    char_groups?: char_groupsUpdateOneRequiredWithoutCharactersNestedInput
    predator_types?: predator_typesUpdateOneRequiredWithoutCharactersNestedInput
    sects?: sectsUpdateOneWithoutCharactersNestedInput
    users?: usersUpdateOneRequiredWithoutCharactersNestedInput
    exp_logs?: exp_logsUpdateManyWithoutCharactersNestedInput
  }

  export type charactersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clan_id?: NullableStringFieldUpdateOperationsInput | string | null
    clan_bane?: NullableStringFieldUpdateOperationsInput | string | null
    clan_compulsion?: NullableStringFieldUpdateOperationsInput | string | null
    sect_id?: NullableStringFieldUpdateOperationsInput | string | null
    player?: StringFieldUpdateOperationsInput | string
    predator_type?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    chronicle_id?: NullableStringFieldUpdateOperationsInput | string | null
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    group_id?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUncheckedUpdateManyWithoutCharactersNestedInput
    character_alchemy_powers?: character_alchemy_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUncheckedUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUncheckedUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUncheckedUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUncheckedUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUncheckedUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUncheckedUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUncheckedUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUncheckedUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUncheckedUpdateManyWithoutCharactersNestedInput
    exp_logs?: exp_logsUncheckedUpdateManyWithoutCharactersNestedInput
  }

  export type charactersCreateManyInput = {
    id?: string
    user_id: string
    name: string
    clan_id?: string | null
    clan_bane?: string | null
    clan_compulsion?: string | null
    sect_id?: string | null
    player: string
    predator_type: string
    generation: number
    chronicle_id?: string | null
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    group_id: string
    type?: $Enums.Entity
  }

  export type charactersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    player?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
  }

  export type charactersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clan_id?: NullableStringFieldUpdateOperationsInput | string | null
    clan_bane?: NullableStringFieldUpdateOperationsInput | string | null
    clan_compulsion?: NullableStringFieldUpdateOperationsInput | string | null
    sect_id?: NullableStringFieldUpdateOperationsInput | string | null
    player?: StringFieldUpdateOperationsInput | string
    predator_type?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    chronicle_id?: NullableStringFieldUpdateOperationsInput | string | null
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    group_id?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
  }

  export type chroniclesCreateInput = {
    id?: string
    name: string
    description: string
    created_at?: Date | string
    updated_at?: Date | string
    characters?: charactersCreateNestedManyWithoutChroniclesInput
    users: usersCreateNestedOneWithoutChroniclesInput
  }

  export type chroniclesUncheckedCreateInput = {
    id?: string
    user_id: string
    name: string
    description: string
    created_at?: Date | string
    updated_at?: Date | string
    characters?: charactersUncheckedCreateNestedManyWithoutChroniclesInput
  }

  export type chroniclesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    characters?: charactersUpdateManyWithoutChroniclesNestedInput
    users?: usersUpdateOneRequiredWithoutChroniclesNestedInput
  }

  export type chroniclesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    characters?: charactersUncheckedUpdateManyWithoutChroniclesNestedInput
  }

  export type chroniclesCreateManyInput = {
    id?: string
    user_id: string
    name: string
    description: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type chroniclesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chroniclesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type clan_banesCreateInput = {
    id?: string
    name: string
    description: string
    character_bloodpotencies?: character_bloodpotenciesCreateNestedManyWithoutClan_banesInput
    characters?: charactersCreateNestedManyWithoutClan_banesInput
    clans: clansCreateNestedOneWithoutClan_banesInput
  }

  export type clan_banesUncheckedCreateInput = {
    id?: string
    name: string
    clan_id: string
    description: string
    character_bloodpotencies?: character_bloodpotenciesUncheckedCreateNestedManyWithoutClan_banesInput
    characters?: charactersUncheckedCreateNestedManyWithoutClan_banesInput
  }

  export type clan_banesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    character_bloodpotencies?: character_bloodpotenciesUpdateManyWithoutClan_banesNestedInput
    characters?: charactersUpdateManyWithoutClan_banesNestedInput
    clans?: clansUpdateOneRequiredWithoutClan_banesNestedInput
  }

  export type clan_banesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clan_id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    character_bloodpotencies?: character_bloodpotenciesUncheckedUpdateManyWithoutClan_banesNestedInput
    characters?: charactersUncheckedUpdateManyWithoutClan_banesNestedInput
  }

  export type clan_banesCreateManyInput = {
    id?: string
    name: string
    clan_id: string
    description: string
  }

  export type clan_banesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type clan_banesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clan_id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type clan_compulsionsCreateInput = {
    id?: string
    name: string
    description: string
    character_bloodpotencies?: character_bloodpotenciesCreateNestedManyWithoutClan_compulsionsInput
    characters?: charactersCreateNestedManyWithoutClan_compulsionsInput
    clans: clansCreateNestedOneWithoutClan_compulsionsInput
  }

  export type clan_compulsionsUncheckedCreateInput = {
    id?: string
    name: string
    clan_id: string
    description: string
    character_bloodpotencies?: character_bloodpotenciesUncheckedCreateNestedManyWithoutClan_compulsionsInput
    characters?: charactersUncheckedCreateNestedManyWithoutClan_compulsionsInput
  }

  export type clan_compulsionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    character_bloodpotencies?: character_bloodpotenciesUpdateManyWithoutClan_compulsionsNestedInput
    characters?: charactersUpdateManyWithoutClan_compulsionsNestedInput
    clans?: clansUpdateOneRequiredWithoutClan_compulsionsNestedInput
  }

  export type clan_compulsionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clan_id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    character_bloodpotencies?: character_bloodpotenciesUncheckedUpdateManyWithoutClan_compulsionsNestedInput
    characters?: charactersUncheckedUpdateManyWithoutClan_compulsionsNestedInput
  }

  export type clan_compulsionsCreateManyInput = {
    id?: string
    name: string
    clan_id: string
    description: string
  }

  export type clan_compulsionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type clan_compulsionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clan_id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type clansCreateInput = {
    id?: string
    name: string
    description: string
    advantages?: advantagesCreateNestedManyWithoutClansInput
    characters?: charactersCreateNestedManyWithoutClansInput
    clan_banes?: clan_banesCreateNestedManyWithoutClansInput
    clan_compulsions?: clan_compulsionsCreateNestedManyWithoutClansInput
  }

  export type clansUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    advantages?: advantagesUncheckedCreateNestedManyWithoutClansInput
    characters?: charactersUncheckedCreateNestedManyWithoutClansInput
    clan_banes?: clan_banesUncheckedCreateNestedManyWithoutClansInput
    clan_compulsions?: clan_compulsionsUncheckedCreateNestedManyWithoutClansInput
  }

  export type clansUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    advantages?: advantagesUpdateManyWithoutClansNestedInput
    characters?: charactersUpdateManyWithoutClansNestedInput
    clan_banes?: clan_banesUpdateManyWithoutClansNestedInput
    clan_compulsions?: clan_compulsionsUpdateManyWithoutClansNestedInput
  }

  export type clansUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    advantages?: advantagesUncheckedUpdateManyWithoutClansNestedInput
    characters?: charactersUncheckedUpdateManyWithoutClansNestedInput
    clan_banes?: clan_banesUncheckedUpdateManyWithoutClansNestedInput
    clan_compulsions?: clan_compulsionsUncheckedUpdateManyWithoutClansNestedInput
  }

  export type clansCreateManyInput = {
    id?: string
    name: string
    description: string
  }

  export type clansUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type clansUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type discipline_powersCreateInput = {
    id?: string
    name: string
    level: number
    description: string
    dice_pool: string
    cost: string
    prerequisites: string
    amalgam: string
    system: string
    duration: string
    character_discipline_powers?: character_discipline_powersCreateNestedManyWithoutDiscipline_powersInput
    disciplines: disciplinesCreateNestedOneWithoutDiscipline_powersInput
  }

  export type discipline_powersUncheckedCreateInput = {
    id?: string
    discipline_id: string
    name: string
    level: number
    description: string
    dice_pool: string
    cost: string
    prerequisites: string
    amalgam: string
    system: string
    duration: string
    character_discipline_powers?: character_discipline_powersUncheckedCreateNestedManyWithoutDiscipline_powersInput
  }

  export type discipline_powersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    dice_pool?: StringFieldUpdateOperationsInput | string
    cost?: StringFieldUpdateOperationsInput | string
    prerequisites?: StringFieldUpdateOperationsInput | string
    amalgam?: StringFieldUpdateOperationsInput | string
    system?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    character_discipline_powers?: character_discipline_powersUpdateManyWithoutDiscipline_powersNestedInput
    disciplines?: disciplinesUpdateOneRequiredWithoutDiscipline_powersNestedInput
  }

  export type discipline_powersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    discipline_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    dice_pool?: StringFieldUpdateOperationsInput | string
    cost?: StringFieldUpdateOperationsInput | string
    prerequisites?: StringFieldUpdateOperationsInput | string
    amalgam?: StringFieldUpdateOperationsInput | string
    system?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    character_discipline_powers?: character_discipline_powersUncheckedUpdateManyWithoutDiscipline_powersNestedInput
  }

  export type discipline_powersCreateManyInput = {
    id?: string
    discipline_id: string
    name: string
    level: number
    description: string
    dice_pool: string
    cost: string
    prerequisites: string
    amalgam: string
    system: string
    duration: string
  }

  export type discipline_powersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    dice_pool?: StringFieldUpdateOperationsInput | string
    cost?: StringFieldUpdateOperationsInput | string
    prerequisites?: StringFieldUpdateOperationsInput | string
    amalgam?: StringFieldUpdateOperationsInput | string
    system?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
  }

  export type discipline_powersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    discipline_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    dice_pool?: StringFieldUpdateOperationsInput | string
    cost?: StringFieldUpdateOperationsInput | string
    prerequisites?: StringFieldUpdateOperationsInput | string
    amalgam?: StringFieldUpdateOperationsInput | string
    system?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
  }

  export type disciplinesCreateInput = {
    id?: string
    name: string
    description: string
    nicknames: string
    characteristics: string
    type: string
    masquerade_threat: string
    blood_resonance: string
    character_disciplines?: character_disciplinesCreateNestedManyWithoutDisciplinesInput
    discipline_powers?: discipline_powersCreateNestedManyWithoutDisciplinesInput
  }

  export type disciplinesUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    nicknames: string
    characteristics: string
    type: string
    masquerade_threat: string
    blood_resonance: string
    character_disciplines?: character_disciplinesUncheckedCreateNestedManyWithoutDisciplinesInput
    discipline_powers?: discipline_powersUncheckedCreateNestedManyWithoutDisciplinesInput
  }

  export type disciplinesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    nicknames?: StringFieldUpdateOperationsInput | string
    characteristics?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    masquerade_threat?: StringFieldUpdateOperationsInput | string
    blood_resonance?: StringFieldUpdateOperationsInput | string
    character_disciplines?: character_disciplinesUpdateManyWithoutDisciplinesNestedInput
    discipline_powers?: discipline_powersUpdateManyWithoutDisciplinesNestedInput
  }

  export type disciplinesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    nicknames?: StringFieldUpdateOperationsInput | string
    characteristics?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    masquerade_threat?: StringFieldUpdateOperationsInput | string
    blood_resonance?: StringFieldUpdateOperationsInput | string
    character_disciplines?: character_disciplinesUncheckedUpdateManyWithoutDisciplinesNestedInput
    discipline_powers?: discipline_powersUncheckedUpdateManyWithoutDisciplinesNestedInput
  }

  export type disciplinesCreateManyInput = {
    id?: string
    name: string
    description: string
    nicknames: string
    characteristics: string
    type: string
    masquerade_threat: string
    blood_resonance: string
  }

  export type disciplinesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    nicknames?: StringFieldUpdateOperationsInput | string
    characteristics?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    masquerade_threat?: StringFieldUpdateOperationsInput | string
    blood_resonance?: StringFieldUpdateOperationsInput | string
  }

  export type disciplinesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    nicknames?: StringFieldUpdateOperationsInput | string
    characteristics?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    masquerade_threat?: StringFieldUpdateOperationsInput | string
    blood_resonance?: StringFieldUpdateOperationsInput | string
  }

  export type exp_logsCreateInput = {
    id?: string
    section?: string | null
    name?: string | null
    prev_level?: number | null
    new_level?: number | null
    expanditure?: number | null
    created_at?: Date | string
    characters: charactersCreateNestedOneWithoutExp_logsInput
    users: usersCreateNestedOneWithoutExp_logsInput
  }

  export type exp_logsUncheckedCreateInput = {
    id?: string
    user_id: string
    char_id: string
    section?: string | null
    name?: string | null
    prev_level?: number | null
    new_level?: number | null
    expanditure?: number | null
    created_at?: Date | string
  }

  export type exp_logsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    prev_level?: NullableIntFieldUpdateOperationsInput | number | null
    new_level?: NullableIntFieldUpdateOperationsInput | number | null
    expanditure?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    characters?: charactersUpdateOneRequiredWithoutExp_logsNestedInput
    users?: usersUpdateOneRequiredWithoutExp_logsNestedInput
  }

  export type exp_logsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    prev_level?: NullableIntFieldUpdateOperationsInput | number | null
    new_level?: NullableIntFieldUpdateOperationsInput | number | null
    expanditure?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type exp_logsCreateManyInput = {
    id?: string
    user_id: string
    char_id: string
    section?: string | null
    name?: string | null
    prev_level?: number | null
    new_level?: number | null
    expanditure?: number | null
    created_at?: Date | string
  }

  export type exp_logsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    prev_level?: NullableIntFieldUpdateOperationsInput | number | null
    new_level?: NullableIntFieldUpdateOperationsInput | number | null
    expanditure?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type exp_logsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    prev_level?: NullableIntFieldUpdateOperationsInput | number | null
    new_level?: NullableIntFieldUpdateOperationsInput | number | null
    expanditure?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type humanityCreateInput = {
    id?: string
    description: string
    level: number
  }

  export type humanityUncheckedCreateInput = {
    id?: string
    description: string
    level: number
  }

  export type humanityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
  }

  export type humanityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
  }

  export type humanityCreateManyInput = {
    id?: string
    description: string
    level: number
  }

  export type humanityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
  }

  export type humanityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
  }

  export type predator_typesCreateInput = {
    id?: string
    name: string
    description: string
    dice_pool: string
    benefits: string
    characters?: charactersCreateNestedManyWithoutPredator_typesInput
  }

  export type predator_typesUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    dice_pool: string
    benefits: string
    characters?: charactersUncheckedCreateNestedManyWithoutPredator_typesInput
  }

  export type predator_typesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dice_pool?: StringFieldUpdateOperationsInput | string
    benefits?: StringFieldUpdateOperationsInput | string
    characters?: charactersUpdateManyWithoutPredator_typesNestedInput
  }

  export type predator_typesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dice_pool?: StringFieldUpdateOperationsInput | string
    benefits?: StringFieldUpdateOperationsInput | string
    characters?: charactersUncheckedUpdateManyWithoutPredator_typesNestedInput
  }

  export type predator_typesCreateManyInput = {
    id?: string
    name: string
    description: string
    dice_pool: string
    benefits: string
  }

  export type predator_typesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dice_pool?: StringFieldUpdateOperationsInput | string
    benefits?: StringFieldUpdateOperationsInput | string
  }

  export type predator_typesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dice_pool?: StringFieldUpdateOperationsInput | string
    benefits?: StringFieldUpdateOperationsInput | string
  }

  export type ritualsCreateInput = {
    id?: string
    name: string
    description: string
    ingridients: string
    process: string
    system: string
    level: number
    character_rituals?: character_ritualsCreateNestedManyWithoutRitualsInput
  }

  export type ritualsUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    ingridients: string
    process: string
    system: string
    level: number
    character_rituals?: character_ritualsUncheckedCreateNestedManyWithoutRitualsInput
  }

  export type ritualsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ingridients?: StringFieldUpdateOperationsInput | string
    process?: StringFieldUpdateOperationsInput | string
    system?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    character_rituals?: character_ritualsUpdateManyWithoutRitualsNestedInput
  }

  export type ritualsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ingridients?: StringFieldUpdateOperationsInput | string
    process?: StringFieldUpdateOperationsInput | string
    system?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    character_rituals?: character_ritualsUncheckedUpdateManyWithoutRitualsNestedInput
  }

  export type ritualsCreateManyInput = {
    id?: string
    name: string
    description: string
    ingridients: string
    process: string
    system: string
    level: number
  }

  export type ritualsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ingridients?: StringFieldUpdateOperationsInput | string
    process?: StringFieldUpdateOperationsInput | string
    system?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
  }

  export type ritualsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ingridients?: StringFieldUpdateOperationsInput | string
    process?: StringFieldUpdateOperationsInput | string
    system?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
  }

  export type sectsCreateInput = {
    id?: string
    name: string
    description: string
    advantages?: advantagesCreateNestedManyWithoutSectsInput
    characters?: charactersCreateNestedManyWithoutSectsInput
  }

  export type sectsUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    advantages?: advantagesUncheckedCreateNestedManyWithoutSectsInput
    characters?: charactersUncheckedCreateNestedManyWithoutSectsInput
  }

  export type sectsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    advantages?: advantagesUpdateManyWithoutSectsNestedInput
    characters?: charactersUpdateManyWithoutSectsNestedInput
  }

  export type sectsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    advantages?: advantagesUncheckedUpdateManyWithoutSectsNestedInput
    characters?: charactersUncheckedUpdateManyWithoutSectsNestedInput
  }

  export type sectsCreateManyInput = {
    id?: string
    name: string
    description: string
  }

  export type sectsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type sectsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type skillsCreateInput = {
    id?: string
    name: string
    description: string
    character_skills?: character_skillsCreateNestedManyWithoutSkillsInput
    character_specialties?: character_specialtiesCreateNestedManyWithoutSkillsInput
  }

  export type skillsUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    character_skills?: character_skillsUncheckedCreateNestedManyWithoutSkillsInput
    character_specialties?: character_specialtiesUncheckedCreateNestedManyWithoutSkillsInput
  }

  export type skillsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    character_skills?: character_skillsUpdateManyWithoutSkillsNestedInput
    character_specialties?: character_specialtiesUpdateManyWithoutSkillsNestedInput
  }

  export type skillsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    character_skills?: character_skillsUncheckedUpdateManyWithoutSkillsNestedInput
    character_specialties?: character_specialtiesUncheckedUpdateManyWithoutSkillsNestedInput
  }

  export type skillsCreateManyInput = {
    id?: string
    name: string
    description: string
  }

  export type skillsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type skillsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type usersCreateInput = {
    id?: string
    clerk_user_id: string
    email: string
    name: string
    image_url?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    char_groups?: char_groupsCreateNestedManyWithoutUsersInput
    characters?: charactersCreateNestedManyWithoutUsersInput
    chronicles?: chroniclesCreateNestedManyWithoutUsersInput
    exp_logs?: exp_logsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateInput = {
    id?: string
    clerk_user_id: string
    email: string
    name: string
    image_url?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    char_groups?: char_groupsUncheckedCreateNestedManyWithoutUsersInput
    characters?: charactersUncheckedCreateNestedManyWithoutUsersInput
    chronicles?: chroniclesUncheckedCreateNestedManyWithoutUsersInput
    exp_logs?: exp_logsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerk_user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    char_groups?: char_groupsUpdateManyWithoutUsersNestedInput
    characters?: charactersUpdateManyWithoutUsersNestedInput
    chronicles?: chroniclesUpdateManyWithoutUsersNestedInput
    exp_logs?: exp_logsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerk_user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    char_groups?: char_groupsUncheckedUpdateManyWithoutUsersNestedInput
    characters?: charactersUncheckedUpdateManyWithoutUsersNestedInput
    chronicles?: chroniclesUncheckedUpdateManyWithoutUsersNestedInput
    exp_logs?: exp_logsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateManyInput = {
    id?: string
    clerk_user_id: string
    email: string
    name: string
    image_url?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type usersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerk_user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerk_user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumtypeFilter<$PrismaModel = never> = {
    equals?: $Enums.type | EnumtypeFieldRefInput<$PrismaModel>
    in?: $Enums.type[] | ListEnumtypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.type[] | ListEnumtypeFieldRefInput<$PrismaModel>
    not?: NestedEnumtypeFilter<$PrismaModel> | $Enums.type
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumforWhomFilter<$PrismaModel = never> = {
    equals?: $Enums.forWhom | EnumforWhomFieldRefInput<$PrismaModel>
    in?: $Enums.forWhom[] | ListEnumforWhomFieldRefInput<$PrismaModel>
    notIn?: $Enums.forWhom[] | ListEnumforWhomFieldRefInput<$PrismaModel>
    not?: NestedEnumforWhomFilter<$PrismaModel> | $Enums.forWhom
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type ClansNullableScalarRelationFilter = {
    is?: clansWhereInput | null
    isNot?: clansWhereInput | null
  }

  export type SectsNullableScalarRelationFilter = {
    is?: sectsWhereInput | null
    isNot?: sectsWhereInput | null
  }

  export type Character_advantagesListRelationFilter = {
    every?: character_advantagesWhereInput
    some?: character_advantagesWhereInput
    none?: character_advantagesWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type character_advantagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type advantagesCountOrderByAggregateInput = {
    id?: SortOrder
    parent_name?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    level?: SortOrder
    for?: SortOrder
    clan_req?: SortOrder
    sect_req?: SortOrder
  }

  export type advantagesAvgOrderByAggregateInput = {
    level?: SortOrder
  }

  export type advantagesMaxOrderByAggregateInput = {
    id?: SortOrder
    parent_name?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    level?: SortOrder
    for?: SortOrder
    clan_req?: SortOrder
    sect_req?: SortOrder
  }

  export type advantagesMinOrderByAggregateInput = {
    id?: SortOrder
    parent_name?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    level?: SortOrder
    for?: SortOrder
    clan_req?: SortOrder
    sect_req?: SortOrder
  }

  export type advantagesSumOrderByAggregateInput = {
    level?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumtypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.type | EnumtypeFieldRefInput<$PrismaModel>
    in?: $Enums.type[] | ListEnumtypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.type[] | ListEnumtypeFieldRefInput<$PrismaModel>
    not?: NestedEnumtypeWithAggregatesFilter<$PrismaModel> | $Enums.type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtypeFilter<$PrismaModel>
    _max?: NestedEnumtypeFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumforWhomWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.forWhom | EnumforWhomFieldRefInput<$PrismaModel>
    in?: $Enums.forWhom[] | ListEnumforWhomFieldRefInput<$PrismaModel>
    notIn?: $Enums.forWhom[] | ListEnumforWhomFieldRefInput<$PrismaModel>
    not?: NestedEnumforWhomWithAggregatesFilter<$PrismaModel> | $Enums.forWhom
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumforWhomFilter<$PrismaModel>
    _max?: NestedEnumforWhomFilter<$PrismaModel>
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type Character_alchemy_powersListRelationFilter = {
    every?: character_alchemy_powersWhereInput
    some?: character_alchemy_powersWhereInput
    none?: character_alchemy_powersWhereInput
  }

  export type character_alchemy_powersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type alchemy_powersCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ingridients?: SortOrder
    activation?: SortOrder
    dice_pool?: SortOrder
    system?: SortOrder
    duration?: SortOrder
    level?: SortOrder
  }

  export type alchemy_powersAvgOrderByAggregateInput = {
    level?: SortOrder
  }

  export type alchemy_powersMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ingridients?: SortOrder
    activation?: SortOrder
    dice_pool?: SortOrder
    system?: SortOrder
    duration?: SortOrder
    level?: SortOrder
  }

  export type alchemy_powersMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ingridients?: SortOrder
    activation?: SortOrder
    dice_pool?: SortOrder
    system?: SortOrder
    duration?: SortOrder
    level?: SortOrder
  }

  export type alchemy_powersSumOrderByAggregateInput = {
    level?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumcategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.category | EnumcategoryFieldRefInput<$PrismaModel>
    in?: $Enums.category[] | ListEnumcategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.category[] | ListEnumcategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumcategoryFilter<$PrismaModel> | $Enums.category
  }

  export type Character_attributesListRelationFilter = {
    every?: character_attributesWhereInput
    some?: character_attributesWhereInput
    none?: character_attributesWhereInput
  }

  export type character_attributesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type attributesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
  }

  export type attributesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
  }

  export type attributesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
  }

  export type EnumcategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.category | EnumcategoryFieldRefInput<$PrismaModel>
    in?: $Enums.category[] | ListEnumcategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.category[] | ListEnumcategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumcategoryWithAggregatesFilter<$PrismaModel> | $Enums.category
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumcategoryFilter<$PrismaModel>
    _max?: NestedEnumcategoryFilter<$PrismaModel>
  }

  export type Character_bloodpotenciesListRelationFilter = {
    every?: character_bloodpotenciesWhereInput
    some?: character_bloodpotenciesWhereInput
    none?: character_bloodpotenciesWhereInput
  }

  export type character_bloodpotenciesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type blood_potencyCountOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    description?: SortOrder
    blood_surge?: SortOrder
    damage_mend?: SortOrder
    power_bonus?: SortOrder
    rc_reroll?: SortOrder
    bane_severity?: SortOrder
    feeding_penalty?: SortOrder
  }

  export type blood_potencyAvgOrderByAggregateInput = {
    level?: SortOrder
    bane_severity?: SortOrder
  }

  export type blood_potencyMaxOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    description?: SortOrder
    blood_surge?: SortOrder
    damage_mend?: SortOrder
    power_bonus?: SortOrder
    rc_reroll?: SortOrder
    bane_severity?: SortOrder
    feeding_penalty?: SortOrder
  }

  export type blood_potencyMinOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    description?: SortOrder
    blood_surge?: SortOrder
    damage_mend?: SortOrder
    power_bonus?: SortOrder
    rc_reroll?: SortOrder
    bane_severity?: SortOrder
    feeding_penalty?: SortOrder
  }

  export type blood_potencySumOrderByAggregateInput = {
    level?: SortOrder
    bane_severity?: SortOrder
  }

  export type Char_groupsNullableScalarRelationFilter = {
    is?: char_groupsWhereInput | null
    isNot?: char_groupsWhereInput | null
  }

  export type Char_groupsListRelationFilter = {
    every?: char_groupsWhereInput
    some?: char_groupsWhereInput
    none?: char_groupsWhereInput
  }

  export type UsersScalarRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type CharactersListRelationFilter = {
    every?: charactersWhereInput
    some?: charactersWhereInput
    none?: charactersWhereInput
  }

  export type char_groupsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type charactersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type char_groupsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    parent_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type char_groupsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    parent_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type char_groupsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    parent_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type AdvantagesScalarRelationFilter = {
    is?: advantagesWhereInput
    isNot?: advantagesWhereInput
  }

  export type CharactersScalarRelationFilter = {
    is?: charactersWhereInput
    isNot?: charactersWhereInput
  }

  export type character_advantagesCountOrderByAggregateInput = {
    id?: SortOrder
    char_id?: SortOrder
    advantage_id?: SortOrder
  }

  export type character_advantagesMaxOrderByAggregateInput = {
    id?: SortOrder
    char_id?: SortOrder
    advantage_id?: SortOrder
  }

  export type character_advantagesMinOrderByAggregateInput = {
    id?: SortOrder
    char_id?: SortOrder
    advantage_id?: SortOrder
  }

  export type Alchemy_powersScalarRelationFilter = {
    is?: alchemy_powersWhereInput
    isNot?: alchemy_powersWhereInput
  }

  export type character_alchemy_powersCountOrderByAggregateInput = {
    id?: SortOrder
    char_id?: SortOrder
    alchemy_power_id?: SortOrder
  }

  export type character_alchemy_powersMaxOrderByAggregateInput = {
    id?: SortOrder
    char_id?: SortOrder
    alchemy_power_id?: SortOrder
  }

  export type character_alchemy_powersMinOrderByAggregateInput = {
    id?: SortOrder
    char_id?: SortOrder
    alchemy_power_id?: SortOrder
  }

  export type AttributesScalarRelationFilter = {
    is?: attributesWhereInput
    isNot?: attributesWhereInput
  }

  export type character_attributesCountOrderByAggregateInput = {
    id?: SortOrder
    char_id?: SortOrder
    attribute_id?: SortOrder
    level?: SortOrder
  }

  export type character_attributesAvgOrderByAggregateInput = {
    level?: SortOrder
  }

  export type character_attributesMaxOrderByAggregateInput = {
    id?: SortOrder
    char_id?: SortOrder
    attribute_id?: SortOrder
    level?: SortOrder
  }

  export type character_attributesMinOrderByAggregateInput = {
    id?: SortOrder
    char_id?: SortOrder
    attribute_id?: SortOrder
    level?: SortOrder
  }

  export type character_attributesSumOrderByAggregateInput = {
    level?: SortOrder
  }

  export type Blood_potencyNullableScalarRelationFilter = {
    is?: blood_potencyWhereInput | null
    isNot?: blood_potencyWhereInput | null
  }

  export type Clan_compulsionsNullableScalarRelationFilter = {
    is?: clan_compulsionsWhereInput | null
    isNot?: clan_compulsionsWhereInput | null
  }

  export type Clan_banesNullableScalarRelationFilter = {
    is?: clan_banesWhereInput | null
    isNot?: clan_banesWhereInput | null
  }

  export type character_bloodpotenciesCountOrderByAggregateInput = {
    id?: SortOrder
    char_id?: SortOrder
    blood_potency_level?: SortOrder
    blood_surge?: SortOrder
    bane_severity?: SortOrder
    power_bonus?: SortOrder
    feeding_penalty?: SortOrder
    mend_amount?: SortOrder
    rc_reroll?: SortOrder
    clane_bane?: SortOrder
    clan_compulsion?: SortOrder
  }

  export type character_bloodpotenciesAvgOrderByAggregateInput = {
    bane_severity?: SortOrder
    mend_amount?: SortOrder
  }

  export type character_bloodpotenciesMaxOrderByAggregateInput = {
    id?: SortOrder
    char_id?: SortOrder
    blood_potency_level?: SortOrder
    blood_surge?: SortOrder
    bane_severity?: SortOrder
    power_bonus?: SortOrder
    feeding_penalty?: SortOrder
    mend_amount?: SortOrder
    rc_reroll?: SortOrder
    clane_bane?: SortOrder
    clan_compulsion?: SortOrder
  }

  export type character_bloodpotenciesMinOrderByAggregateInput = {
    id?: SortOrder
    char_id?: SortOrder
    blood_potency_level?: SortOrder
    blood_surge?: SortOrder
    bane_severity?: SortOrder
    power_bonus?: SortOrder
    feeding_penalty?: SortOrder
    mend_amount?: SortOrder
    rc_reroll?: SortOrder
    clane_bane?: SortOrder
    clan_compulsion?: SortOrder
  }

  export type character_bloodpotenciesSumOrderByAggregateInput = {
    bane_severity?: SortOrder
    mend_amount?: SortOrder
  }

  export type Discipline_powersScalarRelationFilter = {
    is?: discipline_powersWhereInput
    isNot?: discipline_powersWhereInput
  }

  export type character_discipline_powersCountOrderByAggregateInput = {
    id?: SortOrder
    char_id?: SortOrder
    discipline_power_id?: SortOrder
  }

  export type character_discipline_powersMaxOrderByAggregateInput = {
    id?: SortOrder
    char_id?: SortOrder
    discipline_power_id?: SortOrder
  }

  export type character_discipline_powersMinOrderByAggregateInput = {
    id?: SortOrder
    char_id?: SortOrder
    discipline_power_id?: SortOrder
  }

  export type DisciplinesScalarRelationFilter = {
    is?: disciplinesWhereInput
    isNot?: disciplinesWhereInput
  }

  export type character_disciplinesCountOrderByAggregateInput = {
    id?: SortOrder
    char_id?: SortOrder
    discipline_id?: SortOrder
  }

  export type character_disciplinesMaxOrderByAggregateInput = {
    id?: SortOrder
    char_id?: SortOrder
    discipline_id?: SortOrder
  }

  export type character_disciplinesMinOrderByAggregateInput = {
    id?: SortOrder
    char_id?: SortOrder
    discipline_id?: SortOrder
  }

  export type character_healthsCountOrderByAggregateInput = {
    id?: SortOrder
    char_id?: SortOrder
    max_health?: SortOrder
    current_aggravated?: SortOrder
    current_superficial?: SortOrder
  }

  export type character_healthsAvgOrderByAggregateInput = {
    max_health?: SortOrder
    current_aggravated?: SortOrder
    current_superficial?: SortOrder
  }

  export type character_healthsMaxOrderByAggregateInput = {
    id?: SortOrder
    char_id?: SortOrder
    max_health?: SortOrder
    current_aggravated?: SortOrder
    current_superficial?: SortOrder
  }

  export type character_healthsMinOrderByAggregateInput = {
    id?: SortOrder
    char_id?: SortOrder
    max_health?: SortOrder
    current_aggravated?: SortOrder
    current_superficial?: SortOrder
  }

  export type character_healthsSumOrderByAggregateInput = {
    max_health?: SortOrder
    current_aggravated?: SortOrder
    current_superficial?: SortOrder
  }

  export type character_humanityCountOrderByAggregateInput = {
    id?: SortOrder
    char_id?: SortOrder
    level?: SortOrder
    stain_count?: SortOrder
  }

  export type character_humanityAvgOrderByAggregateInput = {
    level?: SortOrder
    stain_count?: SortOrder
  }

  export type character_humanityMaxOrderByAggregateInput = {
    id?: SortOrder
    char_id?: SortOrder
    level?: SortOrder
    stain_count?: SortOrder
  }

  export type character_humanityMinOrderByAggregateInput = {
    id?: SortOrder
    char_id?: SortOrder
    level?: SortOrder
    stain_count?: SortOrder
  }

  export type character_humanitySumOrderByAggregateInput = {
    level?: SortOrder
    stain_count?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type character_profileCountOrderByAggregateInput = {
    id?: SortOrder
    char_id?: SortOrder
    description?: SortOrder
    birthday?: SortOrder
    notes?: SortOrder
    age?: SortOrder
    embraced_at?: SortOrder
    apparent_age?: SortOrder
    concept?: SortOrder
  }

  export type character_profileAvgOrderByAggregateInput = {
    age?: SortOrder
    apparent_age?: SortOrder
  }

  export type character_profileMaxOrderByAggregateInput = {
    id?: SortOrder
    char_id?: SortOrder
    description?: SortOrder
    birthday?: SortOrder
    notes?: SortOrder
    age?: SortOrder
    embraced_at?: SortOrder
    apparent_age?: SortOrder
    concept?: SortOrder
  }

  export type character_profileMinOrderByAggregateInput = {
    id?: SortOrder
    char_id?: SortOrder
    description?: SortOrder
    birthday?: SortOrder
    notes?: SortOrder
    age?: SortOrder
    embraced_at?: SortOrder
    apparent_age?: SortOrder
    concept?: SortOrder
  }

  export type character_profileSumOrderByAggregateInput = {
    age?: SortOrder
    apparent_age?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type RitualsScalarRelationFilter = {
    is?: ritualsWhereInput
    isNot?: ritualsWhereInput
  }

  export type character_ritualsCountOrderByAggregateInput = {
    id?: SortOrder
    char_id?: SortOrder
    ritual_id?: SortOrder
  }

  export type character_ritualsMaxOrderByAggregateInput = {
    id?: SortOrder
    char_id?: SortOrder
    ritual_id?: SortOrder
  }

  export type character_ritualsMinOrderByAggregateInput = {
    id?: SortOrder
    char_id?: SortOrder
    ritual_id?: SortOrder
  }

  export type SkillsScalarRelationFilter = {
    is?: skillsWhereInput
    isNot?: skillsWhereInput
  }

  export type character_skillsCountOrderByAggregateInput = {
    id?: SortOrder
    char_id?: SortOrder
    skill_id?: SortOrder
    level?: SortOrder
  }

  export type character_skillsAvgOrderByAggregateInput = {
    level?: SortOrder
  }

  export type character_skillsMaxOrderByAggregateInput = {
    id?: SortOrder
    char_id?: SortOrder
    skill_id?: SortOrder
    level?: SortOrder
  }

  export type character_skillsMinOrderByAggregateInput = {
    id?: SortOrder
    char_id?: SortOrder
    skill_id?: SortOrder
    level?: SortOrder
  }

  export type character_skillsSumOrderByAggregateInput = {
    level?: SortOrder
  }

  export type character_specialtiesCountOrderByAggregateInput = {
    id?: SortOrder
    char_id?: SortOrder
    skill_id?: SortOrder
    specialty_name?: SortOrder
  }

  export type character_specialtiesMaxOrderByAggregateInput = {
    id?: SortOrder
    char_id?: SortOrder
    skill_id?: SortOrder
    specialty_name?: SortOrder
  }

  export type character_specialtiesMinOrderByAggregateInput = {
    id?: SortOrder
    char_id?: SortOrder
    skill_id?: SortOrder
    specialty_name?: SortOrder
  }

  export type character_willpowersCountOrderByAggregateInput = {
    id?: SortOrder
    char_id?: SortOrder
    max_willpower?: SortOrder
    current_aggravated?: SortOrder
    current_superficial?: SortOrder
  }

  export type character_willpowersAvgOrderByAggregateInput = {
    max_willpower?: SortOrder
    current_aggravated?: SortOrder
    current_superficial?: SortOrder
  }

  export type character_willpowersMaxOrderByAggregateInput = {
    id?: SortOrder
    char_id?: SortOrder
    max_willpower?: SortOrder
    current_aggravated?: SortOrder
    current_superficial?: SortOrder
  }

  export type character_willpowersMinOrderByAggregateInput = {
    id?: SortOrder
    char_id?: SortOrder
    max_willpower?: SortOrder
    current_aggravated?: SortOrder
    current_superficial?: SortOrder
  }

  export type character_willpowersSumOrderByAggregateInput = {
    max_willpower?: SortOrder
    current_aggravated?: SortOrder
    current_superficial?: SortOrder
  }

  export type EnumEntityFilter<$PrismaModel = never> = {
    equals?: $Enums.Entity | EnumEntityFieldRefInput<$PrismaModel>
    in?: $Enums.Entity[] | ListEnumEntityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Entity[] | ListEnumEntityFieldRefInput<$PrismaModel>
    not?: NestedEnumEntityFilter<$PrismaModel> | $Enums.Entity
  }

  export type Character_discipline_powersListRelationFilter = {
    every?: character_discipline_powersWhereInput
    some?: character_discipline_powersWhereInput
    none?: character_discipline_powersWhereInput
  }

  export type Character_disciplinesListRelationFilter = {
    every?: character_disciplinesWhereInput
    some?: character_disciplinesWhereInput
    none?: character_disciplinesWhereInput
  }

  export type Character_healthsListRelationFilter = {
    every?: character_healthsWhereInput
    some?: character_healthsWhereInput
    none?: character_healthsWhereInput
  }

  export type Character_humanityListRelationFilter = {
    every?: character_humanityWhereInput
    some?: character_humanityWhereInput
    none?: character_humanityWhereInput
  }

  export type Character_profileListRelationFilter = {
    every?: character_profileWhereInput
    some?: character_profileWhereInput
    none?: character_profileWhereInput
  }

  export type Character_ritualsListRelationFilter = {
    every?: character_ritualsWhereInput
    some?: character_ritualsWhereInput
    none?: character_ritualsWhereInput
  }

  export type Character_skillsListRelationFilter = {
    every?: character_skillsWhereInput
    some?: character_skillsWhereInput
    none?: character_skillsWhereInput
  }

  export type Character_specialtiesListRelationFilter = {
    every?: character_specialtiesWhereInput
    some?: character_specialtiesWhereInput
    none?: character_specialtiesWhereInput
  }

  export type Character_willpowersListRelationFilter = {
    every?: character_willpowersWhereInput
    some?: character_willpowersWhereInput
    none?: character_willpowersWhereInput
  }

  export type ChroniclesNullableScalarRelationFilter = {
    is?: chroniclesWhereInput | null
    isNot?: chroniclesWhereInput | null
  }

  export type Char_groupsScalarRelationFilter = {
    is?: char_groupsWhereInput
    isNot?: char_groupsWhereInput
  }

  export type Predator_typesScalarRelationFilter = {
    is?: predator_typesWhereInput
    isNot?: predator_typesWhereInput
  }

  export type Exp_logsListRelationFilter = {
    every?: exp_logsWhereInput
    some?: exp_logsWhereInput
    none?: exp_logsWhereInput
  }

  export type character_discipline_powersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type character_disciplinesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type character_healthsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type character_humanityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type character_profileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type character_ritualsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type character_skillsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type character_specialtiesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type character_willpowersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type exp_logsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type charactersCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    clan_id?: SortOrder
    clan_bane?: SortOrder
    clan_compulsion?: SortOrder
    sect_id?: SortOrder
    player?: SortOrder
    predator_type?: SortOrder
    generation?: SortOrder
    chronicle_id?: SortOrder
    custom_chronicle?: SortOrder
    ambition?: SortOrder
    desire?: SortOrder
    sire?: SortOrder
    total_experience?: SortOrder
    chronicle_tenets?: SortOrder
    group_id?: SortOrder
    type?: SortOrder
  }

  export type charactersAvgOrderByAggregateInput = {
    generation?: SortOrder
    total_experience?: SortOrder
  }

  export type charactersMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    clan_id?: SortOrder
    clan_bane?: SortOrder
    clan_compulsion?: SortOrder
    sect_id?: SortOrder
    player?: SortOrder
    predator_type?: SortOrder
    generation?: SortOrder
    chronicle_id?: SortOrder
    custom_chronicle?: SortOrder
    ambition?: SortOrder
    desire?: SortOrder
    sire?: SortOrder
    total_experience?: SortOrder
    chronicle_tenets?: SortOrder
    group_id?: SortOrder
    type?: SortOrder
  }

  export type charactersMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    clan_id?: SortOrder
    clan_bane?: SortOrder
    clan_compulsion?: SortOrder
    sect_id?: SortOrder
    player?: SortOrder
    predator_type?: SortOrder
    generation?: SortOrder
    chronicle_id?: SortOrder
    custom_chronicle?: SortOrder
    ambition?: SortOrder
    desire?: SortOrder
    sire?: SortOrder
    total_experience?: SortOrder
    chronicle_tenets?: SortOrder
    group_id?: SortOrder
    type?: SortOrder
  }

  export type charactersSumOrderByAggregateInput = {
    generation?: SortOrder
    total_experience?: SortOrder
  }

  export type EnumEntityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Entity | EnumEntityFieldRefInput<$PrismaModel>
    in?: $Enums.Entity[] | ListEnumEntityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Entity[] | ListEnumEntityFieldRefInput<$PrismaModel>
    not?: NestedEnumEntityWithAggregatesFilter<$PrismaModel> | $Enums.Entity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEntityFilter<$PrismaModel>
    _max?: NestedEnumEntityFilter<$PrismaModel>
  }

  export type chroniclesCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type chroniclesMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type chroniclesMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ClansScalarRelationFilter = {
    is?: clansWhereInput
    isNot?: clansWhereInput
  }

  export type clan_banesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    clan_id?: SortOrder
    description?: SortOrder
  }

  export type clan_banesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    clan_id?: SortOrder
    description?: SortOrder
  }

  export type clan_banesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    clan_id?: SortOrder
    description?: SortOrder
  }

  export type clan_compulsionsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    clan_id?: SortOrder
    description?: SortOrder
  }

  export type clan_compulsionsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    clan_id?: SortOrder
    description?: SortOrder
  }

  export type clan_compulsionsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    clan_id?: SortOrder
    description?: SortOrder
  }

  export type AdvantagesListRelationFilter = {
    every?: advantagesWhereInput
    some?: advantagesWhereInput
    none?: advantagesWhereInput
  }

  export type Clan_banesListRelationFilter = {
    every?: clan_banesWhereInput
    some?: clan_banesWhereInput
    none?: clan_banesWhereInput
  }

  export type Clan_compulsionsListRelationFilter = {
    every?: clan_compulsionsWhereInput
    some?: clan_compulsionsWhereInput
    none?: clan_compulsionsWhereInput
  }

  export type advantagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type clan_banesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type clan_compulsionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type clansCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type clansMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type clansMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type discipline_powersCountOrderByAggregateInput = {
    id?: SortOrder
    discipline_id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    description?: SortOrder
    dice_pool?: SortOrder
    cost?: SortOrder
    prerequisites?: SortOrder
    amalgam?: SortOrder
    system?: SortOrder
    duration?: SortOrder
  }

  export type discipline_powersAvgOrderByAggregateInput = {
    level?: SortOrder
  }

  export type discipline_powersMaxOrderByAggregateInput = {
    id?: SortOrder
    discipline_id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    description?: SortOrder
    dice_pool?: SortOrder
    cost?: SortOrder
    prerequisites?: SortOrder
    amalgam?: SortOrder
    system?: SortOrder
    duration?: SortOrder
  }

  export type discipline_powersMinOrderByAggregateInput = {
    id?: SortOrder
    discipline_id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    description?: SortOrder
    dice_pool?: SortOrder
    cost?: SortOrder
    prerequisites?: SortOrder
    amalgam?: SortOrder
    system?: SortOrder
    duration?: SortOrder
  }

  export type discipline_powersSumOrderByAggregateInput = {
    level?: SortOrder
  }

  export type Discipline_powersListRelationFilter = {
    every?: discipline_powersWhereInput
    some?: discipline_powersWhereInput
    none?: discipline_powersWhereInput
  }

  export type discipline_powersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type disciplinesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    nicknames?: SortOrder
    characteristics?: SortOrder
    type?: SortOrder
    masquerade_threat?: SortOrder
    blood_resonance?: SortOrder
  }

  export type disciplinesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    nicknames?: SortOrder
    characteristics?: SortOrder
    type?: SortOrder
    masquerade_threat?: SortOrder
    blood_resonance?: SortOrder
  }

  export type disciplinesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    nicknames?: SortOrder
    characteristics?: SortOrder
    type?: SortOrder
    masquerade_threat?: SortOrder
    blood_resonance?: SortOrder
  }

  export type exp_logsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    char_id?: SortOrder
    section?: SortOrder
    name?: SortOrder
    prev_level?: SortOrder
    new_level?: SortOrder
    expanditure?: SortOrder
    created_at?: SortOrder
  }

  export type exp_logsAvgOrderByAggregateInput = {
    prev_level?: SortOrder
    new_level?: SortOrder
    expanditure?: SortOrder
  }

  export type exp_logsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    char_id?: SortOrder
    section?: SortOrder
    name?: SortOrder
    prev_level?: SortOrder
    new_level?: SortOrder
    expanditure?: SortOrder
    created_at?: SortOrder
  }

  export type exp_logsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    char_id?: SortOrder
    section?: SortOrder
    name?: SortOrder
    prev_level?: SortOrder
    new_level?: SortOrder
    expanditure?: SortOrder
    created_at?: SortOrder
  }

  export type exp_logsSumOrderByAggregateInput = {
    prev_level?: SortOrder
    new_level?: SortOrder
    expanditure?: SortOrder
  }

  export type humanityCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    level?: SortOrder
  }

  export type humanityAvgOrderByAggregateInput = {
    level?: SortOrder
  }

  export type humanityMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    level?: SortOrder
  }

  export type humanityMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    level?: SortOrder
  }

  export type humanitySumOrderByAggregateInput = {
    level?: SortOrder
  }

  export type predator_typesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    dice_pool?: SortOrder
    benefits?: SortOrder
  }

  export type predator_typesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    dice_pool?: SortOrder
    benefits?: SortOrder
  }

  export type predator_typesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    dice_pool?: SortOrder
    benefits?: SortOrder
  }

  export type ritualsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ingridients?: SortOrder
    process?: SortOrder
    system?: SortOrder
    level?: SortOrder
  }

  export type ritualsAvgOrderByAggregateInput = {
    level?: SortOrder
  }

  export type ritualsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ingridients?: SortOrder
    process?: SortOrder
    system?: SortOrder
    level?: SortOrder
  }

  export type ritualsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ingridients?: SortOrder
    process?: SortOrder
    system?: SortOrder
    level?: SortOrder
  }

  export type ritualsSumOrderByAggregateInput = {
    level?: SortOrder
  }

  export type sectsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type sectsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type sectsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type skillsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type skillsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type skillsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ChroniclesListRelationFilter = {
    every?: chroniclesWhereInput
    some?: chroniclesWhereInput
    none?: chroniclesWhereInput
  }

  export type chroniclesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    clerk_user_id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    image_url?: SortOrder
    deleted_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    clerk_user_id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    image_url?: SortOrder
    deleted_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    clerk_user_id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    image_url?: SortOrder
    deleted_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type clansCreateNestedOneWithoutAdvantagesInput = {
    create?: XOR<clansCreateWithoutAdvantagesInput, clansUncheckedCreateWithoutAdvantagesInput>
    connectOrCreate?: clansCreateOrConnectWithoutAdvantagesInput
    connect?: clansWhereUniqueInput
  }

  export type sectsCreateNestedOneWithoutAdvantagesInput = {
    create?: XOR<sectsCreateWithoutAdvantagesInput, sectsUncheckedCreateWithoutAdvantagesInput>
    connectOrCreate?: sectsCreateOrConnectWithoutAdvantagesInput
    connect?: sectsWhereUniqueInput
  }

  export type character_advantagesCreateNestedManyWithoutAdvantagesInput = {
    create?: XOR<character_advantagesCreateWithoutAdvantagesInput, character_advantagesUncheckedCreateWithoutAdvantagesInput> | character_advantagesCreateWithoutAdvantagesInput[] | character_advantagesUncheckedCreateWithoutAdvantagesInput[]
    connectOrCreate?: character_advantagesCreateOrConnectWithoutAdvantagesInput | character_advantagesCreateOrConnectWithoutAdvantagesInput[]
    createMany?: character_advantagesCreateManyAdvantagesInputEnvelope
    connect?: character_advantagesWhereUniqueInput | character_advantagesWhereUniqueInput[]
  }

  export type character_advantagesUncheckedCreateNestedManyWithoutAdvantagesInput = {
    create?: XOR<character_advantagesCreateWithoutAdvantagesInput, character_advantagesUncheckedCreateWithoutAdvantagesInput> | character_advantagesCreateWithoutAdvantagesInput[] | character_advantagesUncheckedCreateWithoutAdvantagesInput[]
    connectOrCreate?: character_advantagesCreateOrConnectWithoutAdvantagesInput | character_advantagesCreateOrConnectWithoutAdvantagesInput[]
    createMany?: character_advantagesCreateManyAdvantagesInputEnvelope
    connect?: character_advantagesWhereUniqueInput | character_advantagesWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumtypeFieldUpdateOperationsInput = {
    set?: $Enums.type
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumforWhomFieldUpdateOperationsInput = {
    set?: $Enums.forWhom
  }

  export type clansUpdateOneWithoutAdvantagesNestedInput = {
    create?: XOR<clansCreateWithoutAdvantagesInput, clansUncheckedCreateWithoutAdvantagesInput>
    connectOrCreate?: clansCreateOrConnectWithoutAdvantagesInput
    upsert?: clansUpsertWithoutAdvantagesInput
    disconnect?: clansWhereInput | boolean
    delete?: clansWhereInput | boolean
    connect?: clansWhereUniqueInput
    update?: XOR<XOR<clansUpdateToOneWithWhereWithoutAdvantagesInput, clansUpdateWithoutAdvantagesInput>, clansUncheckedUpdateWithoutAdvantagesInput>
  }

  export type sectsUpdateOneWithoutAdvantagesNestedInput = {
    create?: XOR<sectsCreateWithoutAdvantagesInput, sectsUncheckedCreateWithoutAdvantagesInput>
    connectOrCreate?: sectsCreateOrConnectWithoutAdvantagesInput
    upsert?: sectsUpsertWithoutAdvantagesInput
    disconnect?: sectsWhereInput | boolean
    delete?: sectsWhereInput | boolean
    connect?: sectsWhereUniqueInput
    update?: XOR<XOR<sectsUpdateToOneWithWhereWithoutAdvantagesInput, sectsUpdateWithoutAdvantagesInput>, sectsUncheckedUpdateWithoutAdvantagesInput>
  }

  export type character_advantagesUpdateManyWithoutAdvantagesNestedInput = {
    create?: XOR<character_advantagesCreateWithoutAdvantagesInput, character_advantagesUncheckedCreateWithoutAdvantagesInput> | character_advantagesCreateWithoutAdvantagesInput[] | character_advantagesUncheckedCreateWithoutAdvantagesInput[]
    connectOrCreate?: character_advantagesCreateOrConnectWithoutAdvantagesInput | character_advantagesCreateOrConnectWithoutAdvantagesInput[]
    upsert?: character_advantagesUpsertWithWhereUniqueWithoutAdvantagesInput | character_advantagesUpsertWithWhereUniqueWithoutAdvantagesInput[]
    createMany?: character_advantagesCreateManyAdvantagesInputEnvelope
    set?: character_advantagesWhereUniqueInput | character_advantagesWhereUniqueInput[]
    disconnect?: character_advantagesWhereUniqueInput | character_advantagesWhereUniqueInput[]
    delete?: character_advantagesWhereUniqueInput | character_advantagesWhereUniqueInput[]
    connect?: character_advantagesWhereUniqueInput | character_advantagesWhereUniqueInput[]
    update?: character_advantagesUpdateWithWhereUniqueWithoutAdvantagesInput | character_advantagesUpdateWithWhereUniqueWithoutAdvantagesInput[]
    updateMany?: character_advantagesUpdateManyWithWhereWithoutAdvantagesInput | character_advantagesUpdateManyWithWhereWithoutAdvantagesInput[]
    deleteMany?: character_advantagesScalarWhereInput | character_advantagesScalarWhereInput[]
  }

  export type character_advantagesUncheckedUpdateManyWithoutAdvantagesNestedInput = {
    create?: XOR<character_advantagesCreateWithoutAdvantagesInput, character_advantagesUncheckedCreateWithoutAdvantagesInput> | character_advantagesCreateWithoutAdvantagesInput[] | character_advantagesUncheckedCreateWithoutAdvantagesInput[]
    connectOrCreate?: character_advantagesCreateOrConnectWithoutAdvantagesInput | character_advantagesCreateOrConnectWithoutAdvantagesInput[]
    upsert?: character_advantagesUpsertWithWhereUniqueWithoutAdvantagesInput | character_advantagesUpsertWithWhereUniqueWithoutAdvantagesInput[]
    createMany?: character_advantagesCreateManyAdvantagesInputEnvelope
    set?: character_advantagesWhereUniqueInput | character_advantagesWhereUniqueInput[]
    disconnect?: character_advantagesWhereUniqueInput | character_advantagesWhereUniqueInput[]
    delete?: character_advantagesWhereUniqueInput | character_advantagesWhereUniqueInput[]
    connect?: character_advantagesWhereUniqueInput | character_advantagesWhereUniqueInput[]
    update?: character_advantagesUpdateWithWhereUniqueWithoutAdvantagesInput | character_advantagesUpdateWithWhereUniqueWithoutAdvantagesInput[]
    updateMany?: character_advantagesUpdateManyWithWhereWithoutAdvantagesInput | character_advantagesUpdateManyWithWhereWithoutAdvantagesInput[]
    deleteMany?: character_advantagesScalarWhereInput | character_advantagesScalarWhereInput[]
  }

  export type character_alchemy_powersCreateNestedManyWithoutAlchemy_powersInput = {
    create?: XOR<character_alchemy_powersCreateWithoutAlchemy_powersInput, character_alchemy_powersUncheckedCreateWithoutAlchemy_powersInput> | character_alchemy_powersCreateWithoutAlchemy_powersInput[] | character_alchemy_powersUncheckedCreateWithoutAlchemy_powersInput[]
    connectOrCreate?: character_alchemy_powersCreateOrConnectWithoutAlchemy_powersInput | character_alchemy_powersCreateOrConnectWithoutAlchemy_powersInput[]
    createMany?: character_alchemy_powersCreateManyAlchemy_powersInputEnvelope
    connect?: character_alchemy_powersWhereUniqueInput | character_alchemy_powersWhereUniqueInput[]
  }

  export type character_alchemy_powersUncheckedCreateNestedManyWithoutAlchemy_powersInput = {
    create?: XOR<character_alchemy_powersCreateWithoutAlchemy_powersInput, character_alchemy_powersUncheckedCreateWithoutAlchemy_powersInput> | character_alchemy_powersCreateWithoutAlchemy_powersInput[] | character_alchemy_powersUncheckedCreateWithoutAlchemy_powersInput[]
    connectOrCreate?: character_alchemy_powersCreateOrConnectWithoutAlchemy_powersInput | character_alchemy_powersCreateOrConnectWithoutAlchemy_powersInput[]
    createMany?: character_alchemy_powersCreateManyAlchemy_powersInputEnvelope
    connect?: character_alchemy_powersWhereUniqueInput | character_alchemy_powersWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type character_alchemy_powersUpdateManyWithoutAlchemy_powersNestedInput = {
    create?: XOR<character_alchemy_powersCreateWithoutAlchemy_powersInput, character_alchemy_powersUncheckedCreateWithoutAlchemy_powersInput> | character_alchemy_powersCreateWithoutAlchemy_powersInput[] | character_alchemy_powersUncheckedCreateWithoutAlchemy_powersInput[]
    connectOrCreate?: character_alchemy_powersCreateOrConnectWithoutAlchemy_powersInput | character_alchemy_powersCreateOrConnectWithoutAlchemy_powersInput[]
    upsert?: character_alchemy_powersUpsertWithWhereUniqueWithoutAlchemy_powersInput | character_alchemy_powersUpsertWithWhereUniqueWithoutAlchemy_powersInput[]
    createMany?: character_alchemy_powersCreateManyAlchemy_powersInputEnvelope
    set?: character_alchemy_powersWhereUniqueInput | character_alchemy_powersWhereUniqueInput[]
    disconnect?: character_alchemy_powersWhereUniqueInput | character_alchemy_powersWhereUniqueInput[]
    delete?: character_alchemy_powersWhereUniqueInput | character_alchemy_powersWhereUniqueInput[]
    connect?: character_alchemy_powersWhereUniqueInput | character_alchemy_powersWhereUniqueInput[]
    update?: character_alchemy_powersUpdateWithWhereUniqueWithoutAlchemy_powersInput | character_alchemy_powersUpdateWithWhereUniqueWithoutAlchemy_powersInput[]
    updateMany?: character_alchemy_powersUpdateManyWithWhereWithoutAlchemy_powersInput | character_alchemy_powersUpdateManyWithWhereWithoutAlchemy_powersInput[]
    deleteMany?: character_alchemy_powersScalarWhereInput | character_alchemy_powersScalarWhereInput[]
  }

  export type character_alchemy_powersUncheckedUpdateManyWithoutAlchemy_powersNestedInput = {
    create?: XOR<character_alchemy_powersCreateWithoutAlchemy_powersInput, character_alchemy_powersUncheckedCreateWithoutAlchemy_powersInput> | character_alchemy_powersCreateWithoutAlchemy_powersInput[] | character_alchemy_powersUncheckedCreateWithoutAlchemy_powersInput[]
    connectOrCreate?: character_alchemy_powersCreateOrConnectWithoutAlchemy_powersInput | character_alchemy_powersCreateOrConnectWithoutAlchemy_powersInput[]
    upsert?: character_alchemy_powersUpsertWithWhereUniqueWithoutAlchemy_powersInput | character_alchemy_powersUpsertWithWhereUniqueWithoutAlchemy_powersInput[]
    createMany?: character_alchemy_powersCreateManyAlchemy_powersInputEnvelope
    set?: character_alchemy_powersWhereUniqueInput | character_alchemy_powersWhereUniqueInput[]
    disconnect?: character_alchemy_powersWhereUniqueInput | character_alchemy_powersWhereUniqueInput[]
    delete?: character_alchemy_powersWhereUniqueInput | character_alchemy_powersWhereUniqueInput[]
    connect?: character_alchemy_powersWhereUniqueInput | character_alchemy_powersWhereUniqueInput[]
    update?: character_alchemy_powersUpdateWithWhereUniqueWithoutAlchemy_powersInput | character_alchemy_powersUpdateWithWhereUniqueWithoutAlchemy_powersInput[]
    updateMany?: character_alchemy_powersUpdateManyWithWhereWithoutAlchemy_powersInput | character_alchemy_powersUpdateManyWithWhereWithoutAlchemy_powersInput[]
    deleteMany?: character_alchemy_powersScalarWhereInput | character_alchemy_powersScalarWhereInput[]
  }

  export type character_attributesCreateNestedManyWithoutAttributesInput = {
    create?: XOR<character_attributesCreateWithoutAttributesInput, character_attributesUncheckedCreateWithoutAttributesInput> | character_attributesCreateWithoutAttributesInput[] | character_attributesUncheckedCreateWithoutAttributesInput[]
    connectOrCreate?: character_attributesCreateOrConnectWithoutAttributesInput | character_attributesCreateOrConnectWithoutAttributesInput[]
    createMany?: character_attributesCreateManyAttributesInputEnvelope
    connect?: character_attributesWhereUniqueInput | character_attributesWhereUniqueInput[]
  }

  export type character_attributesUncheckedCreateNestedManyWithoutAttributesInput = {
    create?: XOR<character_attributesCreateWithoutAttributesInput, character_attributesUncheckedCreateWithoutAttributesInput> | character_attributesCreateWithoutAttributesInput[] | character_attributesUncheckedCreateWithoutAttributesInput[]
    connectOrCreate?: character_attributesCreateOrConnectWithoutAttributesInput | character_attributesCreateOrConnectWithoutAttributesInput[]
    createMany?: character_attributesCreateManyAttributesInputEnvelope
    connect?: character_attributesWhereUniqueInput | character_attributesWhereUniqueInput[]
  }

  export type EnumcategoryFieldUpdateOperationsInput = {
    set?: $Enums.category
  }

  export type character_attributesUpdateManyWithoutAttributesNestedInput = {
    create?: XOR<character_attributesCreateWithoutAttributesInput, character_attributesUncheckedCreateWithoutAttributesInput> | character_attributesCreateWithoutAttributesInput[] | character_attributesUncheckedCreateWithoutAttributesInput[]
    connectOrCreate?: character_attributesCreateOrConnectWithoutAttributesInput | character_attributesCreateOrConnectWithoutAttributesInput[]
    upsert?: character_attributesUpsertWithWhereUniqueWithoutAttributesInput | character_attributesUpsertWithWhereUniqueWithoutAttributesInput[]
    createMany?: character_attributesCreateManyAttributesInputEnvelope
    set?: character_attributesWhereUniqueInput | character_attributesWhereUniqueInput[]
    disconnect?: character_attributesWhereUniqueInput | character_attributesWhereUniqueInput[]
    delete?: character_attributesWhereUniqueInput | character_attributesWhereUniqueInput[]
    connect?: character_attributesWhereUniqueInput | character_attributesWhereUniqueInput[]
    update?: character_attributesUpdateWithWhereUniqueWithoutAttributesInput | character_attributesUpdateWithWhereUniqueWithoutAttributesInput[]
    updateMany?: character_attributesUpdateManyWithWhereWithoutAttributesInput | character_attributesUpdateManyWithWhereWithoutAttributesInput[]
    deleteMany?: character_attributesScalarWhereInput | character_attributesScalarWhereInput[]
  }

  export type character_attributesUncheckedUpdateManyWithoutAttributesNestedInput = {
    create?: XOR<character_attributesCreateWithoutAttributesInput, character_attributesUncheckedCreateWithoutAttributesInput> | character_attributesCreateWithoutAttributesInput[] | character_attributesUncheckedCreateWithoutAttributesInput[]
    connectOrCreate?: character_attributesCreateOrConnectWithoutAttributesInput | character_attributesCreateOrConnectWithoutAttributesInput[]
    upsert?: character_attributesUpsertWithWhereUniqueWithoutAttributesInput | character_attributesUpsertWithWhereUniqueWithoutAttributesInput[]
    createMany?: character_attributesCreateManyAttributesInputEnvelope
    set?: character_attributesWhereUniqueInput | character_attributesWhereUniqueInput[]
    disconnect?: character_attributesWhereUniqueInput | character_attributesWhereUniqueInput[]
    delete?: character_attributesWhereUniqueInput | character_attributesWhereUniqueInput[]
    connect?: character_attributesWhereUniqueInput | character_attributesWhereUniqueInput[]
    update?: character_attributesUpdateWithWhereUniqueWithoutAttributesInput | character_attributesUpdateWithWhereUniqueWithoutAttributesInput[]
    updateMany?: character_attributesUpdateManyWithWhereWithoutAttributesInput | character_attributesUpdateManyWithWhereWithoutAttributesInput[]
    deleteMany?: character_attributesScalarWhereInput | character_attributesScalarWhereInput[]
  }

  export type character_bloodpotenciesCreateNestedManyWithoutBlood_potencyInput = {
    create?: XOR<character_bloodpotenciesCreateWithoutBlood_potencyInput, character_bloodpotenciesUncheckedCreateWithoutBlood_potencyInput> | character_bloodpotenciesCreateWithoutBlood_potencyInput[] | character_bloodpotenciesUncheckedCreateWithoutBlood_potencyInput[]
    connectOrCreate?: character_bloodpotenciesCreateOrConnectWithoutBlood_potencyInput | character_bloodpotenciesCreateOrConnectWithoutBlood_potencyInput[]
    createMany?: character_bloodpotenciesCreateManyBlood_potencyInputEnvelope
    connect?: character_bloodpotenciesWhereUniqueInput | character_bloodpotenciesWhereUniqueInput[]
  }

  export type character_bloodpotenciesUncheckedCreateNestedManyWithoutBlood_potencyInput = {
    create?: XOR<character_bloodpotenciesCreateWithoutBlood_potencyInput, character_bloodpotenciesUncheckedCreateWithoutBlood_potencyInput> | character_bloodpotenciesCreateWithoutBlood_potencyInput[] | character_bloodpotenciesUncheckedCreateWithoutBlood_potencyInput[]
    connectOrCreate?: character_bloodpotenciesCreateOrConnectWithoutBlood_potencyInput | character_bloodpotenciesCreateOrConnectWithoutBlood_potencyInput[]
    createMany?: character_bloodpotenciesCreateManyBlood_potencyInputEnvelope
    connect?: character_bloodpotenciesWhereUniqueInput | character_bloodpotenciesWhereUniqueInput[]
  }

  export type character_bloodpotenciesUpdateManyWithoutBlood_potencyNestedInput = {
    create?: XOR<character_bloodpotenciesCreateWithoutBlood_potencyInput, character_bloodpotenciesUncheckedCreateWithoutBlood_potencyInput> | character_bloodpotenciesCreateWithoutBlood_potencyInput[] | character_bloodpotenciesUncheckedCreateWithoutBlood_potencyInput[]
    connectOrCreate?: character_bloodpotenciesCreateOrConnectWithoutBlood_potencyInput | character_bloodpotenciesCreateOrConnectWithoutBlood_potencyInput[]
    upsert?: character_bloodpotenciesUpsertWithWhereUniqueWithoutBlood_potencyInput | character_bloodpotenciesUpsertWithWhereUniqueWithoutBlood_potencyInput[]
    createMany?: character_bloodpotenciesCreateManyBlood_potencyInputEnvelope
    set?: character_bloodpotenciesWhereUniqueInput | character_bloodpotenciesWhereUniqueInput[]
    disconnect?: character_bloodpotenciesWhereUniqueInput | character_bloodpotenciesWhereUniqueInput[]
    delete?: character_bloodpotenciesWhereUniqueInput | character_bloodpotenciesWhereUniqueInput[]
    connect?: character_bloodpotenciesWhereUniqueInput | character_bloodpotenciesWhereUniqueInput[]
    update?: character_bloodpotenciesUpdateWithWhereUniqueWithoutBlood_potencyInput | character_bloodpotenciesUpdateWithWhereUniqueWithoutBlood_potencyInput[]
    updateMany?: character_bloodpotenciesUpdateManyWithWhereWithoutBlood_potencyInput | character_bloodpotenciesUpdateManyWithWhereWithoutBlood_potencyInput[]
    deleteMany?: character_bloodpotenciesScalarWhereInput | character_bloodpotenciesScalarWhereInput[]
  }

  export type character_bloodpotenciesUncheckedUpdateManyWithoutBlood_potencyNestedInput = {
    create?: XOR<character_bloodpotenciesCreateWithoutBlood_potencyInput, character_bloodpotenciesUncheckedCreateWithoutBlood_potencyInput> | character_bloodpotenciesCreateWithoutBlood_potencyInput[] | character_bloodpotenciesUncheckedCreateWithoutBlood_potencyInput[]
    connectOrCreate?: character_bloodpotenciesCreateOrConnectWithoutBlood_potencyInput | character_bloodpotenciesCreateOrConnectWithoutBlood_potencyInput[]
    upsert?: character_bloodpotenciesUpsertWithWhereUniqueWithoutBlood_potencyInput | character_bloodpotenciesUpsertWithWhereUniqueWithoutBlood_potencyInput[]
    createMany?: character_bloodpotenciesCreateManyBlood_potencyInputEnvelope
    set?: character_bloodpotenciesWhereUniqueInput | character_bloodpotenciesWhereUniqueInput[]
    disconnect?: character_bloodpotenciesWhereUniqueInput | character_bloodpotenciesWhereUniqueInput[]
    delete?: character_bloodpotenciesWhereUniqueInput | character_bloodpotenciesWhereUniqueInput[]
    connect?: character_bloodpotenciesWhereUniqueInput | character_bloodpotenciesWhereUniqueInput[]
    update?: character_bloodpotenciesUpdateWithWhereUniqueWithoutBlood_potencyInput | character_bloodpotenciesUpdateWithWhereUniqueWithoutBlood_potencyInput[]
    updateMany?: character_bloodpotenciesUpdateManyWithWhereWithoutBlood_potencyInput | character_bloodpotenciesUpdateManyWithWhereWithoutBlood_potencyInput[]
    deleteMany?: character_bloodpotenciesScalarWhereInput | character_bloodpotenciesScalarWhereInput[]
  }

  export type char_groupsCreateNestedOneWithoutOther_char_groupsInput = {
    create?: XOR<char_groupsCreateWithoutOther_char_groupsInput, char_groupsUncheckedCreateWithoutOther_char_groupsInput>
    connectOrCreate?: char_groupsCreateOrConnectWithoutOther_char_groupsInput
    connect?: char_groupsWhereUniqueInput
  }

  export type char_groupsCreateNestedManyWithoutChar_groupsInput = {
    create?: XOR<char_groupsCreateWithoutChar_groupsInput, char_groupsUncheckedCreateWithoutChar_groupsInput> | char_groupsCreateWithoutChar_groupsInput[] | char_groupsUncheckedCreateWithoutChar_groupsInput[]
    connectOrCreate?: char_groupsCreateOrConnectWithoutChar_groupsInput | char_groupsCreateOrConnectWithoutChar_groupsInput[]
    createMany?: char_groupsCreateManyChar_groupsInputEnvelope
    connect?: char_groupsWhereUniqueInput | char_groupsWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutChar_groupsInput = {
    create?: XOR<usersCreateWithoutChar_groupsInput, usersUncheckedCreateWithoutChar_groupsInput>
    connectOrCreate?: usersCreateOrConnectWithoutChar_groupsInput
    connect?: usersWhereUniqueInput
  }

  export type charactersCreateNestedManyWithoutChar_groupsInput = {
    create?: XOR<charactersCreateWithoutChar_groupsInput, charactersUncheckedCreateWithoutChar_groupsInput> | charactersCreateWithoutChar_groupsInput[] | charactersUncheckedCreateWithoutChar_groupsInput[]
    connectOrCreate?: charactersCreateOrConnectWithoutChar_groupsInput | charactersCreateOrConnectWithoutChar_groupsInput[]
    createMany?: charactersCreateManyChar_groupsInputEnvelope
    connect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
  }

  export type char_groupsUncheckedCreateNestedManyWithoutChar_groupsInput = {
    create?: XOR<char_groupsCreateWithoutChar_groupsInput, char_groupsUncheckedCreateWithoutChar_groupsInput> | char_groupsCreateWithoutChar_groupsInput[] | char_groupsUncheckedCreateWithoutChar_groupsInput[]
    connectOrCreate?: char_groupsCreateOrConnectWithoutChar_groupsInput | char_groupsCreateOrConnectWithoutChar_groupsInput[]
    createMany?: char_groupsCreateManyChar_groupsInputEnvelope
    connect?: char_groupsWhereUniqueInput | char_groupsWhereUniqueInput[]
  }

  export type charactersUncheckedCreateNestedManyWithoutChar_groupsInput = {
    create?: XOR<charactersCreateWithoutChar_groupsInput, charactersUncheckedCreateWithoutChar_groupsInput> | charactersCreateWithoutChar_groupsInput[] | charactersUncheckedCreateWithoutChar_groupsInput[]
    connectOrCreate?: charactersCreateOrConnectWithoutChar_groupsInput | charactersCreateOrConnectWithoutChar_groupsInput[]
    createMany?: charactersCreateManyChar_groupsInputEnvelope
    connect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
  }

  export type char_groupsUpdateOneWithoutOther_char_groupsNestedInput = {
    create?: XOR<char_groupsCreateWithoutOther_char_groupsInput, char_groupsUncheckedCreateWithoutOther_char_groupsInput>
    connectOrCreate?: char_groupsCreateOrConnectWithoutOther_char_groupsInput
    upsert?: char_groupsUpsertWithoutOther_char_groupsInput
    disconnect?: char_groupsWhereInput | boolean
    delete?: char_groupsWhereInput | boolean
    connect?: char_groupsWhereUniqueInput
    update?: XOR<XOR<char_groupsUpdateToOneWithWhereWithoutOther_char_groupsInput, char_groupsUpdateWithoutOther_char_groupsInput>, char_groupsUncheckedUpdateWithoutOther_char_groupsInput>
  }

  export type char_groupsUpdateManyWithoutChar_groupsNestedInput = {
    create?: XOR<char_groupsCreateWithoutChar_groupsInput, char_groupsUncheckedCreateWithoutChar_groupsInput> | char_groupsCreateWithoutChar_groupsInput[] | char_groupsUncheckedCreateWithoutChar_groupsInput[]
    connectOrCreate?: char_groupsCreateOrConnectWithoutChar_groupsInput | char_groupsCreateOrConnectWithoutChar_groupsInput[]
    upsert?: char_groupsUpsertWithWhereUniqueWithoutChar_groupsInput | char_groupsUpsertWithWhereUniqueWithoutChar_groupsInput[]
    createMany?: char_groupsCreateManyChar_groupsInputEnvelope
    set?: char_groupsWhereUniqueInput | char_groupsWhereUniqueInput[]
    disconnect?: char_groupsWhereUniqueInput | char_groupsWhereUniqueInput[]
    delete?: char_groupsWhereUniqueInput | char_groupsWhereUniqueInput[]
    connect?: char_groupsWhereUniqueInput | char_groupsWhereUniqueInput[]
    update?: char_groupsUpdateWithWhereUniqueWithoutChar_groupsInput | char_groupsUpdateWithWhereUniqueWithoutChar_groupsInput[]
    updateMany?: char_groupsUpdateManyWithWhereWithoutChar_groupsInput | char_groupsUpdateManyWithWhereWithoutChar_groupsInput[]
    deleteMany?: char_groupsScalarWhereInput | char_groupsScalarWhereInput[]
  }

  export type usersUpdateOneRequiredWithoutChar_groupsNestedInput = {
    create?: XOR<usersCreateWithoutChar_groupsInput, usersUncheckedCreateWithoutChar_groupsInput>
    connectOrCreate?: usersCreateOrConnectWithoutChar_groupsInput
    upsert?: usersUpsertWithoutChar_groupsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutChar_groupsInput, usersUpdateWithoutChar_groupsInput>, usersUncheckedUpdateWithoutChar_groupsInput>
  }

  export type charactersUpdateManyWithoutChar_groupsNestedInput = {
    create?: XOR<charactersCreateWithoutChar_groupsInput, charactersUncheckedCreateWithoutChar_groupsInput> | charactersCreateWithoutChar_groupsInput[] | charactersUncheckedCreateWithoutChar_groupsInput[]
    connectOrCreate?: charactersCreateOrConnectWithoutChar_groupsInput | charactersCreateOrConnectWithoutChar_groupsInput[]
    upsert?: charactersUpsertWithWhereUniqueWithoutChar_groupsInput | charactersUpsertWithWhereUniqueWithoutChar_groupsInput[]
    createMany?: charactersCreateManyChar_groupsInputEnvelope
    set?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    disconnect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    delete?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    connect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    update?: charactersUpdateWithWhereUniqueWithoutChar_groupsInput | charactersUpdateWithWhereUniqueWithoutChar_groupsInput[]
    updateMany?: charactersUpdateManyWithWhereWithoutChar_groupsInput | charactersUpdateManyWithWhereWithoutChar_groupsInput[]
    deleteMany?: charactersScalarWhereInput | charactersScalarWhereInput[]
  }

  export type char_groupsUncheckedUpdateManyWithoutChar_groupsNestedInput = {
    create?: XOR<char_groupsCreateWithoutChar_groupsInput, char_groupsUncheckedCreateWithoutChar_groupsInput> | char_groupsCreateWithoutChar_groupsInput[] | char_groupsUncheckedCreateWithoutChar_groupsInput[]
    connectOrCreate?: char_groupsCreateOrConnectWithoutChar_groupsInput | char_groupsCreateOrConnectWithoutChar_groupsInput[]
    upsert?: char_groupsUpsertWithWhereUniqueWithoutChar_groupsInput | char_groupsUpsertWithWhereUniqueWithoutChar_groupsInput[]
    createMany?: char_groupsCreateManyChar_groupsInputEnvelope
    set?: char_groupsWhereUniqueInput | char_groupsWhereUniqueInput[]
    disconnect?: char_groupsWhereUniqueInput | char_groupsWhereUniqueInput[]
    delete?: char_groupsWhereUniqueInput | char_groupsWhereUniqueInput[]
    connect?: char_groupsWhereUniqueInput | char_groupsWhereUniqueInput[]
    update?: char_groupsUpdateWithWhereUniqueWithoutChar_groupsInput | char_groupsUpdateWithWhereUniqueWithoutChar_groupsInput[]
    updateMany?: char_groupsUpdateManyWithWhereWithoutChar_groupsInput | char_groupsUpdateManyWithWhereWithoutChar_groupsInput[]
    deleteMany?: char_groupsScalarWhereInput | char_groupsScalarWhereInput[]
  }

  export type charactersUncheckedUpdateManyWithoutChar_groupsNestedInput = {
    create?: XOR<charactersCreateWithoutChar_groupsInput, charactersUncheckedCreateWithoutChar_groupsInput> | charactersCreateWithoutChar_groupsInput[] | charactersUncheckedCreateWithoutChar_groupsInput[]
    connectOrCreate?: charactersCreateOrConnectWithoutChar_groupsInput | charactersCreateOrConnectWithoutChar_groupsInput[]
    upsert?: charactersUpsertWithWhereUniqueWithoutChar_groupsInput | charactersUpsertWithWhereUniqueWithoutChar_groupsInput[]
    createMany?: charactersCreateManyChar_groupsInputEnvelope
    set?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    disconnect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    delete?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    connect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    update?: charactersUpdateWithWhereUniqueWithoutChar_groupsInput | charactersUpdateWithWhereUniqueWithoutChar_groupsInput[]
    updateMany?: charactersUpdateManyWithWhereWithoutChar_groupsInput | charactersUpdateManyWithWhereWithoutChar_groupsInput[]
    deleteMany?: charactersScalarWhereInput | charactersScalarWhereInput[]
  }

  export type advantagesCreateNestedOneWithoutCharacter_advantagesInput = {
    create?: XOR<advantagesCreateWithoutCharacter_advantagesInput, advantagesUncheckedCreateWithoutCharacter_advantagesInput>
    connectOrCreate?: advantagesCreateOrConnectWithoutCharacter_advantagesInput
    connect?: advantagesWhereUniqueInput
  }

  export type charactersCreateNestedOneWithoutCharacter_advantagesInput = {
    create?: XOR<charactersCreateWithoutCharacter_advantagesInput, charactersUncheckedCreateWithoutCharacter_advantagesInput>
    connectOrCreate?: charactersCreateOrConnectWithoutCharacter_advantagesInput
    connect?: charactersWhereUniqueInput
  }

  export type advantagesUpdateOneRequiredWithoutCharacter_advantagesNestedInput = {
    create?: XOR<advantagesCreateWithoutCharacter_advantagesInput, advantagesUncheckedCreateWithoutCharacter_advantagesInput>
    connectOrCreate?: advantagesCreateOrConnectWithoutCharacter_advantagesInput
    upsert?: advantagesUpsertWithoutCharacter_advantagesInput
    connect?: advantagesWhereUniqueInput
    update?: XOR<XOR<advantagesUpdateToOneWithWhereWithoutCharacter_advantagesInput, advantagesUpdateWithoutCharacter_advantagesInput>, advantagesUncheckedUpdateWithoutCharacter_advantagesInput>
  }

  export type charactersUpdateOneRequiredWithoutCharacter_advantagesNestedInput = {
    create?: XOR<charactersCreateWithoutCharacter_advantagesInput, charactersUncheckedCreateWithoutCharacter_advantagesInput>
    connectOrCreate?: charactersCreateOrConnectWithoutCharacter_advantagesInput
    upsert?: charactersUpsertWithoutCharacter_advantagesInput
    connect?: charactersWhereUniqueInput
    update?: XOR<XOR<charactersUpdateToOneWithWhereWithoutCharacter_advantagesInput, charactersUpdateWithoutCharacter_advantagesInput>, charactersUncheckedUpdateWithoutCharacter_advantagesInput>
  }

  export type alchemy_powersCreateNestedOneWithoutCharacter_alchemy_powersInput = {
    create?: XOR<alchemy_powersCreateWithoutCharacter_alchemy_powersInput, alchemy_powersUncheckedCreateWithoutCharacter_alchemy_powersInput>
    connectOrCreate?: alchemy_powersCreateOrConnectWithoutCharacter_alchemy_powersInput
    connect?: alchemy_powersWhereUniqueInput
  }

  export type charactersCreateNestedOneWithoutCharacter_alchemy_powersInput = {
    create?: XOR<charactersCreateWithoutCharacter_alchemy_powersInput, charactersUncheckedCreateWithoutCharacter_alchemy_powersInput>
    connectOrCreate?: charactersCreateOrConnectWithoutCharacter_alchemy_powersInput
    connect?: charactersWhereUniqueInput
  }

  export type alchemy_powersUpdateOneRequiredWithoutCharacter_alchemy_powersNestedInput = {
    create?: XOR<alchemy_powersCreateWithoutCharacter_alchemy_powersInput, alchemy_powersUncheckedCreateWithoutCharacter_alchemy_powersInput>
    connectOrCreate?: alchemy_powersCreateOrConnectWithoutCharacter_alchemy_powersInput
    upsert?: alchemy_powersUpsertWithoutCharacter_alchemy_powersInput
    connect?: alchemy_powersWhereUniqueInput
    update?: XOR<XOR<alchemy_powersUpdateToOneWithWhereWithoutCharacter_alchemy_powersInput, alchemy_powersUpdateWithoutCharacter_alchemy_powersInput>, alchemy_powersUncheckedUpdateWithoutCharacter_alchemy_powersInput>
  }

  export type charactersUpdateOneRequiredWithoutCharacter_alchemy_powersNestedInput = {
    create?: XOR<charactersCreateWithoutCharacter_alchemy_powersInput, charactersUncheckedCreateWithoutCharacter_alchemy_powersInput>
    connectOrCreate?: charactersCreateOrConnectWithoutCharacter_alchemy_powersInput
    upsert?: charactersUpsertWithoutCharacter_alchemy_powersInput
    connect?: charactersWhereUniqueInput
    update?: XOR<XOR<charactersUpdateToOneWithWhereWithoutCharacter_alchemy_powersInput, charactersUpdateWithoutCharacter_alchemy_powersInput>, charactersUncheckedUpdateWithoutCharacter_alchemy_powersInput>
  }

  export type attributesCreateNestedOneWithoutCharacter_attributesInput = {
    create?: XOR<attributesCreateWithoutCharacter_attributesInput, attributesUncheckedCreateWithoutCharacter_attributesInput>
    connectOrCreate?: attributesCreateOrConnectWithoutCharacter_attributesInput
    connect?: attributesWhereUniqueInput
  }

  export type charactersCreateNestedOneWithoutCharacter_attributesInput = {
    create?: XOR<charactersCreateWithoutCharacter_attributesInput, charactersUncheckedCreateWithoutCharacter_attributesInput>
    connectOrCreate?: charactersCreateOrConnectWithoutCharacter_attributesInput
    connect?: charactersWhereUniqueInput
  }

  export type attributesUpdateOneRequiredWithoutCharacter_attributesNestedInput = {
    create?: XOR<attributesCreateWithoutCharacter_attributesInput, attributesUncheckedCreateWithoutCharacter_attributesInput>
    connectOrCreate?: attributesCreateOrConnectWithoutCharacter_attributesInput
    upsert?: attributesUpsertWithoutCharacter_attributesInput
    connect?: attributesWhereUniqueInput
    update?: XOR<XOR<attributesUpdateToOneWithWhereWithoutCharacter_attributesInput, attributesUpdateWithoutCharacter_attributesInput>, attributesUncheckedUpdateWithoutCharacter_attributesInput>
  }

  export type charactersUpdateOneRequiredWithoutCharacter_attributesNestedInput = {
    create?: XOR<charactersCreateWithoutCharacter_attributesInput, charactersUncheckedCreateWithoutCharacter_attributesInput>
    connectOrCreate?: charactersCreateOrConnectWithoutCharacter_attributesInput
    upsert?: charactersUpsertWithoutCharacter_attributesInput
    connect?: charactersWhereUniqueInput
    update?: XOR<XOR<charactersUpdateToOneWithWhereWithoutCharacter_attributesInput, charactersUpdateWithoutCharacter_attributesInput>, charactersUncheckedUpdateWithoutCharacter_attributesInput>
  }

  export type blood_potencyCreateNestedOneWithoutCharacter_bloodpotenciesInput = {
    create?: XOR<blood_potencyCreateWithoutCharacter_bloodpotenciesInput, blood_potencyUncheckedCreateWithoutCharacter_bloodpotenciesInput>
    connectOrCreate?: blood_potencyCreateOrConnectWithoutCharacter_bloodpotenciesInput
    connect?: blood_potencyWhereUniqueInput
  }

  export type charactersCreateNestedOneWithoutCharacter_bloodpotenciesInput = {
    create?: XOR<charactersCreateWithoutCharacter_bloodpotenciesInput, charactersUncheckedCreateWithoutCharacter_bloodpotenciesInput>
    connectOrCreate?: charactersCreateOrConnectWithoutCharacter_bloodpotenciesInput
    connect?: charactersWhereUniqueInput
  }

  export type clan_compulsionsCreateNestedOneWithoutCharacter_bloodpotenciesInput = {
    create?: XOR<clan_compulsionsCreateWithoutCharacter_bloodpotenciesInput, clan_compulsionsUncheckedCreateWithoutCharacter_bloodpotenciesInput>
    connectOrCreate?: clan_compulsionsCreateOrConnectWithoutCharacter_bloodpotenciesInput
    connect?: clan_compulsionsWhereUniqueInput
  }

  export type clan_banesCreateNestedOneWithoutCharacter_bloodpotenciesInput = {
    create?: XOR<clan_banesCreateWithoutCharacter_bloodpotenciesInput, clan_banesUncheckedCreateWithoutCharacter_bloodpotenciesInput>
    connectOrCreate?: clan_banesCreateOrConnectWithoutCharacter_bloodpotenciesInput
    connect?: clan_banesWhereUniqueInput
  }

  export type blood_potencyUpdateOneWithoutCharacter_bloodpotenciesNestedInput = {
    create?: XOR<blood_potencyCreateWithoutCharacter_bloodpotenciesInput, blood_potencyUncheckedCreateWithoutCharacter_bloodpotenciesInput>
    connectOrCreate?: blood_potencyCreateOrConnectWithoutCharacter_bloodpotenciesInput
    upsert?: blood_potencyUpsertWithoutCharacter_bloodpotenciesInput
    disconnect?: blood_potencyWhereInput | boolean
    delete?: blood_potencyWhereInput | boolean
    connect?: blood_potencyWhereUniqueInput
    update?: XOR<XOR<blood_potencyUpdateToOneWithWhereWithoutCharacter_bloodpotenciesInput, blood_potencyUpdateWithoutCharacter_bloodpotenciesInput>, blood_potencyUncheckedUpdateWithoutCharacter_bloodpotenciesInput>
  }

  export type charactersUpdateOneRequiredWithoutCharacter_bloodpotenciesNestedInput = {
    create?: XOR<charactersCreateWithoutCharacter_bloodpotenciesInput, charactersUncheckedCreateWithoutCharacter_bloodpotenciesInput>
    connectOrCreate?: charactersCreateOrConnectWithoutCharacter_bloodpotenciesInput
    upsert?: charactersUpsertWithoutCharacter_bloodpotenciesInput
    connect?: charactersWhereUniqueInput
    update?: XOR<XOR<charactersUpdateToOneWithWhereWithoutCharacter_bloodpotenciesInput, charactersUpdateWithoutCharacter_bloodpotenciesInput>, charactersUncheckedUpdateWithoutCharacter_bloodpotenciesInput>
  }

  export type clan_compulsionsUpdateOneWithoutCharacter_bloodpotenciesNestedInput = {
    create?: XOR<clan_compulsionsCreateWithoutCharacter_bloodpotenciesInput, clan_compulsionsUncheckedCreateWithoutCharacter_bloodpotenciesInput>
    connectOrCreate?: clan_compulsionsCreateOrConnectWithoutCharacter_bloodpotenciesInput
    upsert?: clan_compulsionsUpsertWithoutCharacter_bloodpotenciesInput
    disconnect?: clan_compulsionsWhereInput | boolean
    delete?: clan_compulsionsWhereInput | boolean
    connect?: clan_compulsionsWhereUniqueInput
    update?: XOR<XOR<clan_compulsionsUpdateToOneWithWhereWithoutCharacter_bloodpotenciesInput, clan_compulsionsUpdateWithoutCharacter_bloodpotenciesInput>, clan_compulsionsUncheckedUpdateWithoutCharacter_bloodpotenciesInput>
  }

  export type clan_banesUpdateOneWithoutCharacter_bloodpotenciesNestedInput = {
    create?: XOR<clan_banesCreateWithoutCharacter_bloodpotenciesInput, clan_banesUncheckedCreateWithoutCharacter_bloodpotenciesInput>
    connectOrCreate?: clan_banesCreateOrConnectWithoutCharacter_bloodpotenciesInput
    upsert?: clan_banesUpsertWithoutCharacter_bloodpotenciesInput
    disconnect?: clan_banesWhereInput | boolean
    delete?: clan_banesWhereInput | boolean
    connect?: clan_banesWhereUniqueInput
    update?: XOR<XOR<clan_banesUpdateToOneWithWhereWithoutCharacter_bloodpotenciesInput, clan_banesUpdateWithoutCharacter_bloodpotenciesInput>, clan_banesUncheckedUpdateWithoutCharacter_bloodpotenciesInput>
  }

  export type charactersCreateNestedOneWithoutCharacter_discipline_powersInput = {
    create?: XOR<charactersCreateWithoutCharacter_discipline_powersInput, charactersUncheckedCreateWithoutCharacter_discipline_powersInput>
    connectOrCreate?: charactersCreateOrConnectWithoutCharacter_discipline_powersInput
    connect?: charactersWhereUniqueInput
  }

  export type discipline_powersCreateNestedOneWithoutCharacter_discipline_powersInput = {
    create?: XOR<discipline_powersCreateWithoutCharacter_discipline_powersInput, discipline_powersUncheckedCreateWithoutCharacter_discipline_powersInput>
    connectOrCreate?: discipline_powersCreateOrConnectWithoutCharacter_discipline_powersInput
    connect?: discipline_powersWhereUniqueInput
  }

  export type charactersUpdateOneRequiredWithoutCharacter_discipline_powersNestedInput = {
    create?: XOR<charactersCreateWithoutCharacter_discipline_powersInput, charactersUncheckedCreateWithoutCharacter_discipline_powersInput>
    connectOrCreate?: charactersCreateOrConnectWithoutCharacter_discipline_powersInput
    upsert?: charactersUpsertWithoutCharacter_discipline_powersInput
    connect?: charactersWhereUniqueInput
    update?: XOR<XOR<charactersUpdateToOneWithWhereWithoutCharacter_discipline_powersInput, charactersUpdateWithoutCharacter_discipline_powersInput>, charactersUncheckedUpdateWithoutCharacter_discipline_powersInput>
  }

  export type discipline_powersUpdateOneRequiredWithoutCharacter_discipline_powersNestedInput = {
    create?: XOR<discipline_powersCreateWithoutCharacter_discipline_powersInput, discipline_powersUncheckedCreateWithoutCharacter_discipline_powersInput>
    connectOrCreate?: discipline_powersCreateOrConnectWithoutCharacter_discipline_powersInput
    upsert?: discipline_powersUpsertWithoutCharacter_discipline_powersInput
    connect?: discipline_powersWhereUniqueInput
    update?: XOR<XOR<discipline_powersUpdateToOneWithWhereWithoutCharacter_discipline_powersInput, discipline_powersUpdateWithoutCharacter_discipline_powersInput>, discipline_powersUncheckedUpdateWithoutCharacter_discipline_powersInput>
  }

  export type charactersCreateNestedOneWithoutCharacter_disciplinesInput = {
    create?: XOR<charactersCreateWithoutCharacter_disciplinesInput, charactersUncheckedCreateWithoutCharacter_disciplinesInput>
    connectOrCreate?: charactersCreateOrConnectWithoutCharacter_disciplinesInput
    connect?: charactersWhereUniqueInput
  }

  export type disciplinesCreateNestedOneWithoutCharacter_disciplinesInput = {
    create?: XOR<disciplinesCreateWithoutCharacter_disciplinesInput, disciplinesUncheckedCreateWithoutCharacter_disciplinesInput>
    connectOrCreate?: disciplinesCreateOrConnectWithoutCharacter_disciplinesInput
    connect?: disciplinesWhereUniqueInput
  }

  export type charactersUpdateOneRequiredWithoutCharacter_disciplinesNestedInput = {
    create?: XOR<charactersCreateWithoutCharacter_disciplinesInput, charactersUncheckedCreateWithoutCharacter_disciplinesInput>
    connectOrCreate?: charactersCreateOrConnectWithoutCharacter_disciplinesInput
    upsert?: charactersUpsertWithoutCharacter_disciplinesInput
    connect?: charactersWhereUniqueInput
    update?: XOR<XOR<charactersUpdateToOneWithWhereWithoutCharacter_disciplinesInput, charactersUpdateWithoutCharacter_disciplinesInput>, charactersUncheckedUpdateWithoutCharacter_disciplinesInput>
  }

  export type disciplinesUpdateOneRequiredWithoutCharacter_disciplinesNestedInput = {
    create?: XOR<disciplinesCreateWithoutCharacter_disciplinesInput, disciplinesUncheckedCreateWithoutCharacter_disciplinesInput>
    connectOrCreate?: disciplinesCreateOrConnectWithoutCharacter_disciplinesInput
    upsert?: disciplinesUpsertWithoutCharacter_disciplinesInput
    connect?: disciplinesWhereUniqueInput
    update?: XOR<XOR<disciplinesUpdateToOneWithWhereWithoutCharacter_disciplinesInput, disciplinesUpdateWithoutCharacter_disciplinesInput>, disciplinesUncheckedUpdateWithoutCharacter_disciplinesInput>
  }

  export type charactersCreateNestedOneWithoutCharacter_healthsInput = {
    create?: XOR<charactersCreateWithoutCharacter_healthsInput, charactersUncheckedCreateWithoutCharacter_healthsInput>
    connectOrCreate?: charactersCreateOrConnectWithoutCharacter_healthsInput
    connect?: charactersWhereUniqueInput
  }

  export type charactersUpdateOneRequiredWithoutCharacter_healthsNestedInput = {
    create?: XOR<charactersCreateWithoutCharacter_healthsInput, charactersUncheckedCreateWithoutCharacter_healthsInput>
    connectOrCreate?: charactersCreateOrConnectWithoutCharacter_healthsInput
    upsert?: charactersUpsertWithoutCharacter_healthsInput
    connect?: charactersWhereUniqueInput
    update?: XOR<XOR<charactersUpdateToOneWithWhereWithoutCharacter_healthsInput, charactersUpdateWithoutCharacter_healthsInput>, charactersUncheckedUpdateWithoutCharacter_healthsInput>
  }

  export type charactersCreateNestedOneWithoutCharacter_humanityInput = {
    create?: XOR<charactersCreateWithoutCharacter_humanityInput, charactersUncheckedCreateWithoutCharacter_humanityInput>
    connectOrCreate?: charactersCreateOrConnectWithoutCharacter_humanityInput
    connect?: charactersWhereUniqueInput
  }

  export type charactersUpdateOneRequiredWithoutCharacter_humanityNestedInput = {
    create?: XOR<charactersCreateWithoutCharacter_humanityInput, charactersUncheckedCreateWithoutCharacter_humanityInput>
    connectOrCreate?: charactersCreateOrConnectWithoutCharacter_humanityInput
    upsert?: charactersUpsertWithoutCharacter_humanityInput
    connect?: charactersWhereUniqueInput
    update?: XOR<XOR<charactersUpdateToOneWithWhereWithoutCharacter_humanityInput, charactersUpdateWithoutCharacter_humanityInput>, charactersUncheckedUpdateWithoutCharacter_humanityInput>
  }

  export type charactersCreateNestedOneWithoutCharacter_profileInput = {
    create?: XOR<charactersCreateWithoutCharacter_profileInput, charactersUncheckedCreateWithoutCharacter_profileInput>
    connectOrCreate?: charactersCreateOrConnectWithoutCharacter_profileInput
    connect?: charactersWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type charactersUpdateOneRequiredWithoutCharacter_profileNestedInput = {
    create?: XOR<charactersCreateWithoutCharacter_profileInput, charactersUncheckedCreateWithoutCharacter_profileInput>
    connectOrCreate?: charactersCreateOrConnectWithoutCharacter_profileInput
    upsert?: charactersUpsertWithoutCharacter_profileInput
    connect?: charactersWhereUniqueInput
    update?: XOR<XOR<charactersUpdateToOneWithWhereWithoutCharacter_profileInput, charactersUpdateWithoutCharacter_profileInput>, charactersUncheckedUpdateWithoutCharacter_profileInput>
  }

  export type charactersCreateNestedOneWithoutCharacter_ritualsInput = {
    create?: XOR<charactersCreateWithoutCharacter_ritualsInput, charactersUncheckedCreateWithoutCharacter_ritualsInput>
    connectOrCreate?: charactersCreateOrConnectWithoutCharacter_ritualsInput
    connect?: charactersWhereUniqueInput
  }

  export type ritualsCreateNestedOneWithoutCharacter_ritualsInput = {
    create?: XOR<ritualsCreateWithoutCharacter_ritualsInput, ritualsUncheckedCreateWithoutCharacter_ritualsInput>
    connectOrCreate?: ritualsCreateOrConnectWithoutCharacter_ritualsInput
    connect?: ritualsWhereUniqueInput
  }

  export type charactersUpdateOneRequiredWithoutCharacter_ritualsNestedInput = {
    create?: XOR<charactersCreateWithoutCharacter_ritualsInput, charactersUncheckedCreateWithoutCharacter_ritualsInput>
    connectOrCreate?: charactersCreateOrConnectWithoutCharacter_ritualsInput
    upsert?: charactersUpsertWithoutCharacter_ritualsInput
    connect?: charactersWhereUniqueInput
    update?: XOR<XOR<charactersUpdateToOneWithWhereWithoutCharacter_ritualsInput, charactersUpdateWithoutCharacter_ritualsInput>, charactersUncheckedUpdateWithoutCharacter_ritualsInput>
  }

  export type ritualsUpdateOneRequiredWithoutCharacter_ritualsNestedInput = {
    create?: XOR<ritualsCreateWithoutCharacter_ritualsInput, ritualsUncheckedCreateWithoutCharacter_ritualsInput>
    connectOrCreate?: ritualsCreateOrConnectWithoutCharacter_ritualsInput
    upsert?: ritualsUpsertWithoutCharacter_ritualsInput
    connect?: ritualsWhereUniqueInput
    update?: XOR<XOR<ritualsUpdateToOneWithWhereWithoutCharacter_ritualsInput, ritualsUpdateWithoutCharacter_ritualsInput>, ritualsUncheckedUpdateWithoutCharacter_ritualsInput>
  }

  export type charactersCreateNestedOneWithoutCharacter_skillsInput = {
    create?: XOR<charactersCreateWithoutCharacter_skillsInput, charactersUncheckedCreateWithoutCharacter_skillsInput>
    connectOrCreate?: charactersCreateOrConnectWithoutCharacter_skillsInput
    connect?: charactersWhereUniqueInput
  }

  export type skillsCreateNestedOneWithoutCharacter_skillsInput = {
    create?: XOR<skillsCreateWithoutCharacter_skillsInput, skillsUncheckedCreateWithoutCharacter_skillsInput>
    connectOrCreate?: skillsCreateOrConnectWithoutCharacter_skillsInput
    connect?: skillsWhereUniqueInput
  }

  export type charactersUpdateOneRequiredWithoutCharacter_skillsNestedInput = {
    create?: XOR<charactersCreateWithoutCharacter_skillsInput, charactersUncheckedCreateWithoutCharacter_skillsInput>
    connectOrCreate?: charactersCreateOrConnectWithoutCharacter_skillsInput
    upsert?: charactersUpsertWithoutCharacter_skillsInput
    connect?: charactersWhereUniqueInput
    update?: XOR<XOR<charactersUpdateToOneWithWhereWithoutCharacter_skillsInput, charactersUpdateWithoutCharacter_skillsInput>, charactersUncheckedUpdateWithoutCharacter_skillsInput>
  }

  export type skillsUpdateOneRequiredWithoutCharacter_skillsNestedInput = {
    create?: XOR<skillsCreateWithoutCharacter_skillsInput, skillsUncheckedCreateWithoutCharacter_skillsInput>
    connectOrCreate?: skillsCreateOrConnectWithoutCharacter_skillsInput
    upsert?: skillsUpsertWithoutCharacter_skillsInput
    connect?: skillsWhereUniqueInput
    update?: XOR<XOR<skillsUpdateToOneWithWhereWithoutCharacter_skillsInput, skillsUpdateWithoutCharacter_skillsInput>, skillsUncheckedUpdateWithoutCharacter_skillsInput>
  }

  export type charactersCreateNestedOneWithoutCharacter_specialtiesInput = {
    create?: XOR<charactersCreateWithoutCharacter_specialtiesInput, charactersUncheckedCreateWithoutCharacter_specialtiesInput>
    connectOrCreate?: charactersCreateOrConnectWithoutCharacter_specialtiesInput
    connect?: charactersWhereUniqueInput
  }

  export type skillsCreateNestedOneWithoutCharacter_specialtiesInput = {
    create?: XOR<skillsCreateWithoutCharacter_specialtiesInput, skillsUncheckedCreateWithoutCharacter_specialtiesInput>
    connectOrCreate?: skillsCreateOrConnectWithoutCharacter_specialtiesInput
    connect?: skillsWhereUniqueInput
  }

  export type charactersUpdateOneRequiredWithoutCharacter_specialtiesNestedInput = {
    create?: XOR<charactersCreateWithoutCharacter_specialtiesInput, charactersUncheckedCreateWithoutCharacter_specialtiesInput>
    connectOrCreate?: charactersCreateOrConnectWithoutCharacter_specialtiesInput
    upsert?: charactersUpsertWithoutCharacter_specialtiesInput
    connect?: charactersWhereUniqueInput
    update?: XOR<XOR<charactersUpdateToOneWithWhereWithoutCharacter_specialtiesInput, charactersUpdateWithoutCharacter_specialtiesInput>, charactersUncheckedUpdateWithoutCharacter_specialtiesInput>
  }

  export type skillsUpdateOneRequiredWithoutCharacter_specialtiesNestedInput = {
    create?: XOR<skillsCreateWithoutCharacter_specialtiesInput, skillsUncheckedCreateWithoutCharacter_specialtiesInput>
    connectOrCreate?: skillsCreateOrConnectWithoutCharacter_specialtiesInput
    upsert?: skillsUpsertWithoutCharacter_specialtiesInput
    connect?: skillsWhereUniqueInput
    update?: XOR<XOR<skillsUpdateToOneWithWhereWithoutCharacter_specialtiesInput, skillsUpdateWithoutCharacter_specialtiesInput>, skillsUncheckedUpdateWithoutCharacter_specialtiesInput>
  }

  export type charactersCreateNestedOneWithoutCharacter_willpowersInput = {
    create?: XOR<charactersCreateWithoutCharacter_willpowersInput, charactersUncheckedCreateWithoutCharacter_willpowersInput>
    connectOrCreate?: charactersCreateOrConnectWithoutCharacter_willpowersInput
    connect?: charactersWhereUniqueInput
  }

  export type charactersUpdateOneRequiredWithoutCharacter_willpowersNestedInput = {
    create?: XOR<charactersCreateWithoutCharacter_willpowersInput, charactersUncheckedCreateWithoutCharacter_willpowersInput>
    connectOrCreate?: charactersCreateOrConnectWithoutCharacter_willpowersInput
    upsert?: charactersUpsertWithoutCharacter_willpowersInput
    connect?: charactersWhereUniqueInput
    update?: XOR<XOR<charactersUpdateToOneWithWhereWithoutCharacter_willpowersInput, charactersUpdateWithoutCharacter_willpowersInput>, charactersUncheckedUpdateWithoutCharacter_willpowersInput>
  }

  export type character_advantagesCreateNestedManyWithoutCharactersInput = {
    create?: XOR<character_advantagesCreateWithoutCharactersInput, character_advantagesUncheckedCreateWithoutCharactersInput> | character_advantagesCreateWithoutCharactersInput[] | character_advantagesUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_advantagesCreateOrConnectWithoutCharactersInput | character_advantagesCreateOrConnectWithoutCharactersInput[]
    createMany?: character_advantagesCreateManyCharactersInputEnvelope
    connect?: character_advantagesWhereUniqueInput | character_advantagesWhereUniqueInput[]
  }

  export type character_alchemy_powersCreateNestedManyWithoutCharactersInput = {
    create?: XOR<character_alchemy_powersCreateWithoutCharactersInput, character_alchemy_powersUncheckedCreateWithoutCharactersInput> | character_alchemy_powersCreateWithoutCharactersInput[] | character_alchemy_powersUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_alchemy_powersCreateOrConnectWithoutCharactersInput | character_alchemy_powersCreateOrConnectWithoutCharactersInput[]
    createMany?: character_alchemy_powersCreateManyCharactersInputEnvelope
    connect?: character_alchemy_powersWhereUniqueInput | character_alchemy_powersWhereUniqueInput[]
  }

  export type character_attributesCreateNestedManyWithoutCharactersInput = {
    create?: XOR<character_attributesCreateWithoutCharactersInput, character_attributesUncheckedCreateWithoutCharactersInput> | character_attributesCreateWithoutCharactersInput[] | character_attributesUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_attributesCreateOrConnectWithoutCharactersInput | character_attributesCreateOrConnectWithoutCharactersInput[]
    createMany?: character_attributesCreateManyCharactersInputEnvelope
    connect?: character_attributesWhereUniqueInput | character_attributesWhereUniqueInput[]
  }

  export type character_bloodpotenciesCreateNestedManyWithoutCharactersInput = {
    create?: XOR<character_bloodpotenciesCreateWithoutCharactersInput, character_bloodpotenciesUncheckedCreateWithoutCharactersInput> | character_bloodpotenciesCreateWithoutCharactersInput[] | character_bloodpotenciesUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_bloodpotenciesCreateOrConnectWithoutCharactersInput | character_bloodpotenciesCreateOrConnectWithoutCharactersInput[]
    createMany?: character_bloodpotenciesCreateManyCharactersInputEnvelope
    connect?: character_bloodpotenciesWhereUniqueInput | character_bloodpotenciesWhereUniqueInput[]
  }

  export type character_discipline_powersCreateNestedManyWithoutCharactersInput = {
    create?: XOR<character_discipline_powersCreateWithoutCharactersInput, character_discipline_powersUncheckedCreateWithoutCharactersInput> | character_discipline_powersCreateWithoutCharactersInput[] | character_discipline_powersUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_discipline_powersCreateOrConnectWithoutCharactersInput | character_discipline_powersCreateOrConnectWithoutCharactersInput[]
    createMany?: character_discipline_powersCreateManyCharactersInputEnvelope
    connect?: character_discipline_powersWhereUniqueInput | character_discipline_powersWhereUniqueInput[]
  }

  export type character_disciplinesCreateNestedManyWithoutCharactersInput = {
    create?: XOR<character_disciplinesCreateWithoutCharactersInput, character_disciplinesUncheckedCreateWithoutCharactersInput> | character_disciplinesCreateWithoutCharactersInput[] | character_disciplinesUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_disciplinesCreateOrConnectWithoutCharactersInput | character_disciplinesCreateOrConnectWithoutCharactersInput[]
    createMany?: character_disciplinesCreateManyCharactersInputEnvelope
    connect?: character_disciplinesWhereUniqueInput | character_disciplinesWhereUniqueInput[]
  }

  export type character_healthsCreateNestedManyWithoutCharactersInput = {
    create?: XOR<character_healthsCreateWithoutCharactersInput, character_healthsUncheckedCreateWithoutCharactersInput> | character_healthsCreateWithoutCharactersInput[] | character_healthsUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_healthsCreateOrConnectWithoutCharactersInput | character_healthsCreateOrConnectWithoutCharactersInput[]
    createMany?: character_healthsCreateManyCharactersInputEnvelope
    connect?: character_healthsWhereUniqueInput | character_healthsWhereUniqueInput[]
  }

  export type character_humanityCreateNestedManyWithoutCharactersInput = {
    create?: XOR<character_humanityCreateWithoutCharactersInput, character_humanityUncheckedCreateWithoutCharactersInput> | character_humanityCreateWithoutCharactersInput[] | character_humanityUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_humanityCreateOrConnectWithoutCharactersInput | character_humanityCreateOrConnectWithoutCharactersInput[]
    createMany?: character_humanityCreateManyCharactersInputEnvelope
    connect?: character_humanityWhereUniqueInput | character_humanityWhereUniqueInput[]
  }

  export type character_profileCreateNestedManyWithoutCharactersInput = {
    create?: XOR<character_profileCreateWithoutCharactersInput, character_profileUncheckedCreateWithoutCharactersInput> | character_profileCreateWithoutCharactersInput[] | character_profileUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_profileCreateOrConnectWithoutCharactersInput | character_profileCreateOrConnectWithoutCharactersInput[]
    createMany?: character_profileCreateManyCharactersInputEnvelope
    connect?: character_profileWhereUniqueInput | character_profileWhereUniqueInput[]
  }

  export type character_ritualsCreateNestedManyWithoutCharactersInput = {
    create?: XOR<character_ritualsCreateWithoutCharactersInput, character_ritualsUncheckedCreateWithoutCharactersInput> | character_ritualsCreateWithoutCharactersInput[] | character_ritualsUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_ritualsCreateOrConnectWithoutCharactersInput | character_ritualsCreateOrConnectWithoutCharactersInput[]
    createMany?: character_ritualsCreateManyCharactersInputEnvelope
    connect?: character_ritualsWhereUniqueInput | character_ritualsWhereUniqueInput[]
  }

  export type character_skillsCreateNestedManyWithoutCharactersInput = {
    create?: XOR<character_skillsCreateWithoutCharactersInput, character_skillsUncheckedCreateWithoutCharactersInput> | character_skillsCreateWithoutCharactersInput[] | character_skillsUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_skillsCreateOrConnectWithoutCharactersInput | character_skillsCreateOrConnectWithoutCharactersInput[]
    createMany?: character_skillsCreateManyCharactersInputEnvelope
    connect?: character_skillsWhereUniqueInput | character_skillsWhereUniqueInput[]
  }

  export type character_specialtiesCreateNestedManyWithoutCharactersInput = {
    create?: XOR<character_specialtiesCreateWithoutCharactersInput, character_specialtiesUncheckedCreateWithoutCharactersInput> | character_specialtiesCreateWithoutCharactersInput[] | character_specialtiesUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_specialtiesCreateOrConnectWithoutCharactersInput | character_specialtiesCreateOrConnectWithoutCharactersInput[]
    createMany?: character_specialtiesCreateManyCharactersInputEnvelope
    connect?: character_specialtiesWhereUniqueInput | character_specialtiesWhereUniqueInput[]
  }

  export type character_willpowersCreateNestedManyWithoutCharactersInput = {
    create?: XOR<character_willpowersCreateWithoutCharactersInput, character_willpowersUncheckedCreateWithoutCharactersInput> | character_willpowersCreateWithoutCharactersInput[] | character_willpowersUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_willpowersCreateOrConnectWithoutCharactersInput | character_willpowersCreateOrConnectWithoutCharactersInput[]
    createMany?: character_willpowersCreateManyCharactersInputEnvelope
    connect?: character_willpowersWhereUniqueInput | character_willpowersWhereUniqueInput[]
  }

  export type chroniclesCreateNestedOneWithoutCharactersInput = {
    create?: XOR<chroniclesCreateWithoutCharactersInput, chroniclesUncheckedCreateWithoutCharactersInput>
    connectOrCreate?: chroniclesCreateOrConnectWithoutCharactersInput
    connect?: chroniclesWhereUniqueInput
  }

  export type clan_banesCreateNestedOneWithoutCharactersInput = {
    create?: XOR<clan_banesCreateWithoutCharactersInput, clan_banesUncheckedCreateWithoutCharactersInput>
    connectOrCreate?: clan_banesCreateOrConnectWithoutCharactersInput
    connect?: clan_banesWhereUniqueInput
  }

  export type clan_compulsionsCreateNestedOneWithoutCharactersInput = {
    create?: XOR<clan_compulsionsCreateWithoutCharactersInput, clan_compulsionsUncheckedCreateWithoutCharactersInput>
    connectOrCreate?: clan_compulsionsCreateOrConnectWithoutCharactersInput
    connect?: clan_compulsionsWhereUniqueInput
  }

  export type clansCreateNestedOneWithoutCharactersInput = {
    create?: XOR<clansCreateWithoutCharactersInput, clansUncheckedCreateWithoutCharactersInput>
    connectOrCreate?: clansCreateOrConnectWithoutCharactersInput
    connect?: clansWhereUniqueInput
  }

  export type char_groupsCreateNestedOneWithoutCharactersInput = {
    create?: XOR<char_groupsCreateWithoutCharactersInput, char_groupsUncheckedCreateWithoutCharactersInput>
    connectOrCreate?: char_groupsCreateOrConnectWithoutCharactersInput
    connect?: char_groupsWhereUniqueInput
  }

  export type predator_typesCreateNestedOneWithoutCharactersInput = {
    create?: XOR<predator_typesCreateWithoutCharactersInput, predator_typesUncheckedCreateWithoutCharactersInput>
    connectOrCreate?: predator_typesCreateOrConnectWithoutCharactersInput
    connect?: predator_typesWhereUniqueInput
  }

  export type sectsCreateNestedOneWithoutCharactersInput = {
    create?: XOR<sectsCreateWithoutCharactersInput, sectsUncheckedCreateWithoutCharactersInput>
    connectOrCreate?: sectsCreateOrConnectWithoutCharactersInput
    connect?: sectsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutCharactersInput = {
    create?: XOR<usersCreateWithoutCharactersInput, usersUncheckedCreateWithoutCharactersInput>
    connectOrCreate?: usersCreateOrConnectWithoutCharactersInput
    connect?: usersWhereUniqueInput
  }

  export type exp_logsCreateNestedManyWithoutCharactersInput = {
    create?: XOR<exp_logsCreateWithoutCharactersInput, exp_logsUncheckedCreateWithoutCharactersInput> | exp_logsCreateWithoutCharactersInput[] | exp_logsUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: exp_logsCreateOrConnectWithoutCharactersInput | exp_logsCreateOrConnectWithoutCharactersInput[]
    createMany?: exp_logsCreateManyCharactersInputEnvelope
    connect?: exp_logsWhereUniqueInput | exp_logsWhereUniqueInput[]
  }

  export type character_advantagesUncheckedCreateNestedManyWithoutCharactersInput = {
    create?: XOR<character_advantagesCreateWithoutCharactersInput, character_advantagesUncheckedCreateWithoutCharactersInput> | character_advantagesCreateWithoutCharactersInput[] | character_advantagesUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_advantagesCreateOrConnectWithoutCharactersInput | character_advantagesCreateOrConnectWithoutCharactersInput[]
    createMany?: character_advantagesCreateManyCharactersInputEnvelope
    connect?: character_advantagesWhereUniqueInput | character_advantagesWhereUniqueInput[]
  }

  export type character_alchemy_powersUncheckedCreateNestedManyWithoutCharactersInput = {
    create?: XOR<character_alchemy_powersCreateWithoutCharactersInput, character_alchemy_powersUncheckedCreateWithoutCharactersInput> | character_alchemy_powersCreateWithoutCharactersInput[] | character_alchemy_powersUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_alchemy_powersCreateOrConnectWithoutCharactersInput | character_alchemy_powersCreateOrConnectWithoutCharactersInput[]
    createMany?: character_alchemy_powersCreateManyCharactersInputEnvelope
    connect?: character_alchemy_powersWhereUniqueInput | character_alchemy_powersWhereUniqueInput[]
  }

  export type character_attributesUncheckedCreateNestedManyWithoutCharactersInput = {
    create?: XOR<character_attributesCreateWithoutCharactersInput, character_attributesUncheckedCreateWithoutCharactersInput> | character_attributesCreateWithoutCharactersInput[] | character_attributesUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_attributesCreateOrConnectWithoutCharactersInput | character_attributesCreateOrConnectWithoutCharactersInput[]
    createMany?: character_attributesCreateManyCharactersInputEnvelope
    connect?: character_attributesWhereUniqueInput | character_attributesWhereUniqueInput[]
  }

  export type character_bloodpotenciesUncheckedCreateNestedManyWithoutCharactersInput = {
    create?: XOR<character_bloodpotenciesCreateWithoutCharactersInput, character_bloodpotenciesUncheckedCreateWithoutCharactersInput> | character_bloodpotenciesCreateWithoutCharactersInput[] | character_bloodpotenciesUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_bloodpotenciesCreateOrConnectWithoutCharactersInput | character_bloodpotenciesCreateOrConnectWithoutCharactersInput[]
    createMany?: character_bloodpotenciesCreateManyCharactersInputEnvelope
    connect?: character_bloodpotenciesWhereUniqueInput | character_bloodpotenciesWhereUniqueInput[]
  }

  export type character_discipline_powersUncheckedCreateNestedManyWithoutCharactersInput = {
    create?: XOR<character_discipline_powersCreateWithoutCharactersInput, character_discipline_powersUncheckedCreateWithoutCharactersInput> | character_discipline_powersCreateWithoutCharactersInput[] | character_discipline_powersUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_discipline_powersCreateOrConnectWithoutCharactersInput | character_discipline_powersCreateOrConnectWithoutCharactersInput[]
    createMany?: character_discipline_powersCreateManyCharactersInputEnvelope
    connect?: character_discipline_powersWhereUniqueInput | character_discipline_powersWhereUniqueInput[]
  }

  export type character_disciplinesUncheckedCreateNestedManyWithoutCharactersInput = {
    create?: XOR<character_disciplinesCreateWithoutCharactersInput, character_disciplinesUncheckedCreateWithoutCharactersInput> | character_disciplinesCreateWithoutCharactersInput[] | character_disciplinesUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_disciplinesCreateOrConnectWithoutCharactersInput | character_disciplinesCreateOrConnectWithoutCharactersInput[]
    createMany?: character_disciplinesCreateManyCharactersInputEnvelope
    connect?: character_disciplinesWhereUniqueInput | character_disciplinesWhereUniqueInput[]
  }

  export type character_healthsUncheckedCreateNestedManyWithoutCharactersInput = {
    create?: XOR<character_healthsCreateWithoutCharactersInput, character_healthsUncheckedCreateWithoutCharactersInput> | character_healthsCreateWithoutCharactersInput[] | character_healthsUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_healthsCreateOrConnectWithoutCharactersInput | character_healthsCreateOrConnectWithoutCharactersInput[]
    createMany?: character_healthsCreateManyCharactersInputEnvelope
    connect?: character_healthsWhereUniqueInput | character_healthsWhereUniqueInput[]
  }

  export type character_humanityUncheckedCreateNestedManyWithoutCharactersInput = {
    create?: XOR<character_humanityCreateWithoutCharactersInput, character_humanityUncheckedCreateWithoutCharactersInput> | character_humanityCreateWithoutCharactersInput[] | character_humanityUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_humanityCreateOrConnectWithoutCharactersInput | character_humanityCreateOrConnectWithoutCharactersInput[]
    createMany?: character_humanityCreateManyCharactersInputEnvelope
    connect?: character_humanityWhereUniqueInput | character_humanityWhereUniqueInput[]
  }

  export type character_profileUncheckedCreateNestedManyWithoutCharactersInput = {
    create?: XOR<character_profileCreateWithoutCharactersInput, character_profileUncheckedCreateWithoutCharactersInput> | character_profileCreateWithoutCharactersInput[] | character_profileUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_profileCreateOrConnectWithoutCharactersInput | character_profileCreateOrConnectWithoutCharactersInput[]
    createMany?: character_profileCreateManyCharactersInputEnvelope
    connect?: character_profileWhereUniqueInput | character_profileWhereUniqueInput[]
  }

  export type character_ritualsUncheckedCreateNestedManyWithoutCharactersInput = {
    create?: XOR<character_ritualsCreateWithoutCharactersInput, character_ritualsUncheckedCreateWithoutCharactersInput> | character_ritualsCreateWithoutCharactersInput[] | character_ritualsUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_ritualsCreateOrConnectWithoutCharactersInput | character_ritualsCreateOrConnectWithoutCharactersInput[]
    createMany?: character_ritualsCreateManyCharactersInputEnvelope
    connect?: character_ritualsWhereUniqueInput | character_ritualsWhereUniqueInput[]
  }

  export type character_skillsUncheckedCreateNestedManyWithoutCharactersInput = {
    create?: XOR<character_skillsCreateWithoutCharactersInput, character_skillsUncheckedCreateWithoutCharactersInput> | character_skillsCreateWithoutCharactersInput[] | character_skillsUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_skillsCreateOrConnectWithoutCharactersInput | character_skillsCreateOrConnectWithoutCharactersInput[]
    createMany?: character_skillsCreateManyCharactersInputEnvelope
    connect?: character_skillsWhereUniqueInput | character_skillsWhereUniqueInput[]
  }

  export type character_specialtiesUncheckedCreateNestedManyWithoutCharactersInput = {
    create?: XOR<character_specialtiesCreateWithoutCharactersInput, character_specialtiesUncheckedCreateWithoutCharactersInput> | character_specialtiesCreateWithoutCharactersInput[] | character_specialtiesUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_specialtiesCreateOrConnectWithoutCharactersInput | character_specialtiesCreateOrConnectWithoutCharactersInput[]
    createMany?: character_specialtiesCreateManyCharactersInputEnvelope
    connect?: character_specialtiesWhereUniqueInput | character_specialtiesWhereUniqueInput[]
  }

  export type character_willpowersUncheckedCreateNestedManyWithoutCharactersInput = {
    create?: XOR<character_willpowersCreateWithoutCharactersInput, character_willpowersUncheckedCreateWithoutCharactersInput> | character_willpowersCreateWithoutCharactersInput[] | character_willpowersUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_willpowersCreateOrConnectWithoutCharactersInput | character_willpowersCreateOrConnectWithoutCharactersInput[]
    createMany?: character_willpowersCreateManyCharactersInputEnvelope
    connect?: character_willpowersWhereUniqueInput | character_willpowersWhereUniqueInput[]
  }

  export type exp_logsUncheckedCreateNestedManyWithoutCharactersInput = {
    create?: XOR<exp_logsCreateWithoutCharactersInput, exp_logsUncheckedCreateWithoutCharactersInput> | exp_logsCreateWithoutCharactersInput[] | exp_logsUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: exp_logsCreateOrConnectWithoutCharactersInput | exp_logsCreateOrConnectWithoutCharactersInput[]
    createMany?: exp_logsCreateManyCharactersInputEnvelope
    connect?: exp_logsWhereUniqueInput | exp_logsWhereUniqueInput[]
  }

  export type EnumEntityFieldUpdateOperationsInput = {
    set?: $Enums.Entity
  }

  export type character_advantagesUpdateManyWithoutCharactersNestedInput = {
    create?: XOR<character_advantagesCreateWithoutCharactersInput, character_advantagesUncheckedCreateWithoutCharactersInput> | character_advantagesCreateWithoutCharactersInput[] | character_advantagesUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_advantagesCreateOrConnectWithoutCharactersInput | character_advantagesCreateOrConnectWithoutCharactersInput[]
    upsert?: character_advantagesUpsertWithWhereUniqueWithoutCharactersInput | character_advantagesUpsertWithWhereUniqueWithoutCharactersInput[]
    createMany?: character_advantagesCreateManyCharactersInputEnvelope
    set?: character_advantagesWhereUniqueInput | character_advantagesWhereUniqueInput[]
    disconnect?: character_advantagesWhereUniqueInput | character_advantagesWhereUniqueInput[]
    delete?: character_advantagesWhereUniqueInput | character_advantagesWhereUniqueInput[]
    connect?: character_advantagesWhereUniqueInput | character_advantagesWhereUniqueInput[]
    update?: character_advantagesUpdateWithWhereUniqueWithoutCharactersInput | character_advantagesUpdateWithWhereUniqueWithoutCharactersInput[]
    updateMany?: character_advantagesUpdateManyWithWhereWithoutCharactersInput | character_advantagesUpdateManyWithWhereWithoutCharactersInput[]
    deleteMany?: character_advantagesScalarWhereInput | character_advantagesScalarWhereInput[]
  }

  export type character_alchemy_powersUpdateManyWithoutCharactersNestedInput = {
    create?: XOR<character_alchemy_powersCreateWithoutCharactersInput, character_alchemy_powersUncheckedCreateWithoutCharactersInput> | character_alchemy_powersCreateWithoutCharactersInput[] | character_alchemy_powersUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_alchemy_powersCreateOrConnectWithoutCharactersInput | character_alchemy_powersCreateOrConnectWithoutCharactersInput[]
    upsert?: character_alchemy_powersUpsertWithWhereUniqueWithoutCharactersInput | character_alchemy_powersUpsertWithWhereUniqueWithoutCharactersInput[]
    createMany?: character_alchemy_powersCreateManyCharactersInputEnvelope
    set?: character_alchemy_powersWhereUniqueInput | character_alchemy_powersWhereUniqueInput[]
    disconnect?: character_alchemy_powersWhereUniqueInput | character_alchemy_powersWhereUniqueInput[]
    delete?: character_alchemy_powersWhereUniqueInput | character_alchemy_powersWhereUniqueInput[]
    connect?: character_alchemy_powersWhereUniqueInput | character_alchemy_powersWhereUniqueInput[]
    update?: character_alchemy_powersUpdateWithWhereUniqueWithoutCharactersInput | character_alchemy_powersUpdateWithWhereUniqueWithoutCharactersInput[]
    updateMany?: character_alchemy_powersUpdateManyWithWhereWithoutCharactersInput | character_alchemy_powersUpdateManyWithWhereWithoutCharactersInput[]
    deleteMany?: character_alchemy_powersScalarWhereInput | character_alchemy_powersScalarWhereInput[]
  }

  export type character_attributesUpdateManyWithoutCharactersNestedInput = {
    create?: XOR<character_attributesCreateWithoutCharactersInput, character_attributesUncheckedCreateWithoutCharactersInput> | character_attributesCreateWithoutCharactersInput[] | character_attributesUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_attributesCreateOrConnectWithoutCharactersInput | character_attributesCreateOrConnectWithoutCharactersInput[]
    upsert?: character_attributesUpsertWithWhereUniqueWithoutCharactersInput | character_attributesUpsertWithWhereUniqueWithoutCharactersInput[]
    createMany?: character_attributesCreateManyCharactersInputEnvelope
    set?: character_attributesWhereUniqueInput | character_attributesWhereUniqueInput[]
    disconnect?: character_attributesWhereUniqueInput | character_attributesWhereUniqueInput[]
    delete?: character_attributesWhereUniqueInput | character_attributesWhereUniqueInput[]
    connect?: character_attributesWhereUniqueInput | character_attributesWhereUniqueInput[]
    update?: character_attributesUpdateWithWhereUniqueWithoutCharactersInput | character_attributesUpdateWithWhereUniqueWithoutCharactersInput[]
    updateMany?: character_attributesUpdateManyWithWhereWithoutCharactersInput | character_attributesUpdateManyWithWhereWithoutCharactersInput[]
    deleteMany?: character_attributesScalarWhereInput | character_attributesScalarWhereInput[]
  }

  export type character_bloodpotenciesUpdateManyWithoutCharactersNestedInput = {
    create?: XOR<character_bloodpotenciesCreateWithoutCharactersInput, character_bloodpotenciesUncheckedCreateWithoutCharactersInput> | character_bloodpotenciesCreateWithoutCharactersInput[] | character_bloodpotenciesUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_bloodpotenciesCreateOrConnectWithoutCharactersInput | character_bloodpotenciesCreateOrConnectWithoutCharactersInput[]
    upsert?: character_bloodpotenciesUpsertWithWhereUniqueWithoutCharactersInput | character_bloodpotenciesUpsertWithWhereUniqueWithoutCharactersInput[]
    createMany?: character_bloodpotenciesCreateManyCharactersInputEnvelope
    set?: character_bloodpotenciesWhereUniqueInput | character_bloodpotenciesWhereUniqueInput[]
    disconnect?: character_bloodpotenciesWhereUniqueInput | character_bloodpotenciesWhereUniqueInput[]
    delete?: character_bloodpotenciesWhereUniqueInput | character_bloodpotenciesWhereUniqueInput[]
    connect?: character_bloodpotenciesWhereUniqueInput | character_bloodpotenciesWhereUniqueInput[]
    update?: character_bloodpotenciesUpdateWithWhereUniqueWithoutCharactersInput | character_bloodpotenciesUpdateWithWhereUniqueWithoutCharactersInput[]
    updateMany?: character_bloodpotenciesUpdateManyWithWhereWithoutCharactersInput | character_bloodpotenciesUpdateManyWithWhereWithoutCharactersInput[]
    deleteMany?: character_bloodpotenciesScalarWhereInput | character_bloodpotenciesScalarWhereInput[]
  }

  export type character_discipline_powersUpdateManyWithoutCharactersNestedInput = {
    create?: XOR<character_discipline_powersCreateWithoutCharactersInput, character_discipline_powersUncheckedCreateWithoutCharactersInput> | character_discipline_powersCreateWithoutCharactersInput[] | character_discipline_powersUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_discipline_powersCreateOrConnectWithoutCharactersInput | character_discipline_powersCreateOrConnectWithoutCharactersInput[]
    upsert?: character_discipline_powersUpsertWithWhereUniqueWithoutCharactersInput | character_discipline_powersUpsertWithWhereUniqueWithoutCharactersInput[]
    createMany?: character_discipline_powersCreateManyCharactersInputEnvelope
    set?: character_discipline_powersWhereUniqueInput | character_discipline_powersWhereUniqueInput[]
    disconnect?: character_discipline_powersWhereUniqueInput | character_discipline_powersWhereUniqueInput[]
    delete?: character_discipline_powersWhereUniqueInput | character_discipline_powersWhereUniqueInput[]
    connect?: character_discipline_powersWhereUniqueInput | character_discipline_powersWhereUniqueInput[]
    update?: character_discipline_powersUpdateWithWhereUniqueWithoutCharactersInput | character_discipline_powersUpdateWithWhereUniqueWithoutCharactersInput[]
    updateMany?: character_discipline_powersUpdateManyWithWhereWithoutCharactersInput | character_discipline_powersUpdateManyWithWhereWithoutCharactersInput[]
    deleteMany?: character_discipline_powersScalarWhereInput | character_discipline_powersScalarWhereInput[]
  }

  export type character_disciplinesUpdateManyWithoutCharactersNestedInput = {
    create?: XOR<character_disciplinesCreateWithoutCharactersInput, character_disciplinesUncheckedCreateWithoutCharactersInput> | character_disciplinesCreateWithoutCharactersInput[] | character_disciplinesUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_disciplinesCreateOrConnectWithoutCharactersInput | character_disciplinesCreateOrConnectWithoutCharactersInput[]
    upsert?: character_disciplinesUpsertWithWhereUniqueWithoutCharactersInput | character_disciplinesUpsertWithWhereUniqueWithoutCharactersInput[]
    createMany?: character_disciplinesCreateManyCharactersInputEnvelope
    set?: character_disciplinesWhereUniqueInput | character_disciplinesWhereUniqueInput[]
    disconnect?: character_disciplinesWhereUniqueInput | character_disciplinesWhereUniqueInput[]
    delete?: character_disciplinesWhereUniqueInput | character_disciplinesWhereUniqueInput[]
    connect?: character_disciplinesWhereUniqueInput | character_disciplinesWhereUniqueInput[]
    update?: character_disciplinesUpdateWithWhereUniqueWithoutCharactersInput | character_disciplinesUpdateWithWhereUniqueWithoutCharactersInput[]
    updateMany?: character_disciplinesUpdateManyWithWhereWithoutCharactersInput | character_disciplinesUpdateManyWithWhereWithoutCharactersInput[]
    deleteMany?: character_disciplinesScalarWhereInput | character_disciplinesScalarWhereInput[]
  }

  export type character_healthsUpdateManyWithoutCharactersNestedInput = {
    create?: XOR<character_healthsCreateWithoutCharactersInput, character_healthsUncheckedCreateWithoutCharactersInput> | character_healthsCreateWithoutCharactersInput[] | character_healthsUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_healthsCreateOrConnectWithoutCharactersInput | character_healthsCreateOrConnectWithoutCharactersInput[]
    upsert?: character_healthsUpsertWithWhereUniqueWithoutCharactersInput | character_healthsUpsertWithWhereUniqueWithoutCharactersInput[]
    createMany?: character_healthsCreateManyCharactersInputEnvelope
    set?: character_healthsWhereUniqueInput | character_healthsWhereUniqueInput[]
    disconnect?: character_healthsWhereUniqueInput | character_healthsWhereUniqueInput[]
    delete?: character_healthsWhereUniqueInput | character_healthsWhereUniqueInput[]
    connect?: character_healthsWhereUniqueInput | character_healthsWhereUniqueInput[]
    update?: character_healthsUpdateWithWhereUniqueWithoutCharactersInput | character_healthsUpdateWithWhereUniqueWithoutCharactersInput[]
    updateMany?: character_healthsUpdateManyWithWhereWithoutCharactersInput | character_healthsUpdateManyWithWhereWithoutCharactersInput[]
    deleteMany?: character_healthsScalarWhereInput | character_healthsScalarWhereInput[]
  }

  export type character_humanityUpdateManyWithoutCharactersNestedInput = {
    create?: XOR<character_humanityCreateWithoutCharactersInput, character_humanityUncheckedCreateWithoutCharactersInput> | character_humanityCreateWithoutCharactersInput[] | character_humanityUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_humanityCreateOrConnectWithoutCharactersInput | character_humanityCreateOrConnectWithoutCharactersInput[]
    upsert?: character_humanityUpsertWithWhereUniqueWithoutCharactersInput | character_humanityUpsertWithWhereUniqueWithoutCharactersInput[]
    createMany?: character_humanityCreateManyCharactersInputEnvelope
    set?: character_humanityWhereUniqueInput | character_humanityWhereUniqueInput[]
    disconnect?: character_humanityWhereUniqueInput | character_humanityWhereUniqueInput[]
    delete?: character_humanityWhereUniqueInput | character_humanityWhereUniqueInput[]
    connect?: character_humanityWhereUniqueInput | character_humanityWhereUniqueInput[]
    update?: character_humanityUpdateWithWhereUniqueWithoutCharactersInput | character_humanityUpdateWithWhereUniqueWithoutCharactersInput[]
    updateMany?: character_humanityUpdateManyWithWhereWithoutCharactersInput | character_humanityUpdateManyWithWhereWithoutCharactersInput[]
    deleteMany?: character_humanityScalarWhereInput | character_humanityScalarWhereInput[]
  }

  export type character_profileUpdateManyWithoutCharactersNestedInput = {
    create?: XOR<character_profileCreateWithoutCharactersInput, character_profileUncheckedCreateWithoutCharactersInput> | character_profileCreateWithoutCharactersInput[] | character_profileUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_profileCreateOrConnectWithoutCharactersInput | character_profileCreateOrConnectWithoutCharactersInput[]
    upsert?: character_profileUpsertWithWhereUniqueWithoutCharactersInput | character_profileUpsertWithWhereUniqueWithoutCharactersInput[]
    createMany?: character_profileCreateManyCharactersInputEnvelope
    set?: character_profileWhereUniqueInput | character_profileWhereUniqueInput[]
    disconnect?: character_profileWhereUniqueInput | character_profileWhereUniqueInput[]
    delete?: character_profileWhereUniqueInput | character_profileWhereUniqueInput[]
    connect?: character_profileWhereUniqueInput | character_profileWhereUniqueInput[]
    update?: character_profileUpdateWithWhereUniqueWithoutCharactersInput | character_profileUpdateWithWhereUniqueWithoutCharactersInput[]
    updateMany?: character_profileUpdateManyWithWhereWithoutCharactersInput | character_profileUpdateManyWithWhereWithoutCharactersInput[]
    deleteMany?: character_profileScalarWhereInput | character_profileScalarWhereInput[]
  }

  export type character_ritualsUpdateManyWithoutCharactersNestedInput = {
    create?: XOR<character_ritualsCreateWithoutCharactersInput, character_ritualsUncheckedCreateWithoutCharactersInput> | character_ritualsCreateWithoutCharactersInput[] | character_ritualsUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_ritualsCreateOrConnectWithoutCharactersInput | character_ritualsCreateOrConnectWithoutCharactersInput[]
    upsert?: character_ritualsUpsertWithWhereUniqueWithoutCharactersInput | character_ritualsUpsertWithWhereUniqueWithoutCharactersInput[]
    createMany?: character_ritualsCreateManyCharactersInputEnvelope
    set?: character_ritualsWhereUniqueInput | character_ritualsWhereUniqueInput[]
    disconnect?: character_ritualsWhereUniqueInput | character_ritualsWhereUniqueInput[]
    delete?: character_ritualsWhereUniqueInput | character_ritualsWhereUniqueInput[]
    connect?: character_ritualsWhereUniqueInput | character_ritualsWhereUniqueInput[]
    update?: character_ritualsUpdateWithWhereUniqueWithoutCharactersInput | character_ritualsUpdateWithWhereUniqueWithoutCharactersInput[]
    updateMany?: character_ritualsUpdateManyWithWhereWithoutCharactersInput | character_ritualsUpdateManyWithWhereWithoutCharactersInput[]
    deleteMany?: character_ritualsScalarWhereInput | character_ritualsScalarWhereInput[]
  }

  export type character_skillsUpdateManyWithoutCharactersNestedInput = {
    create?: XOR<character_skillsCreateWithoutCharactersInput, character_skillsUncheckedCreateWithoutCharactersInput> | character_skillsCreateWithoutCharactersInput[] | character_skillsUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_skillsCreateOrConnectWithoutCharactersInput | character_skillsCreateOrConnectWithoutCharactersInput[]
    upsert?: character_skillsUpsertWithWhereUniqueWithoutCharactersInput | character_skillsUpsertWithWhereUniqueWithoutCharactersInput[]
    createMany?: character_skillsCreateManyCharactersInputEnvelope
    set?: character_skillsWhereUniqueInput | character_skillsWhereUniqueInput[]
    disconnect?: character_skillsWhereUniqueInput | character_skillsWhereUniqueInput[]
    delete?: character_skillsWhereUniqueInput | character_skillsWhereUniqueInput[]
    connect?: character_skillsWhereUniqueInput | character_skillsWhereUniqueInput[]
    update?: character_skillsUpdateWithWhereUniqueWithoutCharactersInput | character_skillsUpdateWithWhereUniqueWithoutCharactersInput[]
    updateMany?: character_skillsUpdateManyWithWhereWithoutCharactersInput | character_skillsUpdateManyWithWhereWithoutCharactersInput[]
    deleteMany?: character_skillsScalarWhereInput | character_skillsScalarWhereInput[]
  }

  export type character_specialtiesUpdateManyWithoutCharactersNestedInput = {
    create?: XOR<character_specialtiesCreateWithoutCharactersInput, character_specialtiesUncheckedCreateWithoutCharactersInput> | character_specialtiesCreateWithoutCharactersInput[] | character_specialtiesUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_specialtiesCreateOrConnectWithoutCharactersInput | character_specialtiesCreateOrConnectWithoutCharactersInput[]
    upsert?: character_specialtiesUpsertWithWhereUniqueWithoutCharactersInput | character_specialtiesUpsertWithWhereUniqueWithoutCharactersInput[]
    createMany?: character_specialtiesCreateManyCharactersInputEnvelope
    set?: character_specialtiesWhereUniqueInput | character_specialtiesWhereUniqueInput[]
    disconnect?: character_specialtiesWhereUniqueInput | character_specialtiesWhereUniqueInput[]
    delete?: character_specialtiesWhereUniqueInput | character_specialtiesWhereUniqueInput[]
    connect?: character_specialtiesWhereUniqueInput | character_specialtiesWhereUniqueInput[]
    update?: character_specialtiesUpdateWithWhereUniqueWithoutCharactersInput | character_specialtiesUpdateWithWhereUniqueWithoutCharactersInput[]
    updateMany?: character_specialtiesUpdateManyWithWhereWithoutCharactersInput | character_specialtiesUpdateManyWithWhereWithoutCharactersInput[]
    deleteMany?: character_specialtiesScalarWhereInput | character_specialtiesScalarWhereInput[]
  }

  export type character_willpowersUpdateManyWithoutCharactersNestedInput = {
    create?: XOR<character_willpowersCreateWithoutCharactersInput, character_willpowersUncheckedCreateWithoutCharactersInput> | character_willpowersCreateWithoutCharactersInput[] | character_willpowersUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_willpowersCreateOrConnectWithoutCharactersInput | character_willpowersCreateOrConnectWithoutCharactersInput[]
    upsert?: character_willpowersUpsertWithWhereUniqueWithoutCharactersInput | character_willpowersUpsertWithWhereUniqueWithoutCharactersInput[]
    createMany?: character_willpowersCreateManyCharactersInputEnvelope
    set?: character_willpowersWhereUniqueInput | character_willpowersWhereUniqueInput[]
    disconnect?: character_willpowersWhereUniqueInput | character_willpowersWhereUniqueInput[]
    delete?: character_willpowersWhereUniqueInput | character_willpowersWhereUniqueInput[]
    connect?: character_willpowersWhereUniqueInput | character_willpowersWhereUniqueInput[]
    update?: character_willpowersUpdateWithWhereUniqueWithoutCharactersInput | character_willpowersUpdateWithWhereUniqueWithoutCharactersInput[]
    updateMany?: character_willpowersUpdateManyWithWhereWithoutCharactersInput | character_willpowersUpdateManyWithWhereWithoutCharactersInput[]
    deleteMany?: character_willpowersScalarWhereInput | character_willpowersScalarWhereInput[]
  }

  export type chroniclesUpdateOneWithoutCharactersNestedInput = {
    create?: XOR<chroniclesCreateWithoutCharactersInput, chroniclesUncheckedCreateWithoutCharactersInput>
    connectOrCreate?: chroniclesCreateOrConnectWithoutCharactersInput
    upsert?: chroniclesUpsertWithoutCharactersInput
    disconnect?: chroniclesWhereInput | boolean
    delete?: chroniclesWhereInput | boolean
    connect?: chroniclesWhereUniqueInput
    update?: XOR<XOR<chroniclesUpdateToOneWithWhereWithoutCharactersInput, chroniclesUpdateWithoutCharactersInput>, chroniclesUncheckedUpdateWithoutCharactersInput>
  }

  export type clan_banesUpdateOneWithoutCharactersNestedInput = {
    create?: XOR<clan_banesCreateWithoutCharactersInput, clan_banesUncheckedCreateWithoutCharactersInput>
    connectOrCreate?: clan_banesCreateOrConnectWithoutCharactersInput
    upsert?: clan_banesUpsertWithoutCharactersInput
    disconnect?: clan_banesWhereInput | boolean
    delete?: clan_banesWhereInput | boolean
    connect?: clan_banesWhereUniqueInput
    update?: XOR<XOR<clan_banesUpdateToOneWithWhereWithoutCharactersInput, clan_banesUpdateWithoutCharactersInput>, clan_banesUncheckedUpdateWithoutCharactersInput>
  }

  export type clan_compulsionsUpdateOneWithoutCharactersNestedInput = {
    create?: XOR<clan_compulsionsCreateWithoutCharactersInput, clan_compulsionsUncheckedCreateWithoutCharactersInput>
    connectOrCreate?: clan_compulsionsCreateOrConnectWithoutCharactersInput
    upsert?: clan_compulsionsUpsertWithoutCharactersInput
    disconnect?: clan_compulsionsWhereInput | boolean
    delete?: clan_compulsionsWhereInput | boolean
    connect?: clan_compulsionsWhereUniqueInput
    update?: XOR<XOR<clan_compulsionsUpdateToOneWithWhereWithoutCharactersInput, clan_compulsionsUpdateWithoutCharactersInput>, clan_compulsionsUncheckedUpdateWithoutCharactersInput>
  }

  export type clansUpdateOneWithoutCharactersNestedInput = {
    create?: XOR<clansCreateWithoutCharactersInput, clansUncheckedCreateWithoutCharactersInput>
    connectOrCreate?: clansCreateOrConnectWithoutCharactersInput
    upsert?: clansUpsertWithoutCharactersInput
    disconnect?: clansWhereInput | boolean
    delete?: clansWhereInput | boolean
    connect?: clansWhereUniqueInput
    update?: XOR<XOR<clansUpdateToOneWithWhereWithoutCharactersInput, clansUpdateWithoutCharactersInput>, clansUncheckedUpdateWithoutCharactersInput>
  }

  export type char_groupsUpdateOneRequiredWithoutCharactersNestedInput = {
    create?: XOR<char_groupsCreateWithoutCharactersInput, char_groupsUncheckedCreateWithoutCharactersInput>
    connectOrCreate?: char_groupsCreateOrConnectWithoutCharactersInput
    upsert?: char_groupsUpsertWithoutCharactersInput
    connect?: char_groupsWhereUniqueInput
    update?: XOR<XOR<char_groupsUpdateToOneWithWhereWithoutCharactersInput, char_groupsUpdateWithoutCharactersInput>, char_groupsUncheckedUpdateWithoutCharactersInput>
  }

  export type predator_typesUpdateOneRequiredWithoutCharactersNestedInput = {
    create?: XOR<predator_typesCreateWithoutCharactersInput, predator_typesUncheckedCreateWithoutCharactersInput>
    connectOrCreate?: predator_typesCreateOrConnectWithoutCharactersInput
    upsert?: predator_typesUpsertWithoutCharactersInput
    connect?: predator_typesWhereUniqueInput
    update?: XOR<XOR<predator_typesUpdateToOneWithWhereWithoutCharactersInput, predator_typesUpdateWithoutCharactersInput>, predator_typesUncheckedUpdateWithoutCharactersInput>
  }

  export type sectsUpdateOneWithoutCharactersNestedInput = {
    create?: XOR<sectsCreateWithoutCharactersInput, sectsUncheckedCreateWithoutCharactersInput>
    connectOrCreate?: sectsCreateOrConnectWithoutCharactersInput
    upsert?: sectsUpsertWithoutCharactersInput
    disconnect?: sectsWhereInput | boolean
    delete?: sectsWhereInput | boolean
    connect?: sectsWhereUniqueInput
    update?: XOR<XOR<sectsUpdateToOneWithWhereWithoutCharactersInput, sectsUpdateWithoutCharactersInput>, sectsUncheckedUpdateWithoutCharactersInput>
  }

  export type usersUpdateOneRequiredWithoutCharactersNestedInput = {
    create?: XOR<usersCreateWithoutCharactersInput, usersUncheckedCreateWithoutCharactersInput>
    connectOrCreate?: usersCreateOrConnectWithoutCharactersInput
    upsert?: usersUpsertWithoutCharactersInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutCharactersInput, usersUpdateWithoutCharactersInput>, usersUncheckedUpdateWithoutCharactersInput>
  }

  export type exp_logsUpdateManyWithoutCharactersNestedInput = {
    create?: XOR<exp_logsCreateWithoutCharactersInput, exp_logsUncheckedCreateWithoutCharactersInput> | exp_logsCreateWithoutCharactersInput[] | exp_logsUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: exp_logsCreateOrConnectWithoutCharactersInput | exp_logsCreateOrConnectWithoutCharactersInput[]
    upsert?: exp_logsUpsertWithWhereUniqueWithoutCharactersInput | exp_logsUpsertWithWhereUniqueWithoutCharactersInput[]
    createMany?: exp_logsCreateManyCharactersInputEnvelope
    set?: exp_logsWhereUniqueInput | exp_logsWhereUniqueInput[]
    disconnect?: exp_logsWhereUniqueInput | exp_logsWhereUniqueInput[]
    delete?: exp_logsWhereUniqueInput | exp_logsWhereUniqueInput[]
    connect?: exp_logsWhereUniqueInput | exp_logsWhereUniqueInput[]
    update?: exp_logsUpdateWithWhereUniqueWithoutCharactersInput | exp_logsUpdateWithWhereUniqueWithoutCharactersInput[]
    updateMany?: exp_logsUpdateManyWithWhereWithoutCharactersInput | exp_logsUpdateManyWithWhereWithoutCharactersInput[]
    deleteMany?: exp_logsScalarWhereInput | exp_logsScalarWhereInput[]
  }

  export type character_advantagesUncheckedUpdateManyWithoutCharactersNestedInput = {
    create?: XOR<character_advantagesCreateWithoutCharactersInput, character_advantagesUncheckedCreateWithoutCharactersInput> | character_advantagesCreateWithoutCharactersInput[] | character_advantagesUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_advantagesCreateOrConnectWithoutCharactersInput | character_advantagesCreateOrConnectWithoutCharactersInput[]
    upsert?: character_advantagesUpsertWithWhereUniqueWithoutCharactersInput | character_advantagesUpsertWithWhereUniqueWithoutCharactersInput[]
    createMany?: character_advantagesCreateManyCharactersInputEnvelope
    set?: character_advantagesWhereUniqueInput | character_advantagesWhereUniqueInput[]
    disconnect?: character_advantagesWhereUniqueInput | character_advantagesWhereUniqueInput[]
    delete?: character_advantagesWhereUniqueInput | character_advantagesWhereUniqueInput[]
    connect?: character_advantagesWhereUniqueInput | character_advantagesWhereUniqueInput[]
    update?: character_advantagesUpdateWithWhereUniqueWithoutCharactersInput | character_advantagesUpdateWithWhereUniqueWithoutCharactersInput[]
    updateMany?: character_advantagesUpdateManyWithWhereWithoutCharactersInput | character_advantagesUpdateManyWithWhereWithoutCharactersInput[]
    deleteMany?: character_advantagesScalarWhereInput | character_advantagesScalarWhereInput[]
  }

  export type character_alchemy_powersUncheckedUpdateManyWithoutCharactersNestedInput = {
    create?: XOR<character_alchemy_powersCreateWithoutCharactersInput, character_alchemy_powersUncheckedCreateWithoutCharactersInput> | character_alchemy_powersCreateWithoutCharactersInput[] | character_alchemy_powersUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_alchemy_powersCreateOrConnectWithoutCharactersInput | character_alchemy_powersCreateOrConnectWithoutCharactersInput[]
    upsert?: character_alchemy_powersUpsertWithWhereUniqueWithoutCharactersInput | character_alchemy_powersUpsertWithWhereUniqueWithoutCharactersInput[]
    createMany?: character_alchemy_powersCreateManyCharactersInputEnvelope
    set?: character_alchemy_powersWhereUniqueInput | character_alchemy_powersWhereUniqueInput[]
    disconnect?: character_alchemy_powersWhereUniqueInput | character_alchemy_powersWhereUniqueInput[]
    delete?: character_alchemy_powersWhereUniqueInput | character_alchemy_powersWhereUniqueInput[]
    connect?: character_alchemy_powersWhereUniqueInput | character_alchemy_powersWhereUniqueInput[]
    update?: character_alchemy_powersUpdateWithWhereUniqueWithoutCharactersInput | character_alchemy_powersUpdateWithWhereUniqueWithoutCharactersInput[]
    updateMany?: character_alchemy_powersUpdateManyWithWhereWithoutCharactersInput | character_alchemy_powersUpdateManyWithWhereWithoutCharactersInput[]
    deleteMany?: character_alchemy_powersScalarWhereInput | character_alchemy_powersScalarWhereInput[]
  }

  export type character_attributesUncheckedUpdateManyWithoutCharactersNestedInput = {
    create?: XOR<character_attributesCreateWithoutCharactersInput, character_attributesUncheckedCreateWithoutCharactersInput> | character_attributesCreateWithoutCharactersInput[] | character_attributesUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_attributesCreateOrConnectWithoutCharactersInput | character_attributesCreateOrConnectWithoutCharactersInput[]
    upsert?: character_attributesUpsertWithWhereUniqueWithoutCharactersInput | character_attributesUpsertWithWhereUniqueWithoutCharactersInput[]
    createMany?: character_attributesCreateManyCharactersInputEnvelope
    set?: character_attributesWhereUniqueInput | character_attributesWhereUniqueInput[]
    disconnect?: character_attributesWhereUniqueInput | character_attributesWhereUniqueInput[]
    delete?: character_attributesWhereUniqueInput | character_attributesWhereUniqueInput[]
    connect?: character_attributesWhereUniqueInput | character_attributesWhereUniqueInput[]
    update?: character_attributesUpdateWithWhereUniqueWithoutCharactersInput | character_attributesUpdateWithWhereUniqueWithoutCharactersInput[]
    updateMany?: character_attributesUpdateManyWithWhereWithoutCharactersInput | character_attributesUpdateManyWithWhereWithoutCharactersInput[]
    deleteMany?: character_attributesScalarWhereInput | character_attributesScalarWhereInput[]
  }

  export type character_bloodpotenciesUncheckedUpdateManyWithoutCharactersNestedInput = {
    create?: XOR<character_bloodpotenciesCreateWithoutCharactersInput, character_bloodpotenciesUncheckedCreateWithoutCharactersInput> | character_bloodpotenciesCreateWithoutCharactersInput[] | character_bloodpotenciesUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_bloodpotenciesCreateOrConnectWithoutCharactersInput | character_bloodpotenciesCreateOrConnectWithoutCharactersInput[]
    upsert?: character_bloodpotenciesUpsertWithWhereUniqueWithoutCharactersInput | character_bloodpotenciesUpsertWithWhereUniqueWithoutCharactersInput[]
    createMany?: character_bloodpotenciesCreateManyCharactersInputEnvelope
    set?: character_bloodpotenciesWhereUniqueInput | character_bloodpotenciesWhereUniqueInput[]
    disconnect?: character_bloodpotenciesWhereUniqueInput | character_bloodpotenciesWhereUniqueInput[]
    delete?: character_bloodpotenciesWhereUniqueInput | character_bloodpotenciesWhereUniqueInput[]
    connect?: character_bloodpotenciesWhereUniqueInput | character_bloodpotenciesWhereUniqueInput[]
    update?: character_bloodpotenciesUpdateWithWhereUniqueWithoutCharactersInput | character_bloodpotenciesUpdateWithWhereUniqueWithoutCharactersInput[]
    updateMany?: character_bloodpotenciesUpdateManyWithWhereWithoutCharactersInput | character_bloodpotenciesUpdateManyWithWhereWithoutCharactersInput[]
    deleteMany?: character_bloodpotenciesScalarWhereInput | character_bloodpotenciesScalarWhereInput[]
  }

  export type character_discipline_powersUncheckedUpdateManyWithoutCharactersNestedInput = {
    create?: XOR<character_discipline_powersCreateWithoutCharactersInput, character_discipline_powersUncheckedCreateWithoutCharactersInput> | character_discipline_powersCreateWithoutCharactersInput[] | character_discipline_powersUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_discipline_powersCreateOrConnectWithoutCharactersInput | character_discipline_powersCreateOrConnectWithoutCharactersInput[]
    upsert?: character_discipline_powersUpsertWithWhereUniqueWithoutCharactersInput | character_discipline_powersUpsertWithWhereUniqueWithoutCharactersInput[]
    createMany?: character_discipline_powersCreateManyCharactersInputEnvelope
    set?: character_discipline_powersWhereUniqueInput | character_discipline_powersWhereUniqueInput[]
    disconnect?: character_discipline_powersWhereUniqueInput | character_discipline_powersWhereUniqueInput[]
    delete?: character_discipline_powersWhereUniqueInput | character_discipline_powersWhereUniqueInput[]
    connect?: character_discipline_powersWhereUniqueInput | character_discipline_powersWhereUniqueInput[]
    update?: character_discipline_powersUpdateWithWhereUniqueWithoutCharactersInput | character_discipline_powersUpdateWithWhereUniqueWithoutCharactersInput[]
    updateMany?: character_discipline_powersUpdateManyWithWhereWithoutCharactersInput | character_discipline_powersUpdateManyWithWhereWithoutCharactersInput[]
    deleteMany?: character_discipline_powersScalarWhereInput | character_discipline_powersScalarWhereInput[]
  }

  export type character_disciplinesUncheckedUpdateManyWithoutCharactersNestedInput = {
    create?: XOR<character_disciplinesCreateWithoutCharactersInput, character_disciplinesUncheckedCreateWithoutCharactersInput> | character_disciplinesCreateWithoutCharactersInput[] | character_disciplinesUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_disciplinesCreateOrConnectWithoutCharactersInput | character_disciplinesCreateOrConnectWithoutCharactersInput[]
    upsert?: character_disciplinesUpsertWithWhereUniqueWithoutCharactersInput | character_disciplinesUpsertWithWhereUniqueWithoutCharactersInput[]
    createMany?: character_disciplinesCreateManyCharactersInputEnvelope
    set?: character_disciplinesWhereUniqueInput | character_disciplinesWhereUniqueInput[]
    disconnect?: character_disciplinesWhereUniqueInput | character_disciplinesWhereUniqueInput[]
    delete?: character_disciplinesWhereUniqueInput | character_disciplinesWhereUniqueInput[]
    connect?: character_disciplinesWhereUniqueInput | character_disciplinesWhereUniqueInput[]
    update?: character_disciplinesUpdateWithWhereUniqueWithoutCharactersInput | character_disciplinesUpdateWithWhereUniqueWithoutCharactersInput[]
    updateMany?: character_disciplinesUpdateManyWithWhereWithoutCharactersInput | character_disciplinesUpdateManyWithWhereWithoutCharactersInput[]
    deleteMany?: character_disciplinesScalarWhereInput | character_disciplinesScalarWhereInput[]
  }

  export type character_healthsUncheckedUpdateManyWithoutCharactersNestedInput = {
    create?: XOR<character_healthsCreateWithoutCharactersInput, character_healthsUncheckedCreateWithoutCharactersInput> | character_healthsCreateWithoutCharactersInput[] | character_healthsUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_healthsCreateOrConnectWithoutCharactersInput | character_healthsCreateOrConnectWithoutCharactersInput[]
    upsert?: character_healthsUpsertWithWhereUniqueWithoutCharactersInput | character_healthsUpsertWithWhereUniqueWithoutCharactersInput[]
    createMany?: character_healthsCreateManyCharactersInputEnvelope
    set?: character_healthsWhereUniqueInput | character_healthsWhereUniqueInput[]
    disconnect?: character_healthsWhereUniqueInput | character_healthsWhereUniqueInput[]
    delete?: character_healthsWhereUniqueInput | character_healthsWhereUniqueInput[]
    connect?: character_healthsWhereUniqueInput | character_healthsWhereUniqueInput[]
    update?: character_healthsUpdateWithWhereUniqueWithoutCharactersInput | character_healthsUpdateWithWhereUniqueWithoutCharactersInput[]
    updateMany?: character_healthsUpdateManyWithWhereWithoutCharactersInput | character_healthsUpdateManyWithWhereWithoutCharactersInput[]
    deleteMany?: character_healthsScalarWhereInput | character_healthsScalarWhereInput[]
  }

  export type character_humanityUncheckedUpdateManyWithoutCharactersNestedInput = {
    create?: XOR<character_humanityCreateWithoutCharactersInput, character_humanityUncheckedCreateWithoutCharactersInput> | character_humanityCreateWithoutCharactersInput[] | character_humanityUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_humanityCreateOrConnectWithoutCharactersInput | character_humanityCreateOrConnectWithoutCharactersInput[]
    upsert?: character_humanityUpsertWithWhereUniqueWithoutCharactersInput | character_humanityUpsertWithWhereUniqueWithoutCharactersInput[]
    createMany?: character_humanityCreateManyCharactersInputEnvelope
    set?: character_humanityWhereUniqueInput | character_humanityWhereUniqueInput[]
    disconnect?: character_humanityWhereUniqueInput | character_humanityWhereUniqueInput[]
    delete?: character_humanityWhereUniqueInput | character_humanityWhereUniqueInput[]
    connect?: character_humanityWhereUniqueInput | character_humanityWhereUniqueInput[]
    update?: character_humanityUpdateWithWhereUniqueWithoutCharactersInput | character_humanityUpdateWithWhereUniqueWithoutCharactersInput[]
    updateMany?: character_humanityUpdateManyWithWhereWithoutCharactersInput | character_humanityUpdateManyWithWhereWithoutCharactersInput[]
    deleteMany?: character_humanityScalarWhereInput | character_humanityScalarWhereInput[]
  }

  export type character_profileUncheckedUpdateManyWithoutCharactersNestedInput = {
    create?: XOR<character_profileCreateWithoutCharactersInput, character_profileUncheckedCreateWithoutCharactersInput> | character_profileCreateWithoutCharactersInput[] | character_profileUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_profileCreateOrConnectWithoutCharactersInput | character_profileCreateOrConnectWithoutCharactersInput[]
    upsert?: character_profileUpsertWithWhereUniqueWithoutCharactersInput | character_profileUpsertWithWhereUniqueWithoutCharactersInput[]
    createMany?: character_profileCreateManyCharactersInputEnvelope
    set?: character_profileWhereUniqueInput | character_profileWhereUniqueInput[]
    disconnect?: character_profileWhereUniqueInput | character_profileWhereUniqueInput[]
    delete?: character_profileWhereUniqueInput | character_profileWhereUniqueInput[]
    connect?: character_profileWhereUniqueInput | character_profileWhereUniqueInput[]
    update?: character_profileUpdateWithWhereUniqueWithoutCharactersInput | character_profileUpdateWithWhereUniqueWithoutCharactersInput[]
    updateMany?: character_profileUpdateManyWithWhereWithoutCharactersInput | character_profileUpdateManyWithWhereWithoutCharactersInput[]
    deleteMany?: character_profileScalarWhereInput | character_profileScalarWhereInput[]
  }

  export type character_ritualsUncheckedUpdateManyWithoutCharactersNestedInput = {
    create?: XOR<character_ritualsCreateWithoutCharactersInput, character_ritualsUncheckedCreateWithoutCharactersInput> | character_ritualsCreateWithoutCharactersInput[] | character_ritualsUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_ritualsCreateOrConnectWithoutCharactersInput | character_ritualsCreateOrConnectWithoutCharactersInput[]
    upsert?: character_ritualsUpsertWithWhereUniqueWithoutCharactersInput | character_ritualsUpsertWithWhereUniqueWithoutCharactersInput[]
    createMany?: character_ritualsCreateManyCharactersInputEnvelope
    set?: character_ritualsWhereUniqueInput | character_ritualsWhereUniqueInput[]
    disconnect?: character_ritualsWhereUniqueInput | character_ritualsWhereUniqueInput[]
    delete?: character_ritualsWhereUniqueInput | character_ritualsWhereUniqueInput[]
    connect?: character_ritualsWhereUniqueInput | character_ritualsWhereUniqueInput[]
    update?: character_ritualsUpdateWithWhereUniqueWithoutCharactersInput | character_ritualsUpdateWithWhereUniqueWithoutCharactersInput[]
    updateMany?: character_ritualsUpdateManyWithWhereWithoutCharactersInput | character_ritualsUpdateManyWithWhereWithoutCharactersInput[]
    deleteMany?: character_ritualsScalarWhereInput | character_ritualsScalarWhereInput[]
  }

  export type character_skillsUncheckedUpdateManyWithoutCharactersNestedInput = {
    create?: XOR<character_skillsCreateWithoutCharactersInput, character_skillsUncheckedCreateWithoutCharactersInput> | character_skillsCreateWithoutCharactersInput[] | character_skillsUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_skillsCreateOrConnectWithoutCharactersInput | character_skillsCreateOrConnectWithoutCharactersInput[]
    upsert?: character_skillsUpsertWithWhereUniqueWithoutCharactersInput | character_skillsUpsertWithWhereUniqueWithoutCharactersInput[]
    createMany?: character_skillsCreateManyCharactersInputEnvelope
    set?: character_skillsWhereUniqueInput | character_skillsWhereUniqueInput[]
    disconnect?: character_skillsWhereUniqueInput | character_skillsWhereUniqueInput[]
    delete?: character_skillsWhereUniqueInput | character_skillsWhereUniqueInput[]
    connect?: character_skillsWhereUniqueInput | character_skillsWhereUniqueInput[]
    update?: character_skillsUpdateWithWhereUniqueWithoutCharactersInput | character_skillsUpdateWithWhereUniqueWithoutCharactersInput[]
    updateMany?: character_skillsUpdateManyWithWhereWithoutCharactersInput | character_skillsUpdateManyWithWhereWithoutCharactersInput[]
    deleteMany?: character_skillsScalarWhereInput | character_skillsScalarWhereInput[]
  }

  export type character_specialtiesUncheckedUpdateManyWithoutCharactersNestedInput = {
    create?: XOR<character_specialtiesCreateWithoutCharactersInput, character_specialtiesUncheckedCreateWithoutCharactersInput> | character_specialtiesCreateWithoutCharactersInput[] | character_specialtiesUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_specialtiesCreateOrConnectWithoutCharactersInput | character_specialtiesCreateOrConnectWithoutCharactersInput[]
    upsert?: character_specialtiesUpsertWithWhereUniqueWithoutCharactersInput | character_specialtiesUpsertWithWhereUniqueWithoutCharactersInput[]
    createMany?: character_specialtiesCreateManyCharactersInputEnvelope
    set?: character_specialtiesWhereUniqueInput | character_specialtiesWhereUniqueInput[]
    disconnect?: character_specialtiesWhereUniqueInput | character_specialtiesWhereUniqueInput[]
    delete?: character_specialtiesWhereUniqueInput | character_specialtiesWhereUniqueInput[]
    connect?: character_specialtiesWhereUniqueInput | character_specialtiesWhereUniqueInput[]
    update?: character_specialtiesUpdateWithWhereUniqueWithoutCharactersInput | character_specialtiesUpdateWithWhereUniqueWithoutCharactersInput[]
    updateMany?: character_specialtiesUpdateManyWithWhereWithoutCharactersInput | character_specialtiesUpdateManyWithWhereWithoutCharactersInput[]
    deleteMany?: character_specialtiesScalarWhereInput | character_specialtiesScalarWhereInput[]
  }

  export type character_willpowersUncheckedUpdateManyWithoutCharactersNestedInput = {
    create?: XOR<character_willpowersCreateWithoutCharactersInput, character_willpowersUncheckedCreateWithoutCharactersInput> | character_willpowersCreateWithoutCharactersInput[] | character_willpowersUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: character_willpowersCreateOrConnectWithoutCharactersInput | character_willpowersCreateOrConnectWithoutCharactersInput[]
    upsert?: character_willpowersUpsertWithWhereUniqueWithoutCharactersInput | character_willpowersUpsertWithWhereUniqueWithoutCharactersInput[]
    createMany?: character_willpowersCreateManyCharactersInputEnvelope
    set?: character_willpowersWhereUniqueInput | character_willpowersWhereUniqueInput[]
    disconnect?: character_willpowersWhereUniqueInput | character_willpowersWhereUniqueInput[]
    delete?: character_willpowersWhereUniqueInput | character_willpowersWhereUniqueInput[]
    connect?: character_willpowersWhereUniqueInput | character_willpowersWhereUniqueInput[]
    update?: character_willpowersUpdateWithWhereUniqueWithoutCharactersInput | character_willpowersUpdateWithWhereUniqueWithoutCharactersInput[]
    updateMany?: character_willpowersUpdateManyWithWhereWithoutCharactersInput | character_willpowersUpdateManyWithWhereWithoutCharactersInput[]
    deleteMany?: character_willpowersScalarWhereInput | character_willpowersScalarWhereInput[]
  }

  export type exp_logsUncheckedUpdateManyWithoutCharactersNestedInput = {
    create?: XOR<exp_logsCreateWithoutCharactersInput, exp_logsUncheckedCreateWithoutCharactersInput> | exp_logsCreateWithoutCharactersInput[] | exp_logsUncheckedCreateWithoutCharactersInput[]
    connectOrCreate?: exp_logsCreateOrConnectWithoutCharactersInput | exp_logsCreateOrConnectWithoutCharactersInput[]
    upsert?: exp_logsUpsertWithWhereUniqueWithoutCharactersInput | exp_logsUpsertWithWhereUniqueWithoutCharactersInput[]
    createMany?: exp_logsCreateManyCharactersInputEnvelope
    set?: exp_logsWhereUniqueInput | exp_logsWhereUniqueInput[]
    disconnect?: exp_logsWhereUniqueInput | exp_logsWhereUniqueInput[]
    delete?: exp_logsWhereUniqueInput | exp_logsWhereUniqueInput[]
    connect?: exp_logsWhereUniqueInput | exp_logsWhereUniqueInput[]
    update?: exp_logsUpdateWithWhereUniqueWithoutCharactersInput | exp_logsUpdateWithWhereUniqueWithoutCharactersInput[]
    updateMany?: exp_logsUpdateManyWithWhereWithoutCharactersInput | exp_logsUpdateManyWithWhereWithoutCharactersInput[]
    deleteMany?: exp_logsScalarWhereInput | exp_logsScalarWhereInput[]
  }

  export type charactersCreateNestedManyWithoutChroniclesInput = {
    create?: XOR<charactersCreateWithoutChroniclesInput, charactersUncheckedCreateWithoutChroniclesInput> | charactersCreateWithoutChroniclesInput[] | charactersUncheckedCreateWithoutChroniclesInput[]
    connectOrCreate?: charactersCreateOrConnectWithoutChroniclesInput | charactersCreateOrConnectWithoutChroniclesInput[]
    createMany?: charactersCreateManyChroniclesInputEnvelope
    connect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutChroniclesInput = {
    create?: XOR<usersCreateWithoutChroniclesInput, usersUncheckedCreateWithoutChroniclesInput>
    connectOrCreate?: usersCreateOrConnectWithoutChroniclesInput
    connect?: usersWhereUniqueInput
  }

  export type charactersUncheckedCreateNestedManyWithoutChroniclesInput = {
    create?: XOR<charactersCreateWithoutChroniclesInput, charactersUncheckedCreateWithoutChroniclesInput> | charactersCreateWithoutChroniclesInput[] | charactersUncheckedCreateWithoutChroniclesInput[]
    connectOrCreate?: charactersCreateOrConnectWithoutChroniclesInput | charactersCreateOrConnectWithoutChroniclesInput[]
    createMany?: charactersCreateManyChroniclesInputEnvelope
    connect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
  }

  export type charactersUpdateManyWithoutChroniclesNestedInput = {
    create?: XOR<charactersCreateWithoutChroniclesInput, charactersUncheckedCreateWithoutChroniclesInput> | charactersCreateWithoutChroniclesInput[] | charactersUncheckedCreateWithoutChroniclesInput[]
    connectOrCreate?: charactersCreateOrConnectWithoutChroniclesInput | charactersCreateOrConnectWithoutChroniclesInput[]
    upsert?: charactersUpsertWithWhereUniqueWithoutChroniclesInput | charactersUpsertWithWhereUniqueWithoutChroniclesInput[]
    createMany?: charactersCreateManyChroniclesInputEnvelope
    set?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    disconnect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    delete?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    connect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    update?: charactersUpdateWithWhereUniqueWithoutChroniclesInput | charactersUpdateWithWhereUniqueWithoutChroniclesInput[]
    updateMany?: charactersUpdateManyWithWhereWithoutChroniclesInput | charactersUpdateManyWithWhereWithoutChroniclesInput[]
    deleteMany?: charactersScalarWhereInput | charactersScalarWhereInput[]
  }

  export type usersUpdateOneRequiredWithoutChroniclesNestedInput = {
    create?: XOR<usersCreateWithoutChroniclesInput, usersUncheckedCreateWithoutChroniclesInput>
    connectOrCreate?: usersCreateOrConnectWithoutChroniclesInput
    upsert?: usersUpsertWithoutChroniclesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutChroniclesInput, usersUpdateWithoutChroniclesInput>, usersUncheckedUpdateWithoutChroniclesInput>
  }

  export type charactersUncheckedUpdateManyWithoutChroniclesNestedInput = {
    create?: XOR<charactersCreateWithoutChroniclesInput, charactersUncheckedCreateWithoutChroniclesInput> | charactersCreateWithoutChroniclesInput[] | charactersUncheckedCreateWithoutChroniclesInput[]
    connectOrCreate?: charactersCreateOrConnectWithoutChroniclesInput | charactersCreateOrConnectWithoutChroniclesInput[]
    upsert?: charactersUpsertWithWhereUniqueWithoutChroniclesInput | charactersUpsertWithWhereUniqueWithoutChroniclesInput[]
    createMany?: charactersCreateManyChroniclesInputEnvelope
    set?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    disconnect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    delete?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    connect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    update?: charactersUpdateWithWhereUniqueWithoutChroniclesInput | charactersUpdateWithWhereUniqueWithoutChroniclesInput[]
    updateMany?: charactersUpdateManyWithWhereWithoutChroniclesInput | charactersUpdateManyWithWhereWithoutChroniclesInput[]
    deleteMany?: charactersScalarWhereInput | charactersScalarWhereInput[]
  }

  export type character_bloodpotenciesCreateNestedManyWithoutClan_banesInput = {
    create?: XOR<character_bloodpotenciesCreateWithoutClan_banesInput, character_bloodpotenciesUncheckedCreateWithoutClan_banesInput> | character_bloodpotenciesCreateWithoutClan_banesInput[] | character_bloodpotenciesUncheckedCreateWithoutClan_banesInput[]
    connectOrCreate?: character_bloodpotenciesCreateOrConnectWithoutClan_banesInput | character_bloodpotenciesCreateOrConnectWithoutClan_banesInput[]
    createMany?: character_bloodpotenciesCreateManyClan_banesInputEnvelope
    connect?: character_bloodpotenciesWhereUniqueInput | character_bloodpotenciesWhereUniqueInput[]
  }

  export type charactersCreateNestedManyWithoutClan_banesInput = {
    create?: XOR<charactersCreateWithoutClan_banesInput, charactersUncheckedCreateWithoutClan_banesInput> | charactersCreateWithoutClan_banesInput[] | charactersUncheckedCreateWithoutClan_banesInput[]
    connectOrCreate?: charactersCreateOrConnectWithoutClan_banesInput | charactersCreateOrConnectWithoutClan_banesInput[]
    createMany?: charactersCreateManyClan_banesInputEnvelope
    connect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
  }

  export type clansCreateNestedOneWithoutClan_banesInput = {
    create?: XOR<clansCreateWithoutClan_banesInput, clansUncheckedCreateWithoutClan_banesInput>
    connectOrCreate?: clansCreateOrConnectWithoutClan_banesInput
    connect?: clansWhereUniqueInput
  }

  export type character_bloodpotenciesUncheckedCreateNestedManyWithoutClan_banesInput = {
    create?: XOR<character_bloodpotenciesCreateWithoutClan_banesInput, character_bloodpotenciesUncheckedCreateWithoutClan_banesInput> | character_bloodpotenciesCreateWithoutClan_banesInput[] | character_bloodpotenciesUncheckedCreateWithoutClan_banesInput[]
    connectOrCreate?: character_bloodpotenciesCreateOrConnectWithoutClan_banesInput | character_bloodpotenciesCreateOrConnectWithoutClan_banesInput[]
    createMany?: character_bloodpotenciesCreateManyClan_banesInputEnvelope
    connect?: character_bloodpotenciesWhereUniqueInput | character_bloodpotenciesWhereUniqueInput[]
  }

  export type charactersUncheckedCreateNestedManyWithoutClan_banesInput = {
    create?: XOR<charactersCreateWithoutClan_banesInput, charactersUncheckedCreateWithoutClan_banesInput> | charactersCreateWithoutClan_banesInput[] | charactersUncheckedCreateWithoutClan_banesInput[]
    connectOrCreate?: charactersCreateOrConnectWithoutClan_banesInput | charactersCreateOrConnectWithoutClan_banesInput[]
    createMany?: charactersCreateManyClan_banesInputEnvelope
    connect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
  }

  export type character_bloodpotenciesUpdateManyWithoutClan_banesNestedInput = {
    create?: XOR<character_bloodpotenciesCreateWithoutClan_banesInput, character_bloodpotenciesUncheckedCreateWithoutClan_banesInput> | character_bloodpotenciesCreateWithoutClan_banesInput[] | character_bloodpotenciesUncheckedCreateWithoutClan_banesInput[]
    connectOrCreate?: character_bloodpotenciesCreateOrConnectWithoutClan_banesInput | character_bloodpotenciesCreateOrConnectWithoutClan_banesInput[]
    upsert?: character_bloodpotenciesUpsertWithWhereUniqueWithoutClan_banesInput | character_bloodpotenciesUpsertWithWhereUniqueWithoutClan_banesInput[]
    createMany?: character_bloodpotenciesCreateManyClan_banesInputEnvelope
    set?: character_bloodpotenciesWhereUniqueInput | character_bloodpotenciesWhereUniqueInput[]
    disconnect?: character_bloodpotenciesWhereUniqueInput | character_bloodpotenciesWhereUniqueInput[]
    delete?: character_bloodpotenciesWhereUniqueInput | character_bloodpotenciesWhereUniqueInput[]
    connect?: character_bloodpotenciesWhereUniqueInput | character_bloodpotenciesWhereUniqueInput[]
    update?: character_bloodpotenciesUpdateWithWhereUniqueWithoutClan_banesInput | character_bloodpotenciesUpdateWithWhereUniqueWithoutClan_banesInput[]
    updateMany?: character_bloodpotenciesUpdateManyWithWhereWithoutClan_banesInput | character_bloodpotenciesUpdateManyWithWhereWithoutClan_banesInput[]
    deleteMany?: character_bloodpotenciesScalarWhereInput | character_bloodpotenciesScalarWhereInput[]
  }

  export type charactersUpdateManyWithoutClan_banesNestedInput = {
    create?: XOR<charactersCreateWithoutClan_banesInput, charactersUncheckedCreateWithoutClan_banesInput> | charactersCreateWithoutClan_banesInput[] | charactersUncheckedCreateWithoutClan_banesInput[]
    connectOrCreate?: charactersCreateOrConnectWithoutClan_banesInput | charactersCreateOrConnectWithoutClan_banesInput[]
    upsert?: charactersUpsertWithWhereUniqueWithoutClan_banesInput | charactersUpsertWithWhereUniqueWithoutClan_banesInput[]
    createMany?: charactersCreateManyClan_banesInputEnvelope
    set?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    disconnect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    delete?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    connect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    update?: charactersUpdateWithWhereUniqueWithoutClan_banesInput | charactersUpdateWithWhereUniqueWithoutClan_banesInput[]
    updateMany?: charactersUpdateManyWithWhereWithoutClan_banesInput | charactersUpdateManyWithWhereWithoutClan_banesInput[]
    deleteMany?: charactersScalarWhereInput | charactersScalarWhereInput[]
  }

  export type clansUpdateOneRequiredWithoutClan_banesNestedInput = {
    create?: XOR<clansCreateWithoutClan_banesInput, clansUncheckedCreateWithoutClan_banesInput>
    connectOrCreate?: clansCreateOrConnectWithoutClan_banesInput
    upsert?: clansUpsertWithoutClan_banesInput
    connect?: clansWhereUniqueInput
    update?: XOR<XOR<clansUpdateToOneWithWhereWithoutClan_banesInput, clansUpdateWithoutClan_banesInput>, clansUncheckedUpdateWithoutClan_banesInput>
  }

  export type character_bloodpotenciesUncheckedUpdateManyWithoutClan_banesNestedInput = {
    create?: XOR<character_bloodpotenciesCreateWithoutClan_banesInput, character_bloodpotenciesUncheckedCreateWithoutClan_banesInput> | character_bloodpotenciesCreateWithoutClan_banesInput[] | character_bloodpotenciesUncheckedCreateWithoutClan_banesInput[]
    connectOrCreate?: character_bloodpotenciesCreateOrConnectWithoutClan_banesInput | character_bloodpotenciesCreateOrConnectWithoutClan_banesInput[]
    upsert?: character_bloodpotenciesUpsertWithWhereUniqueWithoutClan_banesInput | character_bloodpotenciesUpsertWithWhereUniqueWithoutClan_banesInput[]
    createMany?: character_bloodpotenciesCreateManyClan_banesInputEnvelope
    set?: character_bloodpotenciesWhereUniqueInput | character_bloodpotenciesWhereUniqueInput[]
    disconnect?: character_bloodpotenciesWhereUniqueInput | character_bloodpotenciesWhereUniqueInput[]
    delete?: character_bloodpotenciesWhereUniqueInput | character_bloodpotenciesWhereUniqueInput[]
    connect?: character_bloodpotenciesWhereUniqueInput | character_bloodpotenciesWhereUniqueInput[]
    update?: character_bloodpotenciesUpdateWithWhereUniqueWithoutClan_banesInput | character_bloodpotenciesUpdateWithWhereUniqueWithoutClan_banesInput[]
    updateMany?: character_bloodpotenciesUpdateManyWithWhereWithoutClan_banesInput | character_bloodpotenciesUpdateManyWithWhereWithoutClan_banesInput[]
    deleteMany?: character_bloodpotenciesScalarWhereInput | character_bloodpotenciesScalarWhereInput[]
  }

  export type charactersUncheckedUpdateManyWithoutClan_banesNestedInput = {
    create?: XOR<charactersCreateWithoutClan_banesInput, charactersUncheckedCreateWithoutClan_banesInput> | charactersCreateWithoutClan_banesInput[] | charactersUncheckedCreateWithoutClan_banesInput[]
    connectOrCreate?: charactersCreateOrConnectWithoutClan_banesInput | charactersCreateOrConnectWithoutClan_banesInput[]
    upsert?: charactersUpsertWithWhereUniqueWithoutClan_banesInput | charactersUpsertWithWhereUniqueWithoutClan_banesInput[]
    createMany?: charactersCreateManyClan_banesInputEnvelope
    set?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    disconnect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    delete?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    connect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    update?: charactersUpdateWithWhereUniqueWithoutClan_banesInput | charactersUpdateWithWhereUniqueWithoutClan_banesInput[]
    updateMany?: charactersUpdateManyWithWhereWithoutClan_banesInput | charactersUpdateManyWithWhereWithoutClan_banesInput[]
    deleteMany?: charactersScalarWhereInput | charactersScalarWhereInput[]
  }

  export type character_bloodpotenciesCreateNestedManyWithoutClan_compulsionsInput = {
    create?: XOR<character_bloodpotenciesCreateWithoutClan_compulsionsInput, character_bloodpotenciesUncheckedCreateWithoutClan_compulsionsInput> | character_bloodpotenciesCreateWithoutClan_compulsionsInput[] | character_bloodpotenciesUncheckedCreateWithoutClan_compulsionsInput[]
    connectOrCreate?: character_bloodpotenciesCreateOrConnectWithoutClan_compulsionsInput | character_bloodpotenciesCreateOrConnectWithoutClan_compulsionsInput[]
    createMany?: character_bloodpotenciesCreateManyClan_compulsionsInputEnvelope
    connect?: character_bloodpotenciesWhereUniqueInput | character_bloodpotenciesWhereUniqueInput[]
  }

  export type charactersCreateNestedManyWithoutClan_compulsionsInput = {
    create?: XOR<charactersCreateWithoutClan_compulsionsInput, charactersUncheckedCreateWithoutClan_compulsionsInput> | charactersCreateWithoutClan_compulsionsInput[] | charactersUncheckedCreateWithoutClan_compulsionsInput[]
    connectOrCreate?: charactersCreateOrConnectWithoutClan_compulsionsInput | charactersCreateOrConnectWithoutClan_compulsionsInput[]
    createMany?: charactersCreateManyClan_compulsionsInputEnvelope
    connect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
  }

  export type clansCreateNestedOneWithoutClan_compulsionsInput = {
    create?: XOR<clansCreateWithoutClan_compulsionsInput, clansUncheckedCreateWithoutClan_compulsionsInput>
    connectOrCreate?: clansCreateOrConnectWithoutClan_compulsionsInput
    connect?: clansWhereUniqueInput
  }

  export type character_bloodpotenciesUncheckedCreateNestedManyWithoutClan_compulsionsInput = {
    create?: XOR<character_bloodpotenciesCreateWithoutClan_compulsionsInput, character_bloodpotenciesUncheckedCreateWithoutClan_compulsionsInput> | character_bloodpotenciesCreateWithoutClan_compulsionsInput[] | character_bloodpotenciesUncheckedCreateWithoutClan_compulsionsInput[]
    connectOrCreate?: character_bloodpotenciesCreateOrConnectWithoutClan_compulsionsInput | character_bloodpotenciesCreateOrConnectWithoutClan_compulsionsInput[]
    createMany?: character_bloodpotenciesCreateManyClan_compulsionsInputEnvelope
    connect?: character_bloodpotenciesWhereUniqueInput | character_bloodpotenciesWhereUniqueInput[]
  }

  export type charactersUncheckedCreateNestedManyWithoutClan_compulsionsInput = {
    create?: XOR<charactersCreateWithoutClan_compulsionsInput, charactersUncheckedCreateWithoutClan_compulsionsInput> | charactersCreateWithoutClan_compulsionsInput[] | charactersUncheckedCreateWithoutClan_compulsionsInput[]
    connectOrCreate?: charactersCreateOrConnectWithoutClan_compulsionsInput | charactersCreateOrConnectWithoutClan_compulsionsInput[]
    createMany?: charactersCreateManyClan_compulsionsInputEnvelope
    connect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
  }

  export type character_bloodpotenciesUpdateManyWithoutClan_compulsionsNestedInput = {
    create?: XOR<character_bloodpotenciesCreateWithoutClan_compulsionsInput, character_bloodpotenciesUncheckedCreateWithoutClan_compulsionsInput> | character_bloodpotenciesCreateWithoutClan_compulsionsInput[] | character_bloodpotenciesUncheckedCreateWithoutClan_compulsionsInput[]
    connectOrCreate?: character_bloodpotenciesCreateOrConnectWithoutClan_compulsionsInput | character_bloodpotenciesCreateOrConnectWithoutClan_compulsionsInput[]
    upsert?: character_bloodpotenciesUpsertWithWhereUniqueWithoutClan_compulsionsInput | character_bloodpotenciesUpsertWithWhereUniqueWithoutClan_compulsionsInput[]
    createMany?: character_bloodpotenciesCreateManyClan_compulsionsInputEnvelope
    set?: character_bloodpotenciesWhereUniqueInput | character_bloodpotenciesWhereUniqueInput[]
    disconnect?: character_bloodpotenciesWhereUniqueInput | character_bloodpotenciesWhereUniqueInput[]
    delete?: character_bloodpotenciesWhereUniqueInput | character_bloodpotenciesWhereUniqueInput[]
    connect?: character_bloodpotenciesWhereUniqueInput | character_bloodpotenciesWhereUniqueInput[]
    update?: character_bloodpotenciesUpdateWithWhereUniqueWithoutClan_compulsionsInput | character_bloodpotenciesUpdateWithWhereUniqueWithoutClan_compulsionsInput[]
    updateMany?: character_bloodpotenciesUpdateManyWithWhereWithoutClan_compulsionsInput | character_bloodpotenciesUpdateManyWithWhereWithoutClan_compulsionsInput[]
    deleteMany?: character_bloodpotenciesScalarWhereInput | character_bloodpotenciesScalarWhereInput[]
  }

  export type charactersUpdateManyWithoutClan_compulsionsNestedInput = {
    create?: XOR<charactersCreateWithoutClan_compulsionsInput, charactersUncheckedCreateWithoutClan_compulsionsInput> | charactersCreateWithoutClan_compulsionsInput[] | charactersUncheckedCreateWithoutClan_compulsionsInput[]
    connectOrCreate?: charactersCreateOrConnectWithoutClan_compulsionsInput | charactersCreateOrConnectWithoutClan_compulsionsInput[]
    upsert?: charactersUpsertWithWhereUniqueWithoutClan_compulsionsInput | charactersUpsertWithWhereUniqueWithoutClan_compulsionsInput[]
    createMany?: charactersCreateManyClan_compulsionsInputEnvelope
    set?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    disconnect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    delete?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    connect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    update?: charactersUpdateWithWhereUniqueWithoutClan_compulsionsInput | charactersUpdateWithWhereUniqueWithoutClan_compulsionsInput[]
    updateMany?: charactersUpdateManyWithWhereWithoutClan_compulsionsInput | charactersUpdateManyWithWhereWithoutClan_compulsionsInput[]
    deleteMany?: charactersScalarWhereInput | charactersScalarWhereInput[]
  }

  export type clansUpdateOneRequiredWithoutClan_compulsionsNestedInput = {
    create?: XOR<clansCreateWithoutClan_compulsionsInput, clansUncheckedCreateWithoutClan_compulsionsInput>
    connectOrCreate?: clansCreateOrConnectWithoutClan_compulsionsInput
    upsert?: clansUpsertWithoutClan_compulsionsInput
    connect?: clansWhereUniqueInput
    update?: XOR<XOR<clansUpdateToOneWithWhereWithoutClan_compulsionsInput, clansUpdateWithoutClan_compulsionsInput>, clansUncheckedUpdateWithoutClan_compulsionsInput>
  }

  export type character_bloodpotenciesUncheckedUpdateManyWithoutClan_compulsionsNestedInput = {
    create?: XOR<character_bloodpotenciesCreateWithoutClan_compulsionsInput, character_bloodpotenciesUncheckedCreateWithoutClan_compulsionsInput> | character_bloodpotenciesCreateWithoutClan_compulsionsInput[] | character_bloodpotenciesUncheckedCreateWithoutClan_compulsionsInput[]
    connectOrCreate?: character_bloodpotenciesCreateOrConnectWithoutClan_compulsionsInput | character_bloodpotenciesCreateOrConnectWithoutClan_compulsionsInput[]
    upsert?: character_bloodpotenciesUpsertWithWhereUniqueWithoutClan_compulsionsInput | character_bloodpotenciesUpsertWithWhereUniqueWithoutClan_compulsionsInput[]
    createMany?: character_bloodpotenciesCreateManyClan_compulsionsInputEnvelope
    set?: character_bloodpotenciesWhereUniqueInput | character_bloodpotenciesWhereUniqueInput[]
    disconnect?: character_bloodpotenciesWhereUniqueInput | character_bloodpotenciesWhereUniqueInput[]
    delete?: character_bloodpotenciesWhereUniqueInput | character_bloodpotenciesWhereUniqueInput[]
    connect?: character_bloodpotenciesWhereUniqueInput | character_bloodpotenciesWhereUniqueInput[]
    update?: character_bloodpotenciesUpdateWithWhereUniqueWithoutClan_compulsionsInput | character_bloodpotenciesUpdateWithWhereUniqueWithoutClan_compulsionsInput[]
    updateMany?: character_bloodpotenciesUpdateManyWithWhereWithoutClan_compulsionsInput | character_bloodpotenciesUpdateManyWithWhereWithoutClan_compulsionsInput[]
    deleteMany?: character_bloodpotenciesScalarWhereInput | character_bloodpotenciesScalarWhereInput[]
  }

  export type charactersUncheckedUpdateManyWithoutClan_compulsionsNestedInput = {
    create?: XOR<charactersCreateWithoutClan_compulsionsInput, charactersUncheckedCreateWithoutClan_compulsionsInput> | charactersCreateWithoutClan_compulsionsInput[] | charactersUncheckedCreateWithoutClan_compulsionsInput[]
    connectOrCreate?: charactersCreateOrConnectWithoutClan_compulsionsInput | charactersCreateOrConnectWithoutClan_compulsionsInput[]
    upsert?: charactersUpsertWithWhereUniqueWithoutClan_compulsionsInput | charactersUpsertWithWhereUniqueWithoutClan_compulsionsInput[]
    createMany?: charactersCreateManyClan_compulsionsInputEnvelope
    set?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    disconnect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    delete?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    connect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    update?: charactersUpdateWithWhereUniqueWithoutClan_compulsionsInput | charactersUpdateWithWhereUniqueWithoutClan_compulsionsInput[]
    updateMany?: charactersUpdateManyWithWhereWithoutClan_compulsionsInput | charactersUpdateManyWithWhereWithoutClan_compulsionsInput[]
    deleteMany?: charactersScalarWhereInput | charactersScalarWhereInput[]
  }

  export type advantagesCreateNestedManyWithoutClansInput = {
    create?: XOR<advantagesCreateWithoutClansInput, advantagesUncheckedCreateWithoutClansInput> | advantagesCreateWithoutClansInput[] | advantagesUncheckedCreateWithoutClansInput[]
    connectOrCreate?: advantagesCreateOrConnectWithoutClansInput | advantagesCreateOrConnectWithoutClansInput[]
    createMany?: advantagesCreateManyClansInputEnvelope
    connect?: advantagesWhereUniqueInput | advantagesWhereUniqueInput[]
  }

  export type charactersCreateNestedManyWithoutClansInput = {
    create?: XOR<charactersCreateWithoutClansInput, charactersUncheckedCreateWithoutClansInput> | charactersCreateWithoutClansInput[] | charactersUncheckedCreateWithoutClansInput[]
    connectOrCreate?: charactersCreateOrConnectWithoutClansInput | charactersCreateOrConnectWithoutClansInput[]
    createMany?: charactersCreateManyClansInputEnvelope
    connect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
  }

  export type clan_banesCreateNestedManyWithoutClansInput = {
    create?: XOR<clan_banesCreateWithoutClansInput, clan_banesUncheckedCreateWithoutClansInput> | clan_banesCreateWithoutClansInput[] | clan_banesUncheckedCreateWithoutClansInput[]
    connectOrCreate?: clan_banesCreateOrConnectWithoutClansInput | clan_banesCreateOrConnectWithoutClansInput[]
    createMany?: clan_banesCreateManyClansInputEnvelope
    connect?: clan_banesWhereUniqueInput | clan_banesWhereUniqueInput[]
  }

  export type clan_compulsionsCreateNestedManyWithoutClansInput = {
    create?: XOR<clan_compulsionsCreateWithoutClansInput, clan_compulsionsUncheckedCreateWithoutClansInput> | clan_compulsionsCreateWithoutClansInput[] | clan_compulsionsUncheckedCreateWithoutClansInput[]
    connectOrCreate?: clan_compulsionsCreateOrConnectWithoutClansInput | clan_compulsionsCreateOrConnectWithoutClansInput[]
    createMany?: clan_compulsionsCreateManyClansInputEnvelope
    connect?: clan_compulsionsWhereUniqueInput | clan_compulsionsWhereUniqueInput[]
  }

  export type advantagesUncheckedCreateNestedManyWithoutClansInput = {
    create?: XOR<advantagesCreateWithoutClansInput, advantagesUncheckedCreateWithoutClansInput> | advantagesCreateWithoutClansInput[] | advantagesUncheckedCreateWithoutClansInput[]
    connectOrCreate?: advantagesCreateOrConnectWithoutClansInput | advantagesCreateOrConnectWithoutClansInput[]
    createMany?: advantagesCreateManyClansInputEnvelope
    connect?: advantagesWhereUniqueInput | advantagesWhereUniqueInput[]
  }

  export type charactersUncheckedCreateNestedManyWithoutClansInput = {
    create?: XOR<charactersCreateWithoutClansInput, charactersUncheckedCreateWithoutClansInput> | charactersCreateWithoutClansInput[] | charactersUncheckedCreateWithoutClansInput[]
    connectOrCreate?: charactersCreateOrConnectWithoutClansInput | charactersCreateOrConnectWithoutClansInput[]
    createMany?: charactersCreateManyClansInputEnvelope
    connect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
  }

  export type clan_banesUncheckedCreateNestedManyWithoutClansInput = {
    create?: XOR<clan_banesCreateWithoutClansInput, clan_banesUncheckedCreateWithoutClansInput> | clan_banesCreateWithoutClansInput[] | clan_banesUncheckedCreateWithoutClansInput[]
    connectOrCreate?: clan_banesCreateOrConnectWithoutClansInput | clan_banesCreateOrConnectWithoutClansInput[]
    createMany?: clan_banesCreateManyClansInputEnvelope
    connect?: clan_banesWhereUniqueInput | clan_banesWhereUniqueInput[]
  }

  export type clan_compulsionsUncheckedCreateNestedManyWithoutClansInput = {
    create?: XOR<clan_compulsionsCreateWithoutClansInput, clan_compulsionsUncheckedCreateWithoutClansInput> | clan_compulsionsCreateWithoutClansInput[] | clan_compulsionsUncheckedCreateWithoutClansInput[]
    connectOrCreate?: clan_compulsionsCreateOrConnectWithoutClansInput | clan_compulsionsCreateOrConnectWithoutClansInput[]
    createMany?: clan_compulsionsCreateManyClansInputEnvelope
    connect?: clan_compulsionsWhereUniqueInput | clan_compulsionsWhereUniqueInput[]
  }

  export type advantagesUpdateManyWithoutClansNestedInput = {
    create?: XOR<advantagesCreateWithoutClansInput, advantagesUncheckedCreateWithoutClansInput> | advantagesCreateWithoutClansInput[] | advantagesUncheckedCreateWithoutClansInput[]
    connectOrCreate?: advantagesCreateOrConnectWithoutClansInput | advantagesCreateOrConnectWithoutClansInput[]
    upsert?: advantagesUpsertWithWhereUniqueWithoutClansInput | advantagesUpsertWithWhereUniqueWithoutClansInput[]
    createMany?: advantagesCreateManyClansInputEnvelope
    set?: advantagesWhereUniqueInput | advantagesWhereUniqueInput[]
    disconnect?: advantagesWhereUniqueInput | advantagesWhereUniqueInput[]
    delete?: advantagesWhereUniqueInput | advantagesWhereUniqueInput[]
    connect?: advantagesWhereUniqueInput | advantagesWhereUniqueInput[]
    update?: advantagesUpdateWithWhereUniqueWithoutClansInput | advantagesUpdateWithWhereUniqueWithoutClansInput[]
    updateMany?: advantagesUpdateManyWithWhereWithoutClansInput | advantagesUpdateManyWithWhereWithoutClansInput[]
    deleteMany?: advantagesScalarWhereInput | advantagesScalarWhereInput[]
  }

  export type charactersUpdateManyWithoutClansNestedInput = {
    create?: XOR<charactersCreateWithoutClansInput, charactersUncheckedCreateWithoutClansInput> | charactersCreateWithoutClansInput[] | charactersUncheckedCreateWithoutClansInput[]
    connectOrCreate?: charactersCreateOrConnectWithoutClansInput | charactersCreateOrConnectWithoutClansInput[]
    upsert?: charactersUpsertWithWhereUniqueWithoutClansInput | charactersUpsertWithWhereUniqueWithoutClansInput[]
    createMany?: charactersCreateManyClansInputEnvelope
    set?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    disconnect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    delete?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    connect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    update?: charactersUpdateWithWhereUniqueWithoutClansInput | charactersUpdateWithWhereUniqueWithoutClansInput[]
    updateMany?: charactersUpdateManyWithWhereWithoutClansInput | charactersUpdateManyWithWhereWithoutClansInput[]
    deleteMany?: charactersScalarWhereInput | charactersScalarWhereInput[]
  }

  export type clan_banesUpdateManyWithoutClansNestedInput = {
    create?: XOR<clan_banesCreateWithoutClansInput, clan_banesUncheckedCreateWithoutClansInput> | clan_banesCreateWithoutClansInput[] | clan_banesUncheckedCreateWithoutClansInput[]
    connectOrCreate?: clan_banesCreateOrConnectWithoutClansInput | clan_banesCreateOrConnectWithoutClansInput[]
    upsert?: clan_banesUpsertWithWhereUniqueWithoutClansInput | clan_banesUpsertWithWhereUniqueWithoutClansInput[]
    createMany?: clan_banesCreateManyClansInputEnvelope
    set?: clan_banesWhereUniqueInput | clan_banesWhereUniqueInput[]
    disconnect?: clan_banesWhereUniqueInput | clan_banesWhereUniqueInput[]
    delete?: clan_banesWhereUniqueInput | clan_banesWhereUniqueInput[]
    connect?: clan_banesWhereUniqueInput | clan_banesWhereUniqueInput[]
    update?: clan_banesUpdateWithWhereUniqueWithoutClansInput | clan_banesUpdateWithWhereUniqueWithoutClansInput[]
    updateMany?: clan_banesUpdateManyWithWhereWithoutClansInput | clan_banesUpdateManyWithWhereWithoutClansInput[]
    deleteMany?: clan_banesScalarWhereInput | clan_banesScalarWhereInput[]
  }

  export type clan_compulsionsUpdateManyWithoutClansNestedInput = {
    create?: XOR<clan_compulsionsCreateWithoutClansInput, clan_compulsionsUncheckedCreateWithoutClansInput> | clan_compulsionsCreateWithoutClansInput[] | clan_compulsionsUncheckedCreateWithoutClansInput[]
    connectOrCreate?: clan_compulsionsCreateOrConnectWithoutClansInput | clan_compulsionsCreateOrConnectWithoutClansInput[]
    upsert?: clan_compulsionsUpsertWithWhereUniqueWithoutClansInput | clan_compulsionsUpsertWithWhereUniqueWithoutClansInput[]
    createMany?: clan_compulsionsCreateManyClansInputEnvelope
    set?: clan_compulsionsWhereUniqueInput | clan_compulsionsWhereUniqueInput[]
    disconnect?: clan_compulsionsWhereUniqueInput | clan_compulsionsWhereUniqueInput[]
    delete?: clan_compulsionsWhereUniqueInput | clan_compulsionsWhereUniqueInput[]
    connect?: clan_compulsionsWhereUniqueInput | clan_compulsionsWhereUniqueInput[]
    update?: clan_compulsionsUpdateWithWhereUniqueWithoutClansInput | clan_compulsionsUpdateWithWhereUniqueWithoutClansInput[]
    updateMany?: clan_compulsionsUpdateManyWithWhereWithoutClansInput | clan_compulsionsUpdateManyWithWhereWithoutClansInput[]
    deleteMany?: clan_compulsionsScalarWhereInput | clan_compulsionsScalarWhereInput[]
  }

  export type advantagesUncheckedUpdateManyWithoutClansNestedInput = {
    create?: XOR<advantagesCreateWithoutClansInput, advantagesUncheckedCreateWithoutClansInput> | advantagesCreateWithoutClansInput[] | advantagesUncheckedCreateWithoutClansInput[]
    connectOrCreate?: advantagesCreateOrConnectWithoutClansInput | advantagesCreateOrConnectWithoutClansInput[]
    upsert?: advantagesUpsertWithWhereUniqueWithoutClansInput | advantagesUpsertWithWhereUniqueWithoutClansInput[]
    createMany?: advantagesCreateManyClansInputEnvelope
    set?: advantagesWhereUniqueInput | advantagesWhereUniqueInput[]
    disconnect?: advantagesWhereUniqueInput | advantagesWhereUniqueInput[]
    delete?: advantagesWhereUniqueInput | advantagesWhereUniqueInput[]
    connect?: advantagesWhereUniqueInput | advantagesWhereUniqueInput[]
    update?: advantagesUpdateWithWhereUniqueWithoutClansInput | advantagesUpdateWithWhereUniqueWithoutClansInput[]
    updateMany?: advantagesUpdateManyWithWhereWithoutClansInput | advantagesUpdateManyWithWhereWithoutClansInput[]
    deleteMany?: advantagesScalarWhereInput | advantagesScalarWhereInput[]
  }

  export type charactersUncheckedUpdateManyWithoutClansNestedInput = {
    create?: XOR<charactersCreateWithoutClansInput, charactersUncheckedCreateWithoutClansInput> | charactersCreateWithoutClansInput[] | charactersUncheckedCreateWithoutClansInput[]
    connectOrCreate?: charactersCreateOrConnectWithoutClansInput | charactersCreateOrConnectWithoutClansInput[]
    upsert?: charactersUpsertWithWhereUniqueWithoutClansInput | charactersUpsertWithWhereUniqueWithoutClansInput[]
    createMany?: charactersCreateManyClansInputEnvelope
    set?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    disconnect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    delete?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    connect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    update?: charactersUpdateWithWhereUniqueWithoutClansInput | charactersUpdateWithWhereUniqueWithoutClansInput[]
    updateMany?: charactersUpdateManyWithWhereWithoutClansInput | charactersUpdateManyWithWhereWithoutClansInput[]
    deleteMany?: charactersScalarWhereInput | charactersScalarWhereInput[]
  }

  export type clan_banesUncheckedUpdateManyWithoutClansNestedInput = {
    create?: XOR<clan_banesCreateWithoutClansInput, clan_banesUncheckedCreateWithoutClansInput> | clan_banesCreateWithoutClansInput[] | clan_banesUncheckedCreateWithoutClansInput[]
    connectOrCreate?: clan_banesCreateOrConnectWithoutClansInput | clan_banesCreateOrConnectWithoutClansInput[]
    upsert?: clan_banesUpsertWithWhereUniqueWithoutClansInput | clan_banesUpsertWithWhereUniqueWithoutClansInput[]
    createMany?: clan_banesCreateManyClansInputEnvelope
    set?: clan_banesWhereUniqueInput | clan_banesWhereUniqueInput[]
    disconnect?: clan_banesWhereUniqueInput | clan_banesWhereUniqueInput[]
    delete?: clan_banesWhereUniqueInput | clan_banesWhereUniqueInput[]
    connect?: clan_banesWhereUniqueInput | clan_banesWhereUniqueInput[]
    update?: clan_banesUpdateWithWhereUniqueWithoutClansInput | clan_banesUpdateWithWhereUniqueWithoutClansInput[]
    updateMany?: clan_banesUpdateManyWithWhereWithoutClansInput | clan_banesUpdateManyWithWhereWithoutClansInput[]
    deleteMany?: clan_banesScalarWhereInput | clan_banesScalarWhereInput[]
  }

  export type clan_compulsionsUncheckedUpdateManyWithoutClansNestedInput = {
    create?: XOR<clan_compulsionsCreateWithoutClansInput, clan_compulsionsUncheckedCreateWithoutClansInput> | clan_compulsionsCreateWithoutClansInput[] | clan_compulsionsUncheckedCreateWithoutClansInput[]
    connectOrCreate?: clan_compulsionsCreateOrConnectWithoutClansInput | clan_compulsionsCreateOrConnectWithoutClansInput[]
    upsert?: clan_compulsionsUpsertWithWhereUniqueWithoutClansInput | clan_compulsionsUpsertWithWhereUniqueWithoutClansInput[]
    createMany?: clan_compulsionsCreateManyClansInputEnvelope
    set?: clan_compulsionsWhereUniqueInput | clan_compulsionsWhereUniqueInput[]
    disconnect?: clan_compulsionsWhereUniqueInput | clan_compulsionsWhereUniqueInput[]
    delete?: clan_compulsionsWhereUniqueInput | clan_compulsionsWhereUniqueInput[]
    connect?: clan_compulsionsWhereUniqueInput | clan_compulsionsWhereUniqueInput[]
    update?: clan_compulsionsUpdateWithWhereUniqueWithoutClansInput | clan_compulsionsUpdateWithWhereUniqueWithoutClansInput[]
    updateMany?: clan_compulsionsUpdateManyWithWhereWithoutClansInput | clan_compulsionsUpdateManyWithWhereWithoutClansInput[]
    deleteMany?: clan_compulsionsScalarWhereInput | clan_compulsionsScalarWhereInput[]
  }

  export type character_discipline_powersCreateNestedManyWithoutDiscipline_powersInput = {
    create?: XOR<character_discipline_powersCreateWithoutDiscipline_powersInput, character_discipline_powersUncheckedCreateWithoutDiscipline_powersInput> | character_discipline_powersCreateWithoutDiscipline_powersInput[] | character_discipline_powersUncheckedCreateWithoutDiscipline_powersInput[]
    connectOrCreate?: character_discipline_powersCreateOrConnectWithoutDiscipline_powersInput | character_discipline_powersCreateOrConnectWithoutDiscipline_powersInput[]
    createMany?: character_discipline_powersCreateManyDiscipline_powersInputEnvelope
    connect?: character_discipline_powersWhereUniqueInput | character_discipline_powersWhereUniqueInput[]
  }

  export type disciplinesCreateNestedOneWithoutDiscipline_powersInput = {
    create?: XOR<disciplinesCreateWithoutDiscipline_powersInput, disciplinesUncheckedCreateWithoutDiscipline_powersInput>
    connectOrCreate?: disciplinesCreateOrConnectWithoutDiscipline_powersInput
    connect?: disciplinesWhereUniqueInput
  }

  export type character_discipline_powersUncheckedCreateNestedManyWithoutDiscipline_powersInput = {
    create?: XOR<character_discipline_powersCreateWithoutDiscipline_powersInput, character_discipline_powersUncheckedCreateWithoutDiscipline_powersInput> | character_discipline_powersCreateWithoutDiscipline_powersInput[] | character_discipline_powersUncheckedCreateWithoutDiscipline_powersInput[]
    connectOrCreate?: character_discipline_powersCreateOrConnectWithoutDiscipline_powersInput | character_discipline_powersCreateOrConnectWithoutDiscipline_powersInput[]
    createMany?: character_discipline_powersCreateManyDiscipline_powersInputEnvelope
    connect?: character_discipline_powersWhereUniqueInput | character_discipline_powersWhereUniqueInput[]
  }

  export type character_discipline_powersUpdateManyWithoutDiscipline_powersNestedInput = {
    create?: XOR<character_discipline_powersCreateWithoutDiscipline_powersInput, character_discipline_powersUncheckedCreateWithoutDiscipline_powersInput> | character_discipline_powersCreateWithoutDiscipline_powersInput[] | character_discipline_powersUncheckedCreateWithoutDiscipline_powersInput[]
    connectOrCreate?: character_discipline_powersCreateOrConnectWithoutDiscipline_powersInput | character_discipline_powersCreateOrConnectWithoutDiscipline_powersInput[]
    upsert?: character_discipline_powersUpsertWithWhereUniqueWithoutDiscipline_powersInput | character_discipline_powersUpsertWithWhereUniqueWithoutDiscipline_powersInput[]
    createMany?: character_discipline_powersCreateManyDiscipline_powersInputEnvelope
    set?: character_discipline_powersWhereUniqueInput | character_discipline_powersWhereUniqueInput[]
    disconnect?: character_discipline_powersWhereUniqueInput | character_discipline_powersWhereUniqueInput[]
    delete?: character_discipline_powersWhereUniqueInput | character_discipline_powersWhereUniqueInput[]
    connect?: character_discipline_powersWhereUniqueInput | character_discipline_powersWhereUniqueInput[]
    update?: character_discipline_powersUpdateWithWhereUniqueWithoutDiscipline_powersInput | character_discipline_powersUpdateWithWhereUniqueWithoutDiscipline_powersInput[]
    updateMany?: character_discipline_powersUpdateManyWithWhereWithoutDiscipline_powersInput | character_discipline_powersUpdateManyWithWhereWithoutDiscipline_powersInput[]
    deleteMany?: character_discipline_powersScalarWhereInput | character_discipline_powersScalarWhereInput[]
  }

  export type disciplinesUpdateOneRequiredWithoutDiscipline_powersNestedInput = {
    create?: XOR<disciplinesCreateWithoutDiscipline_powersInput, disciplinesUncheckedCreateWithoutDiscipline_powersInput>
    connectOrCreate?: disciplinesCreateOrConnectWithoutDiscipline_powersInput
    upsert?: disciplinesUpsertWithoutDiscipline_powersInput
    connect?: disciplinesWhereUniqueInput
    update?: XOR<XOR<disciplinesUpdateToOneWithWhereWithoutDiscipline_powersInput, disciplinesUpdateWithoutDiscipline_powersInput>, disciplinesUncheckedUpdateWithoutDiscipline_powersInput>
  }

  export type character_discipline_powersUncheckedUpdateManyWithoutDiscipline_powersNestedInput = {
    create?: XOR<character_discipline_powersCreateWithoutDiscipline_powersInput, character_discipline_powersUncheckedCreateWithoutDiscipline_powersInput> | character_discipline_powersCreateWithoutDiscipline_powersInput[] | character_discipline_powersUncheckedCreateWithoutDiscipline_powersInput[]
    connectOrCreate?: character_discipline_powersCreateOrConnectWithoutDiscipline_powersInput | character_discipline_powersCreateOrConnectWithoutDiscipline_powersInput[]
    upsert?: character_discipline_powersUpsertWithWhereUniqueWithoutDiscipline_powersInput | character_discipline_powersUpsertWithWhereUniqueWithoutDiscipline_powersInput[]
    createMany?: character_discipline_powersCreateManyDiscipline_powersInputEnvelope
    set?: character_discipline_powersWhereUniqueInput | character_discipline_powersWhereUniqueInput[]
    disconnect?: character_discipline_powersWhereUniqueInput | character_discipline_powersWhereUniqueInput[]
    delete?: character_discipline_powersWhereUniqueInput | character_discipline_powersWhereUniqueInput[]
    connect?: character_discipline_powersWhereUniqueInput | character_discipline_powersWhereUniqueInput[]
    update?: character_discipline_powersUpdateWithWhereUniqueWithoutDiscipline_powersInput | character_discipline_powersUpdateWithWhereUniqueWithoutDiscipline_powersInput[]
    updateMany?: character_discipline_powersUpdateManyWithWhereWithoutDiscipline_powersInput | character_discipline_powersUpdateManyWithWhereWithoutDiscipline_powersInput[]
    deleteMany?: character_discipline_powersScalarWhereInput | character_discipline_powersScalarWhereInput[]
  }

  export type character_disciplinesCreateNestedManyWithoutDisciplinesInput = {
    create?: XOR<character_disciplinesCreateWithoutDisciplinesInput, character_disciplinesUncheckedCreateWithoutDisciplinesInput> | character_disciplinesCreateWithoutDisciplinesInput[] | character_disciplinesUncheckedCreateWithoutDisciplinesInput[]
    connectOrCreate?: character_disciplinesCreateOrConnectWithoutDisciplinesInput | character_disciplinesCreateOrConnectWithoutDisciplinesInput[]
    createMany?: character_disciplinesCreateManyDisciplinesInputEnvelope
    connect?: character_disciplinesWhereUniqueInput | character_disciplinesWhereUniqueInput[]
  }

  export type discipline_powersCreateNestedManyWithoutDisciplinesInput = {
    create?: XOR<discipline_powersCreateWithoutDisciplinesInput, discipline_powersUncheckedCreateWithoutDisciplinesInput> | discipline_powersCreateWithoutDisciplinesInput[] | discipline_powersUncheckedCreateWithoutDisciplinesInput[]
    connectOrCreate?: discipline_powersCreateOrConnectWithoutDisciplinesInput | discipline_powersCreateOrConnectWithoutDisciplinesInput[]
    createMany?: discipline_powersCreateManyDisciplinesInputEnvelope
    connect?: discipline_powersWhereUniqueInput | discipline_powersWhereUniqueInput[]
  }

  export type character_disciplinesUncheckedCreateNestedManyWithoutDisciplinesInput = {
    create?: XOR<character_disciplinesCreateWithoutDisciplinesInput, character_disciplinesUncheckedCreateWithoutDisciplinesInput> | character_disciplinesCreateWithoutDisciplinesInput[] | character_disciplinesUncheckedCreateWithoutDisciplinesInput[]
    connectOrCreate?: character_disciplinesCreateOrConnectWithoutDisciplinesInput | character_disciplinesCreateOrConnectWithoutDisciplinesInput[]
    createMany?: character_disciplinesCreateManyDisciplinesInputEnvelope
    connect?: character_disciplinesWhereUniqueInput | character_disciplinesWhereUniqueInput[]
  }

  export type discipline_powersUncheckedCreateNestedManyWithoutDisciplinesInput = {
    create?: XOR<discipline_powersCreateWithoutDisciplinesInput, discipline_powersUncheckedCreateWithoutDisciplinesInput> | discipline_powersCreateWithoutDisciplinesInput[] | discipline_powersUncheckedCreateWithoutDisciplinesInput[]
    connectOrCreate?: discipline_powersCreateOrConnectWithoutDisciplinesInput | discipline_powersCreateOrConnectWithoutDisciplinesInput[]
    createMany?: discipline_powersCreateManyDisciplinesInputEnvelope
    connect?: discipline_powersWhereUniqueInput | discipline_powersWhereUniqueInput[]
  }

  export type character_disciplinesUpdateManyWithoutDisciplinesNestedInput = {
    create?: XOR<character_disciplinesCreateWithoutDisciplinesInput, character_disciplinesUncheckedCreateWithoutDisciplinesInput> | character_disciplinesCreateWithoutDisciplinesInput[] | character_disciplinesUncheckedCreateWithoutDisciplinesInput[]
    connectOrCreate?: character_disciplinesCreateOrConnectWithoutDisciplinesInput | character_disciplinesCreateOrConnectWithoutDisciplinesInput[]
    upsert?: character_disciplinesUpsertWithWhereUniqueWithoutDisciplinesInput | character_disciplinesUpsertWithWhereUniqueWithoutDisciplinesInput[]
    createMany?: character_disciplinesCreateManyDisciplinesInputEnvelope
    set?: character_disciplinesWhereUniqueInput | character_disciplinesWhereUniqueInput[]
    disconnect?: character_disciplinesWhereUniqueInput | character_disciplinesWhereUniqueInput[]
    delete?: character_disciplinesWhereUniqueInput | character_disciplinesWhereUniqueInput[]
    connect?: character_disciplinesWhereUniqueInput | character_disciplinesWhereUniqueInput[]
    update?: character_disciplinesUpdateWithWhereUniqueWithoutDisciplinesInput | character_disciplinesUpdateWithWhereUniqueWithoutDisciplinesInput[]
    updateMany?: character_disciplinesUpdateManyWithWhereWithoutDisciplinesInput | character_disciplinesUpdateManyWithWhereWithoutDisciplinesInput[]
    deleteMany?: character_disciplinesScalarWhereInput | character_disciplinesScalarWhereInput[]
  }

  export type discipline_powersUpdateManyWithoutDisciplinesNestedInput = {
    create?: XOR<discipline_powersCreateWithoutDisciplinesInput, discipline_powersUncheckedCreateWithoutDisciplinesInput> | discipline_powersCreateWithoutDisciplinesInput[] | discipline_powersUncheckedCreateWithoutDisciplinesInput[]
    connectOrCreate?: discipline_powersCreateOrConnectWithoutDisciplinesInput | discipline_powersCreateOrConnectWithoutDisciplinesInput[]
    upsert?: discipline_powersUpsertWithWhereUniqueWithoutDisciplinesInput | discipline_powersUpsertWithWhereUniqueWithoutDisciplinesInput[]
    createMany?: discipline_powersCreateManyDisciplinesInputEnvelope
    set?: discipline_powersWhereUniqueInput | discipline_powersWhereUniqueInput[]
    disconnect?: discipline_powersWhereUniqueInput | discipline_powersWhereUniqueInput[]
    delete?: discipline_powersWhereUniqueInput | discipline_powersWhereUniqueInput[]
    connect?: discipline_powersWhereUniqueInput | discipline_powersWhereUniqueInput[]
    update?: discipline_powersUpdateWithWhereUniqueWithoutDisciplinesInput | discipline_powersUpdateWithWhereUniqueWithoutDisciplinesInput[]
    updateMany?: discipline_powersUpdateManyWithWhereWithoutDisciplinesInput | discipline_powersUpdateManyWithWhereWithoutDisciplinesInput[]
    deleteMany?: discipline_powersScalarWhereInput | discipline_powersScalarWhereInput[]
  }

  export type character_disciplinesUncheckedUpdateManyWithoutDisciplinesNestedInput = {
    create?: XOR<character_disciplinesCreateWithoutDisciplinesInput, character_disciplinesUncheckedCreateWithoutDisciplinesInput> | character_disciplinesCreateWithoutDisciplinesInput[] | character_disciplinesUncheckedCreateWithoutDisciplinesInput[]
    connectOrCreate?: character_disciplinesCreateOrConnectWithoutDisciplinesInput | character_disciplinesCreateOrConnectWithoutDisciplinesInput[]
    upsert?: character_disciplinesUpsertWithWhereUniqueWithoutDisciplinesInput | character_disciplinesUpsertWithWhereUniqueWithoutDisciplinesInput[]
    createMany?: character_disciplinesCreateManyDisciplinesInputEnvelope
    set?: character_disciplinesWhereUniqueInput | character_disciplinesWhereUniqueInput[]
    disconnect?: character_disciplinesWhereUniqueInput | character_disciplinesWhereUniqueInput[]
    delete?: character_disciplinesWhereUniqueInput | character_disciplinesWhereUniqueInput[]
    connect?: character_disciplinesWhereUniqueInput | character_disciplinesWhereUniqueInput[]
    update?: character_disciplinesUpdateWithWhereUniqueWithoutDisciplinesInput | character_disciplinesUpdateWithWhereUniqueWithoutDisciplinesInput[]
    updateMany?: character_disciplinesUpdateManyWithWhereWithoutDisciplinesInput | character_disciplinesUpdateManyWithWhereWithoutDisciplinesInput[]
    deleteMany?: character_disciplinesScalarWhereInput | character_disciplinesScalarWhereInput[]
  }

  export type discipline_powersUncheckedUpdateManyWithoutDisciplinesNestedInput = {
    create?: XOR<discipline_powersCreateWithoutDisciplinesInput, discipline_powersUncheckedCreateWithoutDisciplinesInput> | discipline_powersCreateWithoutDisciplinesInput[] | discipline_powersUncheckedCreateWithoutDisciplinesInput[]
    connectOrCreate?: discipline_powersCreateOrConnectWithoutDisciplinesInput | discipline_powersCreateOrConnectWithoutDisciplinesInput[]
    upsert?: discipline_powersUpsertWithWhereUniqueWithoutDisciplinesInput | discipline_powersUpsertWithWhereUniqueWithoutDisciplinesInput[]
    createMany?: discipline_powersCreateManyDisciplinesInputEnvelope
    set?: discipline_powersWhereUniqueInput | discipline_powersWhereUniqueInput[]
    disconnect?: discipline_powersWhereUniqueInput | discipline_powersWhereUniqueInput[]
    delete?: discipline_powersWhereUniqueInput | discipline_powersWhereUniqueInput[]
    connect?: discipline_powersWhereUniqueInput | discipline_powersWhereUniqueInput[]
    update?: discipline_powersUpdateWithWhereUniqueWithoutDisciplinesInput | discipline_powersUpdateWithWhereUniqueWithoutDisciplinesInput[]
    updateMany?: discipline_powersUpdateManyWithWhereWithoutDisciplinesInput | discipline_powersUpdateManyWithWhereWithoutDisciplinesInput[]
    deleteMany?: discipline_powersScalarWhereInput | discipline_powersScalarWhereInput[]
  }

  export type charactersCreateNestedOneWithoutExp_logsInput = {
    create?: XOR<charactersCreateWithoutExp_logsInput, charactersUncheckedCreateWithoutExp_logsInput>
    connectOrCreate?: charactersCreateOrConnectWithoutExp_logsInput
    connect?: charactersWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutExp_logsInput = {
    create?: XOR<usersCreateWithoutExp_logsInput, usersUncheckedCreateWithoutExp_logsInput>
    connectOrCreate?: usersCreateOrConnectWithoutExp_logsInput
    connect?: usersWhereUniqueInput
  }

  export type charactersUpdateOneRequiredWithoutExp_logsNestedInput = {
    create?: XOR<charactersCreateWithoutExp_logsInput, charactersUncheckedCreateWithoutExp_logsInput>
    connectOrCreate?: charactersCreateOrConnectWithoutExp_logsInput
    upsert?: charactersUpsertWithoutExp_logsInput
    connect?: charactersWhereUniqueInput
    update?: XOR<XOR<charactersUpdateToOneWithWhereWithoutExp_logsInput, charactersUpdateWithoutExp_logsInput>, charactersUncheckedUpdateWithoutExp_logsInput>
  }

  export type usersUpdateOneRequiredWithoutExp_logsNestedInput = {
    create?: XOR<usersCreateWithoutExp_logsInput, usersUncheckedCreateWithoutExp_logsInput>
    connectOrCreate?: usersCreateOrConnectWithoutExp_logsInput
    upsert?: usersUpsertWithoutExp_logsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutExp_logsInput, usersUpdateWithoutExp_logsInput>, usersUncheckedUpdateWithoutExp_logsInput>
  }

  export type charactersCreateNestedManyWithoutPredator_typesInput = {
    create?: XOR<charactersCreateWithoutPredator_typesInput, charactersUncheckedCreateWithoutPredator_typesInput> | charactersCreateWithoutPredator_typesInput[] | charactersUncheckedCreateWithoutPredator_typesInput[]
    connectOrCreate?: charactersCreateOrConnectWithoutPredator_typesInput | charactersCreateOrConnectWithoutPredator_typesInput[]
    createMany?: charactersCreateManyPredator_typesInputEnvelope
    connect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
  }

  export type charactersUncheckedCreateNestedManyWithoutPredator_typesInput = {
    create?: XOR<charactersCreateWithoutPredator_typesInput, charactersUncheckedCreateWithoutPredator_typesInput> | charactersCreateWithoutPredator_typesInput[] | charactersUncheckedCreateWithoutPredator_typesInput[]
    connectOrCreate?: charactersCreateOrConnectWithoutPredator_typesInput | charactersCreateOrConnectWithoutPredator_typesInput[]
    createMany?: charactersCreateManyPredator_typesInputEnvelope
    connect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
  }

  export type charactersUpdateManyWithoutPredator_typesNestedInput = {
    create?: XOR<charactersCreateWithoutPredator_typesInput, charactersUncheckedCreateWithoutPredator_typesInput> | charactersCreateWithoutPredator_typesInput[] | charactersUncheckedCreateWithoutPredator_typesInput[]
    connectOrCreate?: charactersCreateOrConnectWithoutPredator_typesInput | charactersCreateOrConnectWithoutPredator_typesInput[]
    upsert?: charactersUpsertWithWhereUniqueWithoutPredator_typesInput | charactersUpsertWithWhereUniqueWithoutPredator_typesInput[]
    createMany?: charactersCreateManyPredator_typesInputEnvelope
    set?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    disconnect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    delete?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    connect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    update?: charactersUpdateWithWhereUniqueWithoutPredator_typesInput | charactersUpdateWithWhereUniqueWithoutPredator_typesInput[]
    updateMany?: charactersUpdateManyWithWhereWithoutPredator_typesInput | charactersUpdateManyWithWhereWithoutPredator_typesInput[]
    deleteMany?: charactersScalarWhereInput | charactersScalarWhereInput[]
  }

  export type charactersUncheckedUpdateManyWithoutPredator_typesNestedInput = {
    create?: XOR<charactersCreateWithoutPredator_typesInput, charactersUncheckedCreateWithoutPredator_typesInput> | charactersCreateWithoutPredator_typesInput[] | charactersUncheckedCreateWithoutPredator_typesInput[]
    connectOrCreate?: charactersCreateOrConnectWithoutPredator_typesInput | charactersCreateOrConnectWithoutPredator_typesInput[]
    upsert?: charactersUpsertWithWhereUniqueWithoutPredator_typesInput | charactersUpsertWithWhereUniqueWithoutPredator_typesInput[]
    createMany?: charactersCreateManyPredator_typesInputEnvelope
    set?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    disconnect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    delete?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    connect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    update?: charactersUpdateWithWhereUniqueWithoutPredator_typesInput | charactersUpdateWithWhereUniqueWithoutPredator_typesInput[]
    updateMany?: charactersUpdateManyWithWhereWithoutPredator_typesInput | charactersUpdateManyWithWhereWithoutPredator_typesInput[]
    deleteMany?: charactersScalarWhereInput | charactersScalarWhereInput[]
  }

  export type character_ritualsCreateNestedManyWithoutRitualsInput = {
    create?: XOR<character_ritualsCreateWithoutRitualsInput, character_ritualsUncheckedCreateWithoutRitualsInput> | character_ritualsCreateWithoutRitualsInput[] | character_ritualsUncheckedCreateWithoutRitualsInput[]
    connectOrCreate?: character_ritualsCreateOrConnectWithoutRitualsInput | character_ritualsCreateOrConnectWithoutRitualsInput[]
    createMany?: character_ritualsCreateManyRitualsInputEnvelope
    connect?: character_ritualsWhereUniqueInput | character_ritualsWhereUniqueInput[]
  }

  export type character_ritualsUncheckedCreateNestedManyWithoutRitualsInput = {
    create?: XOR<character_ritualsCreateWithoutRitualsInput, character_ritualsUncheckedCreateWithoutRitualsInput> | character_ritualsCreateWithoutRitualsInput[] | character_ritualsUncheckedCreateWithoutRitualsInput[]
    connectOrCreate?: character_ritualsCreateOrConnectWithoutRitualsInput | character_ritualsCreateOrConnectWithoutRitualsInput[]
    createMany?: character_ritualsCreateManyRitualsInputEnvelope
    connect?: character_ritualsWhereUniqueInput | character_ritualsWhereUniqueInput[]
  }

  export type character_ritualsUpdateManyWithoutRitualsNestedInput = {
    create?: XOR<character_ritualsCreateWithoutRitualsInput, character_ritualsUncheckedCreateWithoutRitualsInput> | character_ritualsCreateWithoutRitualsInput[] | character_ritualsUncheckedCreateWithoutRitualsInput[]
    connectOrCreate?: character_ritualsCreateOrConnectWithoutRitualsInput | character_ritualsCreateOrConnectWithoutRitualsInput[]
    upsert?: character_ritualsUpsertWithWhereUniqueWithoutRitualsInput | character_ritualsUpsertWithWhereUniqueWithoutRitualsInput[]
    createMany?: character_ritualsCreateManyRitualsInputEnvelope
    set?: character_ritualsWhereUniqueInput | character_ritualsWhereUniqueInput[]
    disconnect?: character_ritualsWhereUniqueInput | character_ritualsWhereUniqueInput[]
    delete?: character_ritualsWhereUniqueInput | character_ritualsWhereUniqueInput[]
    connect?: character_ritualsWhereUniqueInput | character_ritualsWhereUniqueInput[]
    update?: character_ritualsUpdateWithWhereUniqueWithoutRitualsInput | character_ritualsUpdateWithWhereUniqueWithoutRitualsInput[]
    updateMany?: character_ritualsUpdateManyWithWhereWithoutRitualsInput | character_ritualsUpdateManyWithWhereWithoutRitualsInput[]
    deleteMany?: character_ritualsScalarWhereInput | character_ritualsScalarWhereInput[]
  }

  export type character_ritualsUncheckedUpdateManyWithoutRitualsNestedInput = {
    create?: XOR<character_ritualsCreateWithoutRitualsInput, character_ritualsUncheckedCreateWithoutRitualsInput> | character_ritualsCreateWithoutRitualsInput[] | character_ritualsUncheckedCreateWithoutRitualsInput[]
    connectOrCreate?: character_ritualsCreateOrConnectWithoutRitualsInput | character_ritualsCreateOrConnectWithoutRitualsInput[]
    upsert?: character_ritualsUpsertWithWhereUniqueWithoutRitualsInput | character_ritualsUpsertWithWhereUniqueWithoutRitualsInput[]
    createMany?: character_ritualsCreateManyRitualsInputEnvelope
    set?: character_ritualsWhereUniqueInput | character_ritualsWhereUniqueInput[]
    disconnect?: character_ritualsWhereUniqueInput | character_ritualsWhereUniqueInput[]
    delete?: character_ritualsWhereUniqueInput | character_ritualsWhereUniqueInput[]
    connect?: character_ritualsWhereUniqueInput | character_ritualsWhereUniqueInput[]
    update?: character_ritualsUpdateWithWhereUniqueWithoutRitualsInput | character_ritualsUpdateWithWhereUniqueWithoutRitualsInput[]
    updateMany?: character_ritualsUpdateManyWithWhereWithoutRitualsInput | character_ritualsUpdateManyWithWhereWithoutRitualsInput[]
    deleteMany?: character_ritualsScalarWhereInput | character_ritualsScalarWhereInput[]
  }

  export type advantagesCreateNestedManyWithoutSectsInput = {
    create?: XOR<advantagesCreateWithoutSectsInput, advantagesUncheckedCreateWithoutSectsInput> | advantagesCreateWithoutSectsInput[] | advantagesUncheckedCreateWithoutSectsInput[]
    connectOrCreate?: advantagesCreateOrConnectWithoutSectsInput | advantagesCreateOrConnectWithoutSectsInput[]
    createMany?: advantagesCreateManySectsInputEnvelope
    connect?: advantagesWhereUniqueInput | advantagesWhereUniqueInput[]
  }

  export type charactersCreateNestedManyWithoutSectsInput = {
    create?: XOR<charactersCreateWithoutSectsInput, charactersUncheckedCreateWithoutSectsInput> | charactersCreateWithoutSectsInput[] | charactersUncheckedCreateWithoutSectsInput[]
    connectOrCreate?: charactersCreateOrConnectWithoutSectsInput | charactersCreateOrConnectWithoutSectsInput[]
    createMany?: charactersCreateManySectsInputEnvelope
    connect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
  }

  export type advantagesUncheckedCreateNestedManyWithoutSectsInput = {
    create?: XOR<advantagesCreateWithoutSectsInput, advantagesUncheckedCreateWithoutSectsInput> | advantagesCreateWithoutSectsInput[] | advantagesUncheckedCreateWithoutSectsInput[]
    connectOrCreate?: advantagesCreateOrConnectWithoutSectsInput | advantagesCreateOrConnectWithoutSectsInput[]
    createMany?: advantagesCreateManySectsInputEnvelope
    connect?: advantagesWhereUniqueInput | advantagesWhereUniqueInput[]
  }

  export type charactersUncheckedCreateNestedManyWithoutSectsInput = {
    create?: XOR<charactersCreateWithoutSectsInput, charactersUncheckedCreateWithoutSectsInput> | charactersCreateWithoutSectsInput[] | charactersUncheckedCreateWithoutSectsInput[]
    connectOrCreate?: charactersCreateOrConnectWithoutSectsInput | charactersCreateOrConnectWithoutSectsInput[]
    createMany?: charactersCreateManySectsInputEnvelope
    connect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
  }

  export type advantagesUpdateManyWithoutSectsNestedInput = {
    create?: XOR<advantagesCreateWithoutSectsInput, advantagesUncheckedCreateWithoutSectsInput> | advantagesCreateWithoutSectsInput[] | advantagesUncheckedCreateWithoutSectsInput[]
    connectOrCreate?: advantagesCreateOrConnectWithoutSectsInput | advantagesCreateOrConnectWithoutSectsInput[]
    upsert?: advantagesUpsertWithWhereUniqueWithoutSectsInput | advantagesUpsertWithWhereUniqueWithoutSectsInput[]
    createMany?: advantagesCreateManySectsInputEnvelope
    set?: advantagesWhereUniqueInput | advantagesWhereUniqueInput[]
    disconnect?: advantagesWhereUniqueInput | advantagesWhereUniqueInput[]
    delete?: advantagesWhereUniqueInput | advantagesWhereUniqueInput[]
    connect?: advantagesWhereUniqueInput | advantagesWhereUniqueInput[]
    update?: advantagesUpdateWithWhereUniqueWithoutSectsInput | advantagesUpdateWithWhereUniqueWithoutSectsInput[]
    updateMany?: advantagesUpdateManyWithWhereWithoutSectsInput | advantagesUpdateManyWithWhereWithoutSectsInput[]
    deleteMany?: advantagesScalarWhereInput | advantagesScalarWhereInput[]
  }

  export type charactersUpdateManyWithoutSectsNestedInput = {
    create?: XOR<charactersCreateWithoutSectsInput, charactersUncheckedCreateWithoutSectsInput> | charactersCreateWithoutSectsInput[] | charactersUncheckedCreateWithoutSectsInput[]
    connectOrCreate?: charactersCreateOrConnectWithoutSectsInput | charactersCreateOrConnectWithoutSectsInput[]
    upsert?: charactersUpsertWithWhereUniqueWithoutSectsInput | charactersUpsertWithWhereUniqueWithoutSectsInput[]
    createMany?: charactersCreateManySectsInputEnvelope
    set?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    disconnect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    delete?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    connect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    update?: charactersUpdateWithWhereUniqueWithoutSectsInput | charactersUpdateWithWhereUniqueWithoutSectsInput[]
    updateMany?: charactersUpdateManyWithWhereWithoutSectsInput | charactersUpdateManyWithWhereWithoutSectsInput[]
    deleteMany?: charactersScalarWhereInput | charactersScalarWhereInput[]
  }

  export type advantagesUncheckedUpdateManyWithoutSectsNestedInput = {
    create?: XOR<advantagesCreateWithoutSectsInput, advantagesUncheckedCreateWithoutSectsInput> | advantagesCreateWithoutSectsInput[] | advantagesUncheckedCreateWithoutSectsInput[]
    connectOrCreate?: advantagesCreateOrConnectWithoutSectsInput | advantagesCreateOrConnectWithoutSectsInput[]
    upsert?: advantagesUpsertWithWhereUniqueWithoutSectsInput | advantagesUpsertWithWhereUniqueWithoutSectsInput[]
    createMany?: advantagesCreateManySectsInputEnvelope
    set?: advantagesWhereUniqueInput | advantagesWhereUniqueInput[]
    disconnect?: advantagesWhereUniqueInput | advantagesWhereUniqueInput[]
    delete?: advantagesWhereUniqueInput | advantagesWhereUniqueInput[]
    connect?: advantagesWhereUniqueInput | advantagesWhereUniqueInput[]
    update?: advantagesUpdateWithWhereUniqueWithoutSectsInput | advantagesUpdateWithWhereUniqueWithoutSectsInput[]
    updateMany?: advantagesUpdateManyWithWhereWithoutSectsInput | advantagesUpdateManyWithWhereWithoutSectsInput[]
    deleteMany?: advantagesScalarWhereInput | advantagesScalarWhereInput[]
  }

  export type charactersUncheckedUpdateManyWithoutSectsNestedInput = {
    create?: XOR<charactersCreateWithoutSectsInput, charactersUncheckedCreateWithoutSectsInput> | charactersCreateWithoutSectsInput[] | charactersUncheckedCreateWithoutSectsInput[]
    connectOrCreate?: charactersCreateOrConnectWithoutSectsInput | charactersCreateOrConnectWithoutSectsInput[]
    upsert?: charactersUpsertWithWhereUniqueWithoutSectsInput | charactersUpsertWithWhereUniqueWithoutSectsInput[]
    createMany?: charactersCreateManySectsInputEnvelope
    set?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    disconnect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    delete?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    connect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    update?: charactersUpdateWithWhereUniqueWithoutSectsInput | charactersUpdateWithWhereUniqueWithoutSectsInput[]
    updateMany?: charactersUpdateManyWithWhereWithoutSectsInput | charactersUpdateManyWithWhereWithoutSectsInput[]
    deleteMany?: charactersScalarWhereInput | charactersScalarWhereInput[]
  }

  export type character_skillsCreateNestedManyWithoutSkillsInput = {
    create?: XOR<character_skillsCreateWithoutSkillsInput, character_skillsUncheckedCreateWithoutSkillsInput> | character_skillsCreateWithoutSkillsInput[] | character_skillsUncheckedCreateWithoutSkillsInput[]
    connectOrCreate?: character_skillsCreateOrConnectWithoutSkillsInput | character_skillsCreateOrConnectWithoutSkillsInput[]
    createMany?: character_skillsCreateManySkillsInputEnvelope
    connect?: character_skillsWhereUniqueInput | character_skillsWhereUniqueInput[]
  }

  export type character_specialtiesCreateNestedManyWithoutSkillsInput = {
    create?: XOR<character_specialtiesCreateWithoutSkillsInput, character_specialtiesUncheckedCreateWithoutSkillsInput> | character_specialtiesCreateWithoutSkillsInput[] | character_specialtiesUncheckedCreateWithoutSkillsInput[]
    connectOrCreate?: character_specialtiesCreateOrConnectWithoutSkillsInput | character_specialtiesCreateOrConnectWithoutSkillsInput[]
    createMany?: character_specialtiesCreateManySkillsInputEnvelope
    connect?: character_specialtiesWhereUniqueInput | character_specialtiesWhereUniqueInput[]
  }

  export type character_skillsUncheckedCreateNestedManyWithoutSkillsInput = {
    create?: XOR<character_skillsCreateWithoutSkillsInput, character_skillsUncheckedCreateWithoutSkillsInput> | character_skillsCreateWithoutSkillsInput[] | character_skillsUncheckedCreateWithoutSkillsInput[]
    connectOrCreate?: character_skillsCreateOrConnectWithoutSkillsInput | character_skillsCreateOrConnectWithoutSkillsInput[]
    createMany?: character_skillsCreateManySkillsInputEnvelope
    connect?: character_skillsWhereUniqueInput | character_skillsWhereUniqueInput[]
  }

  export type character_specialtiesUncheckedCreateNestedManyWithoutSkillsInput = {
    create?: XOR<character_specialtiesCreateWithoutSkillsInput, character_specialtiesUncheckedCreateWithoutSkillsInput> | character_specialtiesCreateWithoutSkillsInput[] | character_specialtiesUncheckedCreateWithoutSkillsInput[]
    connectOrCreate?: character_specialtiesCreateOrConnectWithoutSkillsInput | character_specialtiesCreateOrConnectWithoutSkillsInput[]
    createMany?: character_specialtiesCreateManySkillsInputEnvelope
    connect?: character_specialtiesWhereUniqueInput | character_specialtiesWhereUniqueInput[]
  }

  export type character_skillsUpdateManyWithoutSkillsNestedInput = {
    create?: XOR<character_skillsCreateWithoutSkillsInput, character_skillsUncheckedCreateWithoutSkillsInput> | character_skillsCreateWithoutSkillsInput[] | character_skillsUncheckedCreateWithoutSkillsInput[]
    connectOrCreate?: character_skillsCreateOrConnectWithoutSkillsInput | character_skillsCreateOrConnectWithoutSkillsInput[]
    upsert?: character_skillsUpsertWithWhereUniqueWithoutSkillsInput | character_skillsUpsertWithWhereUniqueWithoutSkillsInput[]
    createMany?: character_skillsCreateManySkillsInputEnvelope
    set?: character_skillsWhereUniqueInput | character_skillsWhereUniqueInput[]
    disconnect?: character_skillsWhereUniqueInput | character_skillsWhereUniqueInput[]
    delete?: character_skillsWhereUniqueInput | character_skillsWhereUniqueInput[]
    connect?: character_skillsWhereUniqueInput | character_skillsWhereUniqueInput[]
    update?: character_skillsUpdateWithWhereUniqueWithoutSkillsInput | character_skillsUpdateWithWhereUniqueWithoutSkillsInput[]
    updateMany?: character_skillsUpdateManyWithWhereWithoutSkillsInput | character_skillsUpdateManyWithWhereWithoutSkillsInput[]
    deleteMany?: character_skillsScalarWhereInput | character_skillsScalarWhereInput[]
  }

  export type character_specialtiesUpdateManyWithoutSkillsNestedInput = {
    create?: XOR<character_specialtiesCreateWithoutSkillsInput, character_specialtiesUncheckedCreateWithoutSkillsInput> | character_specialtiesCreateWithoutSkillsInput[] | character_specialtiesUncheckedCreateWithoutSkillsInput[]
    connectOrCreate?: character_specialtiesCreateOrConnectWithoutSkillsInput | character_specialtiesCreateOrConnectWithoutSkillsInput[]
    upsert?: character_specialtiesUpsertWithWhereUniqueWithoutSkillsInput | character_specialtiesUpsertWithWhereUniqueWithoutSkillsInput[]
    createMany?: character_specialtiesCreateManySkillsInputEnvelope
    set?: character_specialtiesWhereUniqueInput | character_specialtiesWhereUniqueInput[]
    disconnect?: character_specialtiesWhereUniqueInput | character_specialtiesWhereUniqueInput[]
    delete?: character_specialtiesWhereUniqueInput | character_specialtiesWhereUniqueInput[]
    connect?: character_specialtiesWhereUniqueInput | character_specialtiesWhereUniqueInput[]
    update?: character_specialtiesUpdateWithWhereUniqueWithoutSkillsInput | character_specialtiesUpdateWithWhereUniqueWithoutSkillsInput[]
    updateMany?: character_specialtiesUpdateManyWithWhereWithoutSkillsInput | character_specialtiesUpdateManyWithWhereWithoutSkillsInput[]
    deleteMany?: character_specialtiesScalarWhereInput | character_specialtiesScalarWhereInput[]
  }

  export type character_skillsUncheckedUpdateManyWithoutSkillsNestedInput = {
    create?: XOR<character_skillsCreateWithoutSkillsInput, character_skillsUncheckedCreateWithoutSkillsInput> | character_skillsCreateWithoutSkillsInput[] | character_skillsUncheckedCreateWithoutSkillsInput[]
    connectOrCreate?: character_skillsCreateOrConnectWithoutSkillsInput | character_skillsCreateOrConnectWithoutSkillsInput[]
    upsert?: character_skillsUpsertWithWhereUniqueWithoutSkillsInput | character_skillsUpsertWithWhereUniqueWithoutSkillsInput[]
    createMany?: character_skillsCreateManySkillsInputEnvelope
    set?: character_skillsWhereUniqueInput | character_skillsWhereUniqueInput[]
    disconnect?: character_skillsWhereUniqueInput | character_skillsWhereUniqueInput[]
    delete?: character_skillsWhereUniqueInput | character_skillsWhereUniqueInput[]
    connect?: character_skillsWhereUniqueInput | character_skillsWhereUniqueInput[]
    update?: character_skillsUpdateWithWhereUniqueWithoutSkillsInput | character_skillsUpdateWithWhereUniqueWithoutSkillsInput[]
    updateMany?: character_skillsUpdateManyWithWhereWithoutSkillsInput | character_skillsUpdateManyWithWhereWithoutSkillsInput[]
    deleteMany?: character_skillsScalarWhereInput | character_skillsScalarWhereInput[]
  }

  export type character_specialtiesUncheckedUpdateManyWithoutSkillsNestedInput = {
    create?: XOR<character_specialtiesCreateWithoutSkillsInput, character_specialtiesUncheckedCreateWithoutSkillsInput> | character_specialtiesCreateWithoutSkillsInput[] | character_specialtiesUncheckedCreateWithoutSkillsInput[]
    connectOrCreate?: character_specialtiesCreateOrConnectWithoutSkillsInput | character_specialtiesCreateOrConnectWithoutSkillsInput[]
    upsert?: character_specialtiesUpsertWithWhereUniqueWithoutSkillsInput | character_specialtiesUpsertWithWhereUniqueWithoutSkillsInput[]
    createMany?: character_specialtiesCreateManySkillsInputEnvelope
    set?: character_specialtiesWhereUniqueInput | character_specialtiesWhereUniqueInput[]
    disconnect?: character_specialtiesWhereUniqueInput | character_specialtiesWhereUniqueInput[]
    delete?: character_specialtiesWhereUniqueInput | character_specialtiesWhereUniqueInput[]
    connect?: character_specialtiesWhereUniqueInput | character_specialtiesWhereUniqueInput[]
    update?: character_specialtiesUpdateWithWhereUniqueWithoutSkillsInput | character_specialtiesUpdateWithWhereUniqueWithoutSkillsInput[]
    updateMany?: character_specialtiesUpdateManyWithWhereWithoutSkillsInput | character_specialtiesUpdateManyWithWhereWithoutSkillsInput[]
    deleteMany?: character_specialtiesScalarWhereInput | character_specialtiesScalarWhereInput[]
  }

  export type char_groupsCreateNestedManyWithoutUsersInput = {
    create?: XOR<char_groupsCreateWithoutUsersInput, char_groupsUncheckedCreateWithoutUsersInput> | char_groupsCreateWithoutUsersInput[] | char_groupsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: char_groupsCreateOrConnectWithoutUsersInput | char_groupsCreateOrConnectWithoutUsersInput[]
    createMany?: char_groupsCreateManyUsersInputEnvelope
    connect?: char_groupsWhereUniqueInput | char_groupsWhereUniqueInput[]
  }

  export type charactersCreateNestedManyWithoutUsersInput = {
    create?: XOR<charactersCreateWithoutUsersInput, charactersUncheckedCreateWithoutUsersInput> | charactersCreateWithoutUsersInput[] | charactersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: charactersCreateOrConnectWithoutUsersInput | charactersCreateOrConnectWithoutUsersInput[]
    createMany?: charactersCreateManyUsersInputEnvelope
    connect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
  }

  export type chroniclesCreateNestedManyWithoutUsersInput = {
    create?: XOR<chroniclesCreateWithoutUsersInput, chroniclesUncheckedCreateWithoutUsersInput> | chroniclesCreateWithoutUsersInput[] | chroniclesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: chroniclesCreateOrConnectWithoutUsersInput | chroniclesCreateOrConnectWithoutUsersInput[]
    createMany?: chroniclesCreateManyUsersInputEnvelope
    connect?: chroniclesWhereUniqueInput | chroniclesWhereUniqueInput[]
  }

  export type exp_logsCreateNestedManyWithoutUsersInput = {
    create?: XOR<exp_logsCreateWithoutUsersInput, exp_logsUncheckedCreateWithoutUsersInput> | exp_logsCreateWithoutUsersInput[] | exp_logsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: exp_logsCreateOrConnectWithoutUsersInput | exp_logsCreateOrConnectWithoutUsersInput[]
    createMany?: exp_logsCreateManyUsersInputEnvelope
    connect?: exp_logsWhereUniqueInput | exp_logsWhereUniqueInput[]
  }

  export type char_groupsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<char_groupsCreateWithoutUsersInput, char_groupsUncheckedCreateWithoutUsersInput> | char_groupsCreateWithoutUsersInput[] | char_groupsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: char_groupsCreateOrConnectWithoutUsersInput | char_groupsCreateOrConnectWithoutUsersInput[]
    createMany?: char_groupsCreateManyUsersInputEnvelope
    connect?: char_groupsWhereUniqueInput | char_groupsWhereUniqueInput[]
  }

  export type charactersUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<charactersCreateWithoutUsersInput, charactersUncheckedCreateWithoutUsersInput> | charactersCreateWithoutUsersInput[] | charactersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: charactersCreateOrConnectWithoutUsersInput | charactersCreateOrConnectWithoutUsersInput[]
    createMany?: charactersCreateManyUsersInputEnvelope
    connect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
  }

  export type chroniclesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<chroniclesCreateWithoutUsersInput, chroniclesUncheckedCreateWithoutUsersInput> | chroniclesCreateWithoutUsersInput[] | chroniclesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: chroniclesCreateOrConnectWithoutUsersInput | chroniclesCreateOrConnectWithoutUsersInput[]
    createMany?: chroniclesCreateManyUsersInputEnvelope
    connect?: chroniclesWhereUniqueInput | chroniclesWhereUniqueInput[]
  }

  export type exp_logsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<exp_logsCreateWithoutUsersInput, exp_logsUncheckedCreateWithoutUsersInput> | exp_logsCreateWithoutUsersInput[] | exp_logsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: exp_logsCreateOrConnectWithoutUsersInput | exp_logsCreateOrConnectWithoutUsersInput[]
    createMany?: exp_logsCreateManyUsersInputEnvelope
    connect?: exp_logsWhereUniqueInput | exp_logsWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type char_groupsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<char_groupsCreateWithoutUsersInput, char_groupsUncheckedCreateWithoutUsersInput> | char_groupsCreateWithoutUsersInput[] | char_groupsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: char_groupsCreateOrConnectWithoutUsersInput | char_groupsCreateOrConnectWithoutUsersInput[]
    upsert?: char_groupsUpsertWithWhereUniqueWithoutUsersInput | char_groupsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: char_groupsCreateManyUsersInputEnvelope
    set?: char_groupsWhereUniqueInput | char_groupsWhereUniqueInput[]
    disconnect?: char_groupsWhereUniqueInput | char_groupsWhereUniqueInput[]
    delete?: char_groupsWhereUniqueInput | char_groupsWhereUniqueInput[]
    connect?: char_groupsWhereUniqueInput | char_groupsWhereUniqueInput[]
    update?: char_groupsUpdateWithWhereUniqueWithoutUsersInput | char_groupsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: char_groupsUpdateManyWithWhereWithoutUsersInput | char_groupsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: char_groupsScalarWhereInput | char_groupsScalarWhereInput[]
  }

  export type charactersUpdateManyWithoutUsersNestedInput = {
    create?: XOR<charactersCreateWithoutUsersInput, charactersUncheckedCreateWithoutUsersInput> | charactersCreateWithoutUsersInput[] | charactersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: charactersCreateOrConnectWithoutUsersInput | charactersCreateOrConnectWithoutUsersInput[]
    upsert?: charactersUpsertWithWhereUniqueWithoutUsersInput | charactersUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: charactersCreateManyUsersInputEnvelope
    set?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    disconnect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    delete?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    connect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    update?: charactersUpdateWithWhereUniqueWithoutUsersInput | charactersUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: charactersUpdateManyWithWhereWithoutUsersInput | charactersUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: charactersScalarWhereInput | charactersScalarWhereInput[]
  }

  export type chroniclesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<chroniclesCreateWithoutUsersInput, chroniclesUncheckedCreateWithoutUsersInput> | chroniclesCreateWithoutUsersInput[] | chroniclesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: chroniclesCreateOrConnectWithoutUsersInput | chroniclesCreateOrConnectWithoutUsersInput[]
    upsert?: chroniclesUpsertWithWhereUniqueWithoutUsersInput | chroniclesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: chroniclesCreateManyUsersInputEnvelope
    set?: chroniclesWhereUniqueInput | chroniclesWhereUniqueInput[]
    disconnect?: chroniclesWhereUniqueInput | chroniclesWhereUniqueInput[]
    delete?: chroniclesWhereUniqueInput | chroniclesWhereUniqueInput[]
    connect?: chroniclesWhereUniqueInput | chroniclesWhereUniqueInput[]
    update?: chroniclesUpdateWithWhereUniqueWithoutUsersInput | chroniclesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: chroniclesUpdateManyWithWhereWithoutUsersInput | chroniclesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: chroniclesScalarWhereInput | chroniclesScalarWhereInput[]
  }

  export type exp_logsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<exp_logsCreateWithoutUsersInput, exp_logsUncheckedCreateWithoutUsersInput> | exp_logsCreateWithoutUsersInput[] | exp_logsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: exp_logsCreateOrConnectWithoutUsersInput | exp_logsCreateOrConnectWithoutUsersInput[]
    upsert?: exp_logsUpsertWithWhereUniqueWithoutUsersInput | exp_logsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: exp_logsCreateManyUsersInputEnvelope
    set?: exp_logsWhereUniqueInput | exp_logsWhereUniqueInput[]
    disconnect?: exp_logsWhereUniqueInput | exp_logsWhereUniqueInput[]
    delete?: exp_logsWhereUniqueInput | exp_logsWhereUniqueInput[]
    connect?: exp_logsWhereUniqueInput | exp_logsWhereUniqueInput[]
    update?: exp_logsUpdateWithWhereUniqueWithoutUsersInput | exp_logsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: exp_logsUpdateManyWithWhereWithoutUsersInput | exp_logsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: exp_logsScalarWhereInput | exp_logsScalarWhereInput[]
  }

  export type char_groupsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<char_groupsCreateWithoutUsersInput, char_groupsUncheckedCreateWithoutUsersInput> | char_groupsCreateWithoutUsersInput[] | char_groupsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: char_groupsCreateOrConnectWithoutUsersInput | char_groupsCreateOrConnectWithoutUsersInput[]
    upsert?: char_groupsUpsertWithWhereUniqueWithoutUsersInput | char_groupsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: char_groupsCreateManyUsersInputEnvelope
    set?: char_groupsWhereUniqueInput | char_groupsWhereUniqueInput[]
    disconnect?: char_groupsWhereUniqueInput | char_groupsWhereUniqueInput[]
    delete?: char_groupsWhereUniqueInput | char_groupsWhereUniqueInput[]
    connect?: char_groupsWhereUniqueInput | char_groupsWhereUniqueInput[]
    update?: char_groupsUpdateWithWhereUniqueWithoutUsersInput | char_groupsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: char_groupsUpdateManyWithWhereWithoutUsersInput | char_groupsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: char_groupsScalarWhereInput | char_groupsScalarWhereInput[]
  }

  export type charactersUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<charactersCreateWithoutUsersInput, charactersUncheckedCreateWithoutUsersInput> | charactersCreateWithoutUsersInput[] | charactersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: charactersCreateOrConnectWithoutUsersInput | charactersCreateOrConnectWithoutUsersInput[]
    upsert?: charactersUpsertWithWhereUniqueWithoutUsersInput | charactersUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: charactersCreateManyUsersInputEnvelope
    set?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    disconnect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    delete?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    connect?: charactersWhereUniqueInput | charactersWhereUniqueInput[]
    update?: charactersUpdateWithWhereUniqueWithoutUsersInput | charactersUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: charactersUpdateManyWithWhereWithoutUsersInput | charactersUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: charactersScalarWhereInput | charactersScalarWhereInput[]
  }

  export type chroniclesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<chroniclesCreateWithoutUsersInput, chroniclesUncheckedCreateWithoutUsersInput> | chroniclesCreateWithoutUsersInput[] | chroniclesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: chroniclesCreateOrConnectWithoutUsersInput | chroniclesCreateOrConnectWithoutUsersInput[]
    upsert?: chroniclesUpsertWithWhereUniqueWithoutUsersInput | chroniclesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: chroniclesCreateManyUsersInputEnvelope
    set?: chroniclesWhereUniqueInput | chroniclesWhereUniqueInput[]
    disconnect?: chroniclesWhereUniqueInput | chroniclesWhereUniqueInput[]
    delete?: chroniclesWhereUniqueInput | chroniclesWhereUniqueInput[]
    connect?: chroniclesWhereUniqueInput | chroniclesWhereUniqueInput[]
    update?: chroniclesUpdateWithWhereUniqueWithoutUsersInput | chroniclesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: chroniclesUpdateManyWithWhereWithoutUsersInput | chroniclesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: chroniclesScalarWhereInput | chroniclesScalarWhereInput[]
  }

  export type exp_logsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<exp_logsCreateWithoutUsersInput, exp_logsUncheckedCreateWithoutUsersInput> | exp_logsCreateWithoutUsersInput[] | exp_logsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: exp_logsCreateOrConnectWithoutUsersInput | exp_logsCreateOrConnectWithoutUsersInput[]
    upsert?: exp_logsUpsertWithWhereUniqueWithoutUsersInput | exp_logsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: exp_logsCreateManyUsersInputEnvelope
    set?: exp_logsWhereUniqueInput | exp_logsWhereUniqueInput[]
    disconnect?: exp_logsWhereUniqueInput | exp_logsWhereUniqueInput[]
    delete?: exp_logsWhereUniqueInput | exp_logsWhereUniqueInput[]
    connect?: exp_logsWhereUniqueInput | exp_logsWhereUniqueInput[]
    update?: exp_logsUpdateWithWhereUniqueWithoutUsersInput | exp_logsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: exp_logsUpdateManyWithWhereWithoutUsersInput | exp_logsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: exp_logsScalarWhereInput | exp_logsScalarWhereInput[]
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumtypeFilter<$PrismaModel = never> = {
    equals?: $Enums.type | EnumtypeFieldRefInput<$PrismaModel>
    in?: $Enums.type[] | ListEnumtypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.type[] | ListEnumtypeFieldRefInput<$PrismaModel>
    not?: NestedEnumtypeFilter<$PrismaModel> | $Enums.type
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumforWhomFilter<$PrismaModel = never> = {
    equals?: $Enums.forWhom | EnumforWhomFieldRefInput<$PrismaModel>
    in?: $Enums.forWhom[] | ListEnumforWhomFieldRefInput<$PrismaModel>
    notIn?: $Enums.forWhom[] | ListEnumforWhomFieldRefInput<$PrismaModel>
    not?: NestedEnumforWhomFilter<$PrismaModel> | $Enums.forWhom
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumtypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.type | EnumtypeFieldRefInput<$PrismaModel>
    in?: $Enums.type[] | ListEnumtypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.type[] | ListEnumtypeFieldRefInput<$PrismaModel>
    not?: NestedEnumtypeWithAggregatesFilter<$PrismaModel> | $Enums.type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumtypeFilter<$PrismaModel>
    _max?: NestedEnumtypeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumforWhomWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.forWhom | EnumforWhomFieldRefInput<$PrismaModel>
    in?: $Enums.forWhom[] | ListEnumforWhomFieldRefInput<$PrismaModel>
    notIn?: $Enums.forWhom[] | ListEnumforWhomFieldRefInput<$PrismaModel>
    not?: NestedEnumforWhomWithAggregatesFilter<$PrismaModel> | $Enums.forWhom
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumforWhomFilter<$PrismaModel>
    _max?: NestedEnumforWhomFilter<$PrismaModel>
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumcategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.category | EnumcategoryFieldRefInput<$PrismaModel>
    in?: $Enums.category[] | ListEnumcategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.category[] | ListEnumcategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumcategoryFilter<$PrismaModel> | $Enums.category
  }

  export type NestedEnumcategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.category | EnumcategoryFieldRefInput<$PrismaModel>
    in?: $Enums.category[] | ListEnumcategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.category[] | ListEnumcategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumcategoryWithAggregatesFilter<$PrismaModel> | $Enums.category
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumcategoryFilter<$PrismaModel>
    _max?: NestedEnumcategoryFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumEntityFilter<$PrismaModel = never> = {
    equals?: $Enums.Entity | EnumEntityFieldRefInput<$PrismaModel>
    in?: $Enums.Entity[] | ListEnumEntityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Entity[] | ListEnumEntityFieldRefInput<$PrismaModel>
    not?: NestedEnumEntityFilter<$PrismaModel> | $Enums.Entity
  }

  export type NestedEnumEntityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Entity | EnumEntityFieldRefInput<$PrismaModel>
    in?: $Enums.Entity[] | ListEnumEntityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Entity[] | ListEnumEntityFieldRefInput<$PrismaModel>
    not?: NestedEnumEntityWithAggregatesFilter<$PrismaModel> | $Enums.Entity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEntityFilter<$PrismaModel>
    _max?: NestedEnumEntityFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type clansCreateWithoutAdvantagesInput = {
    id?: string
    name: string
    description: string
    characters?: charactersCreateNestedManyWithoutClansInput
    clan_banes?: clan_banesCreateNestedManyWithoutClansInput
    clan_compulsions?: clan_compulsionsCreateNestedManyWithoutClansInput
  }

  export type clansUncheckedCreateWithoutAdvantagesInput = {
    id?: string
    name: string
    description: string
    characters?: charactersUncheckedCreateNestedManyWithoutClansInput
    clan_banes?: clan_banesUncheckedCreateNestedManyWithoutClansInput
    clan_compulsions?: clan_compulsionsUncheckedCreateNestedManyWithoutClansInput
  }

  export type clansCreateOrConnectWithoutAdvantagesInput = {
    where: clansWhereUniqueInput
    create: XOR<clansCreateWithoutAdvantagesInput, clansUncheckedCreateWithoutAdvantagesInput>
  }

  export type sectsCreateWithoutAdvantagesInput = {
    id?: string
    name: string
    description: string
    characters?: charactersCreateNestedManyWithoutSectsInput
  }

  export type sectsUncheckedCreateWithoutAdvantagesInput = {
    id?: string
    name: string
    description: string
    characters?: charactersUncheckedCreateNestedManyWithoutSectsInput
  }

  export type sectsCreateOrConnectWithoutAdvantagesInput = {
    where: sectsWhereUniqueInput
    create: XOR<sectsCreateWithoutAdvantagesInput, sectsUncheckedCreateWithoutAdvantagesInput>
  }

  export type character_advantagesCreateWithoutAdvantagesInput = {
    id?: string
    characters: charactersCreateNestedOneWithoutCharacter_advantagesInput
  }

  export type character_advantagesUncheckedCreateWithoutAdvantagesInput = {
    id?: string
    char_id: string
  }

  export type character_advantagesCreateOrConnectWithoutAdvantagesInput = {
    where: character_advantagesWhereUniqueInput
    create: XOR<character_advantagesCreateWithoutAdvantagesInput, character_advantagesUncheckedCreateWithoutAdvantagesInput>
  }

  export type character_advantagesCreateManyAdvantagesInputEnvelope = {
    data: character_advantagesCreateManyAdvantagesInput | character_advantagesCreateManyAdvantagesInput[]
    skipDuplicates?: boolean
  }

  export type clansUpsertWithoutAdvantagesInput = {
    update: XOR<clansUpdateWithoutAdvantagesInput, clansUncheckedUpdateWithoutAdvantagesInput>
    create: XOR<clansCreateWithoutAdvantagesInput, clansUncheckedCreateWithoutAdvantagesInput>
    where?: clansWhereInput
  }

  export type clansUpdateToOneWithWhereWithoutAdvantagesInput = {
    where?: clansWhereInput
    data: XOR<clansUpdateWithoutAdvantagesInput, clansUncheckedUpdateWithoutAdvantagesInput>
  }

  export type clansUpdateWithoutAdvantagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    characters?: charactersUpdateManyWithoutClansNestedInput
    clan_banes?: clan_banesUpdateManyWithoutClansNestedInput
    clan_compulsions?: clan_compulsionsUpdateManyWithoutClansNestedInput
  }

  export type clansUncheckedUpdateWithoutAdvantagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    characters?: charactersUncheckedUpdateManyWithoutClansNestedInput
    clan_banes?: clan_banesUncheckedUpdateManyWithoutClansNestedInput
    clan_compulsions?: clan_compulsionsUncheckedUpdateManyWithoutClansNestedInput
  }

  export type sectsUpsertWithoutAdvantagesInput = {
    update: XOR<sectsUpdateWithoutAdvantagesInput, sectsUncheckedUpdateWithoutAdvantagesInput>
    create: XOR<sectsCreateWithoutAdvantagesInput, sectsUncheckedCreateWithoutAdvantagesInput>
    where?: sectsWhereInput
  }

  export type sectsUpdateToOneWithWhereWithoutAdvantagesInput = {
    where?: sectsWhereInput
    data: XOR<sectsUpdateWithoutAdvantagesInput, sectsUncheckedUpdateWithoutAdvantagesInput>
  }

  export type sectsUpdateWithoutAdvantagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    characters?: charactersUpdateManyWithoutSectsNestedInput
  }

  export type sectsUncheckedUpdateWithoutAdvantagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    characters?: charactersUncheckedUpdateManyWithoutSectsNestedInput
  }

  export type character_advantagesUpsertWithWhereUniqueWithoutAdvantagesInput = {
    where: character_advantagesWhereUniqueInput
    update: XOR<character_advantagesUpdateWithoutAdvantagesInput, character_advantagesUncheckedUpdateWithoutAdvantagesInput>
    create: XOR<character_advantagesCreateWithoutAdvantagesInput, character_advantagesUncheckedCreateWithoutAdvantagesInput>
  }

  export type character_advantagesUpdateWithWhereUniqueWithoutAdvantagesInput = {
    where: character_advantagesWhereUniqueInput
    data: XOR<character_advantagesUpdateWithoutAdvantagesInput, character_advantagesUncheckedUpdateWithoutAdvantagesInput>
  }

  export type character_advantagesUpdateManyWithWhereWithoutAdvantagesInput = {
    where: character_advantagesScalarWhereInput
    data: XOR<character_advantagesUpdateManyMutationInput, character_advantagesUncheckedUpdateManyWithoutAdvantagesInput>
  }

  export type character_advantagesScalarWhereInput = {
    AND?: character_advantagesScalarWhereInput | character_advantagesScalarWhereInput[]
    OR?: character_advantagesScalarWhereInput[]
    NOT?: character_advantagesScalarWhereInput | character_advantagesScalarWhereInput[]
    id?: UuidFilter<"character_advantages"> | string
    char_id?: UuidFilter<"character_advantages"> | string
    advantage_id?: UuidFilter<"character_advantages"> | string
  }

  export type character_alchemy_powersCreateWithoutAlchemy_powersInput = {
    id?: string
    characters: charactersCreateNestedOneWithoutCharacter_alchemy_powersInput
  }

  export type character_alchemy_powersUncheckedCreateWithoutAlchemy_powersInput = {
    id?: string
    char_id: string
  }

  export type character_alchemy_powersCreateOrConnectWithoutAlchemy_powersInput = {
    where: character_alchemy_powersWhereUniqueInput
    create: XOR<character_alchemy_powersCreateWithoutAlchemy_powersInput, character_alchemy_powersUncheckedCreateWithoutAlchemy_powersInput>
  }

  export type character_alchemy_powersCreateManyAlchemy_powersInputEnvelope = {
    data: character_alchemy_powersCreateManyAlchemy_powersInput | character_alchemy_powersCreateManyAlchemy_powersInput[]
    skipDuplicates?: boolean
  }

  export type character_alchemy_powersUpsertWithWhereUniqueWithoutAlchemy_powersInput = {
    where: character_alchemy_powersWhereUniqueInput
    update: XOR<character_alchemy_powersUpdateWithoutAlchemy_powersInput, character_alchemy_powersUncheckedUpdateWithoutAlchemy_powersInput>
    create: XOR<character_alchemy_powersCreateWithoutAlchemy_powersInput, character_alchemy_powersUncheckedCreateWithoutAlchemy_powersInput>
  }

  export type character_alchemy_powersUpdateWithWhereUniqueWithoutAlchemy_powersInput = {
    where: character_alchemy_powersWhereUniqueInput
    data: XOR<character_alchemy_powersUpdateWithoutAlchemy_powersInput, character_alchemy_powersUncheckedUpdateWithoutAlchemy_powersInput>
  }

  export type character_alchemy_powersUpdateManyWithWhereWithoutAlchemy_powersInput = {
    where: character_alchemy_powersScalarWhereInput
    data: XOR<character_alchemy_powersUpdateManyMutationInput, character_alchemy_powersUncheckedUpdateManyWithoutAlchemy_powersInput>
  }

  export type character_alchemy_powersScalarWhereInput = {
    AND?: character_alchemy_powersScalarWhereInput | character_alchemy_powersScalarWhereInput[]
    OR?: character_alchemy_powersScalarWhereInput[]
    NOT?: character_alchemy_powersScalarWhereInput | character_alchemy_powersScalarWhereInput[]
    id?: UuidFilter<"character_alchemy_powers"> | string
    char_id?: UuidFilter<"character_alchemy_powers"> | string
    alchemy_power_id?: UuidFilter<"character_alchemy_powers"> | string
  }

  export type character_attributesCreateWithoutAttributesInput = {
    id?: string
    level?: number
    characters: charactersCreateNestedOneWithoutCharacter_attributesInput
  }

  export type character_attributesUncheckedCreateWithoutAttributesInput = {
    id?: string
    char_id: string
    level?: number
  }

  export type character_attributesCreateOrConnectWithoutAttributesInput = {
    where: character_attributesWhereUniqueInput
    create: XOR<character_attributesCreateWithoutAttributesInput, character_attributesUncheckedCreateWithoutAttributesInput>
  }

  export type character_attributesCreateManyAttributesInputEnvelope = {
    data: character_attributesCreateManyAttributesInput | character_attributesCreateManyAttributesInput[]
    skipDuplicates?: boolean
  }

  export type character_attributesUpsertWithWhereUniqueWithoutAttributesInput = {
    where: character_attributesWhereUniqueInput
    update: XOR<character_attributesUpdateWithoutAttributesInput, character_attributesUncheckedUpdateWithoutAttributesInput>
    create: XOR<character_attributesCreateWithoutAttributesInput, character_attributesUncheckedCreateWithoutAttributesInput>
  }

  export type character_attributesUpdateWithWhereUniqueWithoutAttributesInput = {
    where: character_attributesWhereUniqueInput
    data: XOR<character_attributesUpdateWithoutAttributesInput, character_attributesUncheckedUpdateWithoutAttributesInput>
  }

  export type character_attributesUpdateManyWithWhereWithoutAttributesInput = {
    where: character_attributesScalarWhereInput
    data: XOR<character_attributesUpdateManyMutationInput, character_attributesUncheckedUpdateManyWithoutAttributesInput>
  }

  export type character_attributesScalarWhereInput = {
    AND?: character_attributesScalarWhereInput | character_attributesScalarWhereInput[]
    OR?: character_attributesScalarWhereInput[]
    NOT?: character_attributesScalarWhereInput | character_attributesScalarWhereInput[]
    id?: UuidFilter<"character_attributes"> | string
    char_id?: UuidFilter<"character_attributes"> | string
    attribute_id?: UuidFilter<"character_attributes"> | string
    level?: IntFilter<"character_attributes"> | number
  }

  export type character_bloodpotenciesCreateWithoutBlood_potencyInput = {
    id?: string
    blood_surge?: string | null
    bane_severity?: number | null
    power_bonus?: string | null
    feeding_penalty?: string | null
    mend_amount?: number | null
    rc_reroll?: string | null
    characters: charactersCreateNestedOneWithoutCharacter_bloodpotenciesInput
    clan_compulsions?: clan_compulsionsCreateNestedOneWithoutCharacter_bloodpotenciesInput
    clan_banes?: clan_banesCreateNestedOneWithoutCharacter_bloodpotenciesInput
  }

  export type character_bloodpotenciesUncheckedCreateWithoutBlood_potencyInput = {
    id?: string
    char_id: string
    blood_surge?: string | null
    bane_severity?: number | null
    power_bonus?: string | null
    feeding_penalty?: string | null
    mend_amount?: number | null
    rc_reroll?: string | null
    clane_bane?: string | null
    clan_compulsion?: string | null
  }

  export type character_bloodpotenciesCreateOrConnectWithoutBlood_potencyInput = {
    where: character_bloodpotenciesWhereUniqueInput
    create: XOR<character_bloodpotenciesCreateWithoutBlood_potencyInput, character_bloodpotenciesUncheckedCreateWithoutBlood_potencyInput>
  }

  export type character_bloodpotenciesCreateManyBlood_potencyInputEnvelope = {
    data: character_bloodpotenciesCreateManyBlood_potencyInput | character_bloodpotenciesCreateManyBlood_potencyInput[]
    skipDuplicates?: boolean
  }

  export type character_bloodpotenciesUpsertWithWhereUniqueWithoutBlood_potencyInput = {
    where: character_bloodpotenciesWhereUniqueInput
    update: XOR<character_bloodpotenciesUpdateWithoutBlood_potencyInput, character_bloodpotenciesUncheckedUpdateWithoutBlood_potencyInput>
    create: XOR<character_bloodpotenciesCreateWithoutBlood_potencyInput, character_bloodpotenciesUncheckedCreateWithoutBlood_potencyInput>
  }

  export type character_bloodpotenciesUpdateWithWhereUniqueWithoutBlood_potencyInput = {
    where: character_bloodpotenciesWhereUniqueInput
    data: XOR<character_bloodpotenciesUpdateWithoutBlood_potencyInput, character_bloodpotenciesUncheckedUpdateWithoutBlood_potencyInput>
  }

  export type character_bloodpotenciesUpdateManyWithWhereWithoutBlood_potencyInput = {
    where: character_bloodpotenciesScalarWhereInput
    data: XOR<character_bloodpotenciesUpdateManyMutationInput, character_bloodpotenciesUncheckedUpdateManyWithoutBlood_potencyInput>
  }

  export type character_bloodpotenciesScalarWhereInput = {
    AND?: character_bloodpotenciesScalarWhereInput | character_bloodpotenciesScalarWhereInput[]
    OR?: character_bloodpotenciesScalarWhereInput[]
    NOT?: character_bloodpotenciesScalarWhereInput | character_bloodpotenciesScalarWhereInput[]
    id?: UuidFilter<"character_bloodpotencies"> | string
    char_id?: UuidFilter<"character_bloodpotencies"> | string
    blood_potency_level?: UuidNullableFilter<"character_bloodpotencies"> | string | null
    blood_surge?: StringNullableFilter<"character_bloodpotencies"> | string | null
    bane_severity?: IntNullableFilter<"character_bloodpotencies"> | number | null
    power_bonus?: StringNullableFilter<"character_bloodpotencies"> | string | null
    feeding_penalty?: StringNullableFilter<"character_bloodpotencies"> | string | null
    mend_amount?: IntNullableFilter<"character_bloodpotencies"> | number | null
    rc_reroll?: StringNullableFilter<"character_bloodpotencies"> | string | null
    clane_bane?: UuidNullableFilter<"character_bloodpotencies"> | string | null
    clan_compulsion?: UuidNullableFilter<"character_bloodpotencies"> | string | null
  }

  export type char_groupsCreateWithoutOther_char_groupsInput = {
    id?: string
    name: string
    description: string
    char_groups?: char_groupsCreateNestedOneWithoutOther_char_groupsInput
    users: usersCreateNestedOneWithoutChar_groupsInput
    characters?: charactersCreateNestedManyWithoutChar_groupsInput
  }

  export type char_groupsUncheckedCreateWithoutOther_char_groupsInput = {
    id?: string
    user_id: string
    parent_id?: string | null
    name: string
    description: string
    characters?: charactersUncheckedCreateNestedManyWithoutChar_groupsInput
  }

  export type char_groupsCreateOrConnectWithoutOther_char_groupsInput = {
    where: char_groupsWhereUniqueInput
    create: XOR<char_groupsCreateWithoutOther_char_groupsInput, char_groupsUncheckedCreateWithoutOther_char_groupsInput>
  }

  export type char_groupsCreateWithoutChar_groupsInput = {
    id?: string
    name: string
    description: string
    other_char_groups?: char_groupsCreateNestedManyWithoutChar_groupsInput
    users: usersCreateNestedOneWithoutChar_groupsInput
    characters?: charactersCreateNestedManyWithoutChar_groupsInput
  }

  export type char_groupsUncheckedCreateWithoutChar_groupsInput = {
    id?: string
    user_id: string
    name: string
    description: string
    other_char_groups?: char_groupsUncheckedCreateNestedManyWithoutChar_groupsInput
    characters?: charactersUncheckedCreateNestedManyWithoutChar_groupsInput
  }

  export type char_groupsCreateOrConnectWithoutChar_groupsInput = {
    where: char_groupsWhereUniqueInput
    create: XOR<char_groupsCreateWithoutChar_groupsInput, char_groupsUncheckedCreateWithoutChar_groupsInput>
  }

  export type char_groupsCreateManyChar_groupsInputEnvelope = {
    data: char_groupsCreateManyChar_groupsInput | char_groupsCreateManyChar_groupsInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutChar_groupsInput = {
    id?: string
    clerk_user_id: string
    email: string
    name: string
    image_url?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    characters?: charactersCreateNestedManyWithoutUsersInput
    chronicles?: chroniclesCreateNestedManyWithoutUsersInput
    exp_logs?: exp_logsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutChar_groupsInput = {
    id?: string
    clerk_user_id: string
    email: string
    name: string
    image_url?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    characters?: charactersUncheckedCreateNestedManyWithoutUsersInput
    chronicles?: chroniclesUncheckedCreateNestedManyWithoutUsersInput
    exp_logs?: exp_logsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutChar_groupsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutChar_groupsInput, usersUncheckedCreateWithoutChar_groupsInput>
  }

  export type charactersCreateWithoutChar_groupsInput = {
    id?: string
    name: string
    player: string
    generation: number
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesCreateNestedManyWithoutCharactersInput
    character_alchemy_powers?: character_alchemy_powersCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersCreateNestedManyWithoutCharactersInput
    chronicles?: chroniclesCreateNestedOneWithoutCharactersInput
    clan_banes?: clan_banesCreateNestedOneWithoutCharactersInput
    clan_compulsions?: clan_compulsionsCreateNestedOneWithoutCharactersInput
    clans?: clansCreateNestedOneWithoutCharactersInput
    predator_types: predator_typesCreateNestedOneWithoutCharactersInput
    sects?: sectsCreateNestedOneWithoutCharactersInput
    users: usersCreateNestedOneWithoutCharactersInput
    exp_logs?: exp_logsCreateNestedManyWithoutCharactersInput
  }

  export type charactersUncheckedCreateWithoutChar_groupsInput = {
    id?: string
    user_id: string
    name: string
    clan_id?: string | null
    clan_bane?: string | null
    clan_compulsion?: string | null
    sect_id?: string | null
    player: string
    predator_type: string
    generation: number
    chronicle_id?: string | null
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesUncheckedCreateNestedManyWithoutCharactersInput
    character_alchemy_powers?: character_alchemy_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesUncheckedCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesUncheckedCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsUncheckedCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityUncheckedCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileUncheckedCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsUncheckedCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsUncheckedCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesUncheckedCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersUncheckedCreateNestedManyWithoutCharactersInput
    exp_logs?: exp_logsUncheckedCreateNestedManyWithoutCharactersInput
  }

  export type charactersCreateOrConnectWithoutChar_groupsInput = {
    where: charactersWhereUniqueInput
    create: XOR<charactersCreateWithoutChar_groupsInput, charactersUncheckedCreateWithoutChar_groupsInput>
  }

  export type charactersCreateManyChar_groupsInputEnvelope = {
    data: charactersCreateManyChar_groupsInput | charactersCreateManyChar_groupsInput[]
    skipDuplicates?: boolean
  }

  export type char_groupsUpsertWithoutOther_char_groupsInput = {
    update: XOR<char_groupsUpdateWithoutOther_char_groupsInput, char_groupsUncheckedUpdateWithoutOther_char_groupsInput>
    create: XOR<char_groupsCreateWithoutOther_char_groupsInput, char_groupsUncheckedCreateWithoutOther_char_groupsInput>
    where?: char_groupsWhereInput
  }

  export type char_groupsUpdateToOneWithWhereWithoutOther_char_groupsInput = {
    where?: char_groupsWhereInput
    data: XOR<char_groupsUpdateWithoutOther_char_groupsInput, char_groupsUncheckedUpdateWithoutOther_char_groupsInput>
  }

  export type char_groupsUpdateWithoutOther_char_groupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    char_groups?: char_groupsUpdateOneWithoutOther_char_groupsNestedInput
    users?: usersUpdateOneRequiredWithoutChar_groupsNestedInput
    characters?: charactersUpdateManyWithoutChar_groupsNestedInput
  }

  export type char_groupsUncheckedUpdateWithoutOther_char_groupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    characters?: charactersUncheckedUpdateManyWithoutChar_groupsNestedInput
  }

  export type char_groupsUpsertWithWhereUniqueWithoutChar_groupsInput = {
    where: char_groupsWhereUniqueInput
    update: XOR<char_groupsUpdateWithoutChar_groupsInput, char_groupsUncheckedUpdateWithoutChar_groupsInput>
    create: XOR<char_groupsCreateWithoutChar_groupsInput, char_groupsUncheckedCreateWithoutChar_groupsInput>
  }

  export type char_groupsUpdateWithWhereUniqueWithoutChar_groupsInput = {
    where: char_groupsWhereUniqueInput
    data: XOR<char_groupsUpdateWithoutChar_groupsInput, char_groupsUncheckedUpdateWithoutChar_groupsInput>
  }

  export type char_groupsUpdateManyWithWhereWithoutChar_groupsInput = {
    where: char_groupsScalarWhereInput
    data: XOR<char_groupsUpdateManyMutationInput, char_groupsUncheckedUpdateManyWithoutChar_groupsInput>
  }

  export type char_groupsScalarWhereInput = {
    AND?: char_groupsScalarWhereInput | char_groupsScalarWhereInput[]
    OR?: char_groupsScalarWhereInput[]
    NOT?: char_groupsScalarWhereInput | char_groupsScalarWhereInput[]
    id?: UuidFilter<"char_groups"> | string
    user_id?: UuidFilter<"char_groups"> | string
    parent_id?: UuidNullableFilter<"char_groups"> | string | null
    name?: StringFilter<"char_groups"> | string
    description?: StringFilter<"char_groups"> | string
  }

  export type usersUpsertWithoutChar_groupsInput = {
    update: XOR<usersUpdateWithoutChar_groupsInput, usersUncheckedUpdateWithoutChar_groupsInput>
    create: XOR<usersCreateWithoutChar_groupsInput, usersUncheckedCreateWithoutChar_groupsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutChar_groupsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutChar_groupsInput, usersUncheckedUpdateWithoutChar_groupsInput>
  }

  export type usersUpdateWithoutChar_groupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerk_user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    characters?: charactersUpdateManyWithoutUsersNestedInput
    chronicles?: chroniclesUpdateManyWithoutUsersNestedInput
    exp_logs?: exp_logsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutChar_groupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerk_user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    characters?: charactersUncheckedUpdateManyWithoutUsersNestedInput
    chronicles?: chroniclesUncheckedUpdateManyWithoutUsersNestedInput
    exp_logs?: exp_logsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type charactersUpsertWithWhereUniqueWithoutChar_groupsInput = {
    where: charactersWhereUniqueInput
    update: XOR<charactersUpdateWithoutChar_groupsInput, charactersUncheckedUpdateWithoutChar_groupsInput>
    create: XOR<charactersCreateWithoutChar_groupsInput, charactersUncheckedCreateWithoutChar_groupsInput>
  }

  export type charactersUpdateWithWhereUniqueWithoutChar_groupsInput = {
    where: charactersWhereUniqueInput
    data: XOR<charactersUpdateWithoutChar_groupsInput, charactersUncheckedUpdateWithoutChar_groupsInput>
  }

  export type charactersUpdateManyWithWhereWithoutChar_groupsInput = {
    where: charactersScalarWhereInput
    data: XOR<charactersUpdateManyMutationInput, charactersUncheckedUpdateManyWithoutChar_groupsInput>
  }

  export type charactersScalarWhereInput = {
    AND?: charactersScalarWhereInput | charactersScalarWhereInput[]
    OR?: charactersScalarWhereInput[]
    NOT?: charactersScalarWhereInput | charactersScalarWhereInput[]
    id?: UuidFilter<"characters"> | string
    user_id?: UuidFilter<"characters"> | string
    name?: StringFilter<"characters"> | string
    clan_id?: UuidNullableFilter<"characters"> | string | null
    clan_bane?: UuidNullableFilter<"characters"> | string | null
    clan_compulsion?: UuidNullableFilter<"characters"> | string | null
    sect_id?: UuidNullableFilter<"characters"> | string | null
    player?: StringFilter<"characters"> | string
    predator_type?: UuidFilter<"characters"> | string
    generation?: IntFilter<"characters"> | number
    chronicle_id?: UuidNullableFilter<"characters"> | string | null
    custom_chronicle?: StringNullableFilter<"characters"> | string | null
    ambition?: StringFilter<"characters"> | string
    desire?: StringFilter<"characters"> | string
    sire?: StringFilter<"characters"> | string
    total_experience?: IntFilter<"characters"> | number
    chronicle_tenets?: StringFilter<"characters"> | string
    group_id?: UuidFilter<"characters"> | string
    type?: EnumEntityFilter<"characters"> | $Enums.Entity
  }

  export type advantagesCreateWithoutCharacter_advantagesInput = {
    id?: string
    parent_name?: string | null
    name: string
    description: string
    type: $Enums.type
    level: number
    for: $Enums.forWhom
    clans?: clansCreateNestedOneWithoutAdvantagesInput
    sects?: sectsCreateNestedOneWithoutAdvantagesInput
  }

  export type advantagesUncheckedCreateWithoutCharacter_advantagesInput = {
    id?: string
    parent_name?: string | null
    name: string
    description: string
    type: $Enums.type
    level: number
    for: $Enums.forWhom
    clan_req?: string | null
    sect_req?: string | null
  }

  export type advantagesCreateOrConnectWithoutCharacter_advantagesInput = {
    where: advantagesWhereUniqueInput
    create: XOR<advantagesCreateWithoutCharacter_advantagesInput, advantagesUncheckedCreateWithoutCharacter_advantagesInput>
  }

  export type charactersCreateWithoutCharacter_advantagesInput = {
    id?: string
    name: string
    player: string
    generation: number
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    type?: $Enums.Entity
    character_alchemy_powers?: character_alchemy_powersCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersCreateNestedManyWithoutCharactersInput
    chronicles?: chroniclesCreateNestedOneWithoutCharactersInput
    clan_banes?: clan_banesCreateNestedOneWithoutCharactersInput
    clan_compulsions?: clan_compulsionsCreateNestedOneWithoutCharactersInput
    clans?: clansCreateNestedOneWithoutCharactersInput
    char_groups: char_groupsCreateNestedOneWithoutCharactersInput
    predator_types: predator_typesCreateNestedOneWithoutCharactersInput
    sects?: sectsCreateNestedOneWithoutCharactersInput
    users: usersCreateNestedOneWithoutCharactersInput
    exp_logs?: exp_logsCreateNestedManyWithoutCharactersInput
  }

  export type charactersUncheckedCreateWithoutCharacter_advantagesInput = {
    id?: string
    user_id: string
    name: string
    clan_id?: string | null
    clan_bane?: string | null
    clan_compulsion?: string | null
    sect_id?: string | null
    player: string
    predator_type: string
    generation: number
    chronicle_id?: string | null
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    group_id: string
    type?: $Enums.Entity
    character_alchemy_powers?: character_alchemy_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesUncheckedCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesUncheckedCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsUncheckedCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityUncheckedCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileUncheckedCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsUncheckedCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsUncheckedCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesUncheckedCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersUncheckedCreateNestedManyWithoutCharactersInput
    exp_logs?: exp_logsUncheckedCreateNestedManyWithoutCharactersInput
  }

  export type charactersCreateOrConnectWithoutCharacter_advantagesInput = {
    where: charactersWhereUniqueInput
    create: XOR<charactersCreateWithoutCharacter_advantagesInput, charactersUncheckedCreateWithoutCharacter_advantagesInput>
  }

  export type advantagesUpsertWithoutCharacter_advantagesInput = {
    update: XOR<advantagesUpdateWithoutCharacter_advantagesInput, advantagesUncheckedUpdateWithoutCharacter_advantagesInput>
    create: XOR<advantagesCreateWithoutCharacter_advantagesInput, advantagesUncheckedCreateWithoutCharacter_advantagesInput>
    where?: advantagesWhereInput
  }

  export type advantagesUpdateToOneWithWhereWithoutCharacter_advantagesInput = {
    where?: advantagesWhereInput
    data: XOR<advantagesUpdateWithoutCharacter_advantagesInput, advantagesUncheckedUpdateWithoutCharacter_advantagesInput>
  }

  export type advantagesUpdateWithoutCharacter_advantagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    parent_name?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumtypeFieldUpdateOperationsInput | $Enums.type
    level?: IntFieldUpdateOperationsInput | number
    for?: EnumforWhomFieldUpdateOperationsInput | $Enums.forWhom
    clans?: clansUpdateOneWithoutAdvantagesNestedInput
    sects?: sectsUpdateOneWithoutAdvantagesNestedInput
  }

  export type advantagesUncheckedUpdateWithoutCharacter_advantagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    parent_name?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumtypeFieldUpdateOperationsInput | $Enums.type
    level?: IntFieldUpdateOperationsInput | number
    for?: EnumforWhomFieldUpdateOperationsInput | $Enums.forWhom
    clan_req?: NullableStringFieldUpdateOperationsInput | string | null
    sect_req?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type charactersUpsertWithoutCharacter_advantagesInput = {
    update: XOR<charactersUpdateWithoutCharacter_advantagesInput, charactersUncheckedUpdateWithoutCharacter_advantagesInput>
    create: XOR<charactersCreateWithoutCharacter_advantagesInput, charactersUncheckedCreateWithoutCharacter_advantagesInput>
    where?: charactersWhereInput
  }

  export type charactersUpdateToOneWithWhereWithoutCharacter_advantagesInput = {
    where?: charactersWhereInput
    data: XOR<charactersUpdateWithoutCharacter_advantagesInput, charactersUncheckedUpdateWithoutCharacter_advantagesInput>
  }

  export type charactersUpdateWithoutCharacter_advantagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    player?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_alchemy_powers?: character_alchemy_powersUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUpdateManyWithoutCharactersNestedInput
    chronicles?: chroniclesUpdateOneWithoutCharactersNestedInput
    clan_banes?: clan_banesUpdateOneWithoutCharactersNestedInput
    clan_compulsions?: clan_compulsionsUpdateOneWithoutCharactersNestedInput
    clans?: clansUpdateOneWithoutCharactersNestedInput
    char_groups?: char_groupsUpdateOneRequiredWithoutCharactersNestedInput
    predator_types?: predator_typesUpdateOneRequiredWithoutCharactersNestedInput
    sects?: sectsUpdateOneWithoutCharactersNestedInput
    users?: usersUpdateOneRequiredWithoutCharactersNestedInput
    exp_logs?: exp_logsUpdateManyWithoutCharactersNestedInput
  }

  export type charactersUncheckedUpdateWithoutCharacter_advantagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clan_id?: NullableStringFieldUpdateOperationsInput | string | null
    clan_bane?: NullableStringFieldUpdateOperationsInput | string | null
    clan_compulsion?: NullableStringFieldUpdateOperationsInput | string | null
    sect_id?: NullableStringFieldUpdateOperationsInput | string | null
    player?: StringFieldUpdateOperationsInput | string
    predator_type?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    chronicle_id?: NullableStringFieldUpdateOperationsInput | string | null
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    group_id?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_alchemy_powers?: character_alchemy_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUncheckedUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUncheckedUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUncheckedUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUncheckedUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUncheckedUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUncheckedUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUncheckedUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUncheckedUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUncheckedUpdateManyWithoutCharactersNestedInput
    exp_logs?: exp_logsUncheckedUpdateManyWithoutCharactersNestedInput
  }

  export type alchemy_powersCreateWithoutCharacter_alchemy_powersInput = {
    id?: string
    name: string
    description?: string | null
    ingridients?: string | null
    activation?: string | null
    dice_pool?: string | null
    system?: string | null
    duration?: string | null
    level?: number | null
  }

  export type alchemy_powersUncheckedCreateWithoutCharacter_alchemy_powersInput = {
    id?: string
    name: string
    description?: string | null
    ingridients?: string | null
    activation?: string | null
    dice_pool?: string | null
    system?: string | null
    duration?: string | null
    level?: number | null
  }

  export type alchemy_powersCreateOrConnectWithoutCharacter_alchemy_powersInput = {
    where: alchemy_powersWhereUniqueInput
    create: XOR<alchemy_powersCreateWithoutCharacter_alchemy_powersInput, alchemy_powersUncheckedCreateWithoutCharacter_alchemy_powersInput>
  }

  export type charactersCreateWithoutCharacter_alchemy_powersInput = {
    id?: string
    name: string
    player: string
    generation: number
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersCreateNestedManyWithoutCharactersInput
    chronicles?: chroniclesCreateNestedOneWithoutCharactersInput
    clan_banes?: clan_banesCreateNestedOneWithoutCharactersInput
    clan_compulsions?: clan_compulsionsCreateNestedOneWithoutCharactersInput
    clans?: clansCreateNestedOneWithoutCharactersInput
    char_groups: char_groupsCreateNestedOneWithoutCharactersInput
    predator_types: predator_typesCreateNestedOneWithoutCharactersInput
    sects?: sectsCreateNestedOneWithoutCharactersInput
    users: usersCreateNestedOneWithoutCharactersInput
    exp_logs?: exp_logsCreateNestedManyWithoutCharactersInput
  }

  export type charactersUncheckedCreateWithoutCharacter_alchemy_powersInput = {
    id?: string
    user_id: string
    name: string
    clan_id?: string | null
    clan_bane?: string | null
    clan_compulsion?: string | null
    sect_id?: string | null
    player: string
    predator_type: string
    generation: number
    chronicle_id?: string | null
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    group_id: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesUncheckedCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesUncheckedCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesUncheckedCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsUncheckedCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityUncheckedCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileUncheckedCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsUncheckedCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsUncheckedCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesUncheckedCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersUncheckedCreateNestedManyWithoutCharactersInput
    exp_logs?: exp_logsUncheckedCreateNestedManyWithoutCharactersInput
  }

  export type charactersCreateOrConnectWithoutCharacter_alchemy_powersInput = {
    where: charactersWhereUniqueInput
    create: XOR<charactersCreateWithoutCharacter_alchemy_powersInput, charactersUncheckedCreateWithoutCharacter_alchemy_powersInput>
  }

  export type alchemy_powersUpsertWithoutCharacter_alchemy_powersInput = {
    update: XOR<alchemy_powersUpdateWithoutCharacter_alchemy_powersInput, alchemy_powersUncheckedUpdateWithoutCharacter_alchemy_powersInput>
    create: XOR<alchemy_powersCreateWithoutCharacter_alchemy_powersInput, alchemy_powersUncheckedCreateWithoutCharacter_alchemy_powersInput>
    where?: alchemy_powersWhereInput
  }

  export type alchemy_powersUpdateToOneWithWhereWithoutCharacter_alchemy_powersInput = {
    where?: alchemy_powersWhereInput
    data: XOR<alchemy_powersUpdateWithoutCharacter_alchemy_powersInput, alchemy_powersUncheckedUpdateWithoutCharacter_alchemy_powersInput>
  }

  export type alchemy_powersUpdateWithoutCharacter_alchemy_powersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ingridients?: NullableStringFieldUpdateOperationsInput | string | null
    activation?: NullableStringFieldUpdateOperationsInput | string | null
    dice_pool?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type alchemy_powersUncheckedUpdateWithoutCharacter_alchemy_powersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ingridients?: NullableStringFieldUpdateOperationsInput | string | null
    activation?: NullableStringFieldUpdateOperationsInput | string | null
    dice_pool?: NullableStringFieldUpdateOperationsInput | string | null
    system?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type charactersUpsertWithoutCharacter_alchemy_powersInput = {
    update: XOR<charactersUpdateWithoutCharacter_alchemy_powersInput, charactersUncheckedUpdateWithoutCharacter_alchemy_powersInput>
    create: XOR<charactersCreateWithoutCharacter_alchemy_powersInput, charactersUncheckedCreateWithoutCharacter_alchemy_powersInput>
    where?: charactersWhereInput
  }

  export type charactersUpdateToOneWithWhereWithoutCharacter_alchemy_powersInput = {
    where?: charactersWhereInput
    data: XOR<charactersUpdateWithoutCharacter_alchemy_powersInput, charactersUncheckedUpdateWithoutCharacter_alchemy_powersInput>
  }

  export type charactersUpdateWithoutCharacter_alchemy_powersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    player?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUpdateManyWithoutCharactersNestedInput
    chronicles?: chroniclesUpdateOneWithoutCharactersNestedInput
    clan_banes?: clan_banesUpdateOneWithoutCharactersNestedInput
    clan_compulsions?: clan_compulsionsUpdateOneWithoutCharactersNestedInput
    clans?: clansUpdateOneWithoutCharactersNestedInput
    char_groups?: char_groupsUpdateOneRequiredWithoutCharactersNestedInput
    predator_types?: predator_typesUpdateOneRequiredWithoutCharactersNestedInput
    sects?: sectsUpdateOneWithoutCharactersNestedInput
    users?: usersUpdateOneRequiredWithoutCharactersNestedInput
    exp_logs?: exp_logsUpdateManyWithoutCharactersNestedInput
  }

  export type charactersUncheckedUpdateWithoutCharacter_alchemy_powersInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clan_id?: NullableStringFieldUpdateOperationsInput | string | null
    clan_bane?: NullableStringFieldUpdateOperationsInput | string | null
    clan_compulsion?: NullableStringFieldUpdateOperationsInput | string | null
    sect_id?: NullableStringFieldUpdateOperationsInput | string | null
    player?: StringFieldUpdateOperationsInput | string
    predator_type?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    chronicle_id?: NullableStringFieldUpdateOperationsInput | string | null
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    group_id?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUncheckedUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUncheckedUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUncheckedUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUncheckedUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUncheckedUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUncheckedUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUncheckedUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUncheckedUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUncheckedUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUncheckedUpdateManyWithoutCharactersNestedInput
    exp_logs?: exp_logsUncheckedUpdateManyWithoutCharactersNestedInput
  }

  export type attributesCreateWithoutCharacter_attributesInput = {
    id?: string
    name: string
    description: string
    category: $Enums.category
  }

  export type attributesUncheckedCreateWithoutCharacter_attributesInput = {
    id?: string
    name: string
    description: string
    category: $Enums.category
  }

  export type attributesCreateOrConnectWithoutCharacter_attributesInput = {
    where: attributesWhereUniqueInput
    create: XOR<attributesCreateWithoutCharacter_attributesInput, attributesUncheckedCreateWithoutCharacter_attributesInput>
  }

  export type charactersCreateWithoutCharacter_attributesInput = {
    id?: string
    name: string
    player: string
    generation: number
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesCreateNestedManyWithoutCharactersInput
    character_alchemy_powers?: character_alchemy_powersCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersCreateNestedManyWithoutCharactersInput
    chronicles?: chroniclesCreateNestedOneWithoutCharactersInput
    clan_banes?: clan_banesCreateNestedOneWithoutCharactersInput
    clan_compulsions?: clan_compulsionsCreateNestedOneWithoutCharactersInput
    clans?: clansCreateNestedOneWithoutCharactersInput
    char_groups: char_groupsCreateNestedOneWithoutCharactersInput
    predator_types: predator_typesCreateNestedOneWithoutCharactersInput
    sects?: sectsCreateNestedOneWithoutCharactersInput
    users: usersCreateNestedOneWithoutCharactersInput
    exp_logs?: exp_logsCreateNestedManyWithoutCharactersInput
  }

  export type charactersUncheckedCreateWithoutCharacter_attributesInput = {
    id?: string
    user_id: string
    name: string
    clan_id?: string | null
    clan_bane?: string | null
    clan_compulsion?: string | null
    sect_id?: string | null
    player: string
    predator_type: string
    generation: number
    chronicle_id?: string | null
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    group_id: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesUncheckedCreateNestedManyWithoutCharactersInput
    character_alchemy_powers?: character_alchemy_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesUncheckedCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsUncheckedCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityUncheckedCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileUncheckedCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsUncheckedCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsUncheckedCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesUncheckedCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersUncheckedCreateNestedManyWithoutCharactersInput
    exp_logs?: exp_logsUncheckedCreateNestedManyWithoutCharactersInput
  }

  export type charactersCreateOrConnectWithoutCharacter_attributesInput = {
    where: charactersWhereUniqueInput
    create: XOR<charactersCreateWithoutCharacter_attributesInput, charactersUncheckedCreateWithoutCharacter_attributesInput>
  }

  export type attributesUpsertWithoutCharacter_attributesInput = {
    update: XOR<attributesUpdateWithoutCharacter_attributesInput, attributesUncheckedUpdateWithoutCharacter_attributesInput>
    create: XOR<attributesCreateWithoutCharacter_attributesInput, attributesUncheckedCreateWithoutCharacter_attributesInput>
    where?: attributesWhereInput
  }

  export type attributesUpdateToOneWithWhereWithoutCharacter_attributesInput = {
    where?: attributesWhereInput
    data: XOR<attributesUpdateWithoutCharacter_attributesInput, attributesUncheckedUpdateWithoutCharacter_attributesInput>
  }

  export type attributesUpdateWithoutCharacter_attributesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumcategoryFieldUpdateOperationsInput | $Enums.category
  }

  export type attributesUncheckedUpdateWithoutCharacter_attributesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: EnumcategoryFieldUpdateOperationsInput | $Enums.category
  }

  export type charactersUpsertWithoutCharacter_attributesInput = {
    update: XOR<charactersUpdateWithoutCharacter_attributesInput, charactersUncheckedUpdateWithoutCharacter_attributesInput>
    create: XOR<charactersCreateWithoutCharacter_attributesInput, charactersUncheckedCreateWithoutCharacter_attributesInput>
    where?: charactersWhereInput
  }

  export type charactersUpdateToOneWithWhereWithoutCharacter_attributesInput = {
    where?: charactersWhereInput
    data: XOR<charactersUpdateWithoutCharacter_attributesInput, charactersUncheckedUpdateWithoutCharacter_attributesInput>
  }

  export type charactersUpdateWithoutCharacter_attributesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    player?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUpdateManyWithoutCharactersNestedInput
    character_alchemy_powers?: character_alchemy_powersUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUpdateManyWithoutCharactersNestedInput
    chronicles?: chroniclesUpdateOneWithoutCharactersNestedInput
    clan_banes?: clan_banesUpdateOneWithoutCharactersNestedInput
    clan_compulsions?: clan_compulsionsUpdateOneWithoutCharactersNestedInput
    clans?: clansUpdateOneWithoutCharactersNestedInput
    char_groups?: char_groupsUpdateOneRequiredWithoutCharactersNestedInput
    predator_types?: predator_typesUpdateOneRequiredWithoutCharactersNestedInput
    sects?: sectsUpdateOneWithoutCharactersNestedInput
    users?: usersUpdateOneRequiredWithoutCharactersNestedInput
    exp_logs?: exp_logsUpdateManyWithoutCharactersNestedInput
  }

  export type charactersUncheckedUpdateWithoutCharacter_attributesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clan_id?: NullableStringFieldUpdateOperationsInput | string | null
    clan_bane?: NullableStringFieldUpdateOperationsInput | string | null
    clan_compulsion?: NullableStringFieldUpdateOperationsInput | string | null
    sect_id?: NullableStringFieldUpdateOperationsInput | string | null
    player?: StringFieldUpdateOperationsInput | string
    predator_type?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    chronicle_id?: NullableStringFieldUpdateOperationsInput | string | null
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    group_id?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUncheckedUpdateManyWithoutCharactersNestedInput
    character_alchemy_powers?: character_alchemy_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUncheckedUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUncheckedUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUncheckedUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUncheckedUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUncheckedUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUncheckedUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUncheckedUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUncheckedUpdateManyWithoutCharactersNestedInput
    exp_logs?: exp_logsUncheckedUpdateManyWithoutCharactersNestedInput
  }

  export type blood_potencyCreateWithoutCharacter_bloodpotenciesInput = {
    id?: string
    level: number
    description?: string | null
    blood_surge?: string | null
    damage_mend?: string | null
    power_bonus?: string | null
    rc_reroll?: string | null
    bane_severity?: number | null
    feeding_penalty?: string | null
  }

  export type blood_potencyUncheckedCreateWithoutCharacter_bloodpotenciesInput = {
    id?: string
    level: number
    description?: string | null
    blood_surge?: string | null
    damage_mend?: string | null
    power_bonus?: string | null
    rc_reroll?: string | null
    bane_severity?: number | null
    feeding_penalty?: string | null
  }

  export type blood_potencyCreateOrConnectWithoutCharacter_bloodpotenciesInput = {
    where: blood_potencyWhereUniqueInput
    create: XOR<blood_potencyCreateWithoutCharacter_bloodpotenciesInput, blood_potencyUncheckedCreateWithoutCharacter_bloodpotenciesInput>
  }

  export type charactersCreateWithoutCharacter_bloodpotenciesInput = {
    id?: string
    name: string
    player: string
    generation: number
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesCreateNestedManyWithoutCharactersInput
    character_alchemy_powers?: character_alchemy_powersCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersCreateNestedManyWithoutCharactersInput
    chronicles?: chroniclesCreateNestedOneWithoutCharactersInput
    clan_banes?: clan_banesCreateNestedOneWithoutCharactersInput
    clan_compulsions?: clan_compulsionsCreateNestedOneWithoutCharactersInput
    clans?: clansCreateNestedOneWithoutCharactersInput
    char_groups: char_groupsCreateNestedOneWithoutCharactersInput
    predator_types: predator_typesCreateNestedOneWithoutCharactersInput
    sects?: sectsCreateNestedOneWithoutCharactersInput
    users: usersCreateNestedOneWithoutCharactersInput
    exp_logs?: exp_logsCreateNestedManyWithoutCharactersInput
  }

  export type charactersUncheckedCreateWithoutCharacter_bloodpotenciesInput = {
    id?: string
    user_id: string
    name: string
    clan_id?: string | null
    clan_bane?: string | null
    clan_compulsion?: string | null
    sect_id?: string | null
    player: string
    predator_type: string
    generation: number
    chronicle_id?: string | null
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    group_id: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesUncheckedCreateNestedManyWithoutCharactersInput
    character_alchemy_powers?: character_alchemy_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesUncheckedCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesUncheckedCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsUncheckedCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityUncheckedCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileUncheckedCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsUncheckedCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsUncheckedCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesUncheckedCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersUncheckedCreateNestedManyWithoutCharactersInput
    exp_logs?: exp_logsUncheckedCreateNestedManyWithoutCharactersInput
  }

  export type charactersCreateOrConnectWithoutCharacter_bloodpotenciesInput = {
    where: charactersWhereUniqueInput
    create: XOR<charactersCreateWithoutCharacter_bloodpotenciesInput, charactersUncheckedCreateWithoutCharacter_bloodpotenciesInput>
  }

  export type clan_compulsionsCreateWithoutCharacter_bloodpotenciesInput = {
    id?: string
    name: string
    description: string
    characters?: charactersCreateNestedManyWithoutClan_compulsionsInput
    clans: clansCreateNestedOneWithoutClan_compulsionsInput
  }

  export type clan_compulsionsUncheckedCreateWithoutCharacter_bloodpotenciesInput = {
    id?: string
    name: string
    clan_id: string
    description: string
    characters?: charactersUncheckedCreateNestedManyWithoutClan_compulsionsInput
  }

  export type clan_compulsionsCreateOrConnectWithoutCharacter_bloodpotenciesInput = {
    where: clan_compulsionsWhereUniqueInput
    create: XOR<clan_compulsionsCreateWithoutCharacter_bloodpotenciesInput, clan_compulsionsUncheckedCreateWithoutCharacter_bloodpotenciesInput>
  }

  export type clan_banesCreateWithoutCharacter_bloodpotenciesInput = {
    id?: string
    name: string
    description: string
    characters?: charactersCreateNestedManyWithoutClan_banesInput
    clans: clansCreateNestedOneWithoutClan_banesInput
  }

  export type clan_banesUncheckedCreateWithoutCharacter_bloodpotenciesInput = {
    id?: string
    name: string
    clan_id: string
    description: string
    characters?: charactersUncheckedCreateNestedManyWithoutClan_banesInput
  }

  export type clan_banesCreateOrConnectWithoutCharacter_bloodpotenciesInput = {
    where: clan_banesWhereUniqueInput
    create: XOR<clan_banesCreateWithoutCharacter_bloodpotenciesInput, clan_banesUncheckedCreateWithoutCharacter_bloodpotenciesInput>
  }

  export type blood_potencyUpsertWithoutCharacter_bloodpotenciesInput = {
    update: XOR<blood_potencyUpdateWithoutCharacter_bloodpotenciesInput, blood_potencyUncheckedUpdateWithoutCharacter_bloodpotenciesInput>
    create: XOR<blood_potencyCreateWithoutCharacter_bloodpotenciesInput, blood_potencyUncheckedCreateWithoutCharacter_bloodpotenciesInput>
    where?: blood_potencyWhereInput
  }

  export type blood_potencyUpdateToOneWithWhereWithoutCharacter_bloodpotenciesInput = {
    where?: blood_potencyWhereInput
    data: XOR<blood_potencyUpdateWithoutCharacter_bloodpotenciesInput, blood_potencyUncheckedUpdateWithoutCharacter_bloodpotenciesInput>
  }

  export type blood_potencyUpdateWithoutCharacter_bloodpotenciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    blood_surge?: NullableStringFieldUpdateOperationsInput | string | null
    damage_mend?: NullableStringFieldUpdateOperationsInput | string | null
    power_bonus?: NullableStringFieldUpdateOperationsInput | string | null
    rc_reroll?: NullableStringFieldUpdateOperationsInput | string | null
    bane_severity?: NullableIntFieldUpdateOperationsInput | number | null
    feeding_penalty?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type blood_potencyUncheckedUpdateWithoutCharacter_bloodpotenciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    blood_surge?: NullableStringFieldUpdateOperationsInput | string | null
    damage_mend?: NullableStringFieldUpdateOperationsInput | string | null
    power_bonus?: NullableStringFieldUpdateOperationsInput | string | null
    rc_reroll?: NullableStringFieldUpdateOperationsInput | string | null
    bane_severity?: NullableIntFieldUpdateOperationsInput | number | null
    feeding_penalty?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type charactersUpsertWithoutCharacter_bloodpotenciesInput = {
    update: XOR<charactersUpdateWithoutCharacter_bloodpotenciesInput, charactersUncheckedUpdateWithoutCharacter_bloodpotenciesInput>
    create: XOR<charactersCreateWithoutCharacter_bloodpotenciesInput, charactersUncheckedCreateWithoutCharacter_bloodpotenciesInput>
    where?: charactersWhereInput
  }

  export type charactersUpdateToOneWithWhereWithoutCharacter_bloodpotenciesInput = {
    where?: charactersWhereInput
    data: XOR<charactersUpdateWithoutCharacter_bloodpotenciesInput, charactersUncheckedUpdateWithoutCharacter_bloodpotenciesInput>
  }

  export type charactersUpdateWithoutCharacter_bloodpotenciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    player?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUpdateManyWithoutCharactersNestedInput
    character_alchemy_powers?: character_alchemy_powersUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUpdateManyWithoutCharactersNestedInput
    chronicles?: chroniclesUpdateOneWithoutCharactersNestedInput
    clan_banes?: clan_banesUpdateOneWithoutCharactersNestedInput
    clan_compulsions?: clan_compulsionsUpdateOneWithoutCharactersNestedInput
    clans?: clansUpdateOneWithoutCharactersNestedInput
    char_groups?: char_groupsUpdateOneRequiredWithoutCharactersNestedInput
    predator_types?: predator_typesUpdateOneRequiredWithoutCharactersNestedInput
    sects?: sectsUpdateOneWithoutCharactersNestedInput
    users?: usersUpdateOneRequiredWithoutCharactersNestedInput
    exp_logs?: exp_logsUpdateManyWithoutCharactersNestedInput
  }

  export type charactersUncheckedUpdateWithoutCharacter_bloodpotenciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clan_id?: NullableStringFieldUpdateOperationsInput | string | null
    clan_bane?: NullableStringFieldUpdateOperationsInput | string | null
    clan_compulsion?: NullableStringFieldUpdateOperationsInput | string | null
    sect_id?: NullableStringFieldUpdateOperationsInput | string | null
    player?: StringFieldUpdateOperationsInput | string
    predator_type?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    chronicle_id?: NullableStringFieldUpdateOperationsInput | string | null
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    group_id?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUncheckedUpdateManyWithoutCharactersNestedInput
    character_alchemy_powers?: character_alchemy_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUncheckedUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUncheckedUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUncheckedUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUncheckedUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUncheckedUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUncheckedUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUncheckedUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUncheckedUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUncheckedUpdateManyWithoutCharactersNestedInput
    exp_logs?: exp_logsUncheckedUpdateManyWithoutCharactersNestedInput
  }

  export type clan_compulsionsUpsertWithoutCharacter_bloodpotenciesInput = {
    update: XOR<clan_compulsionsUpdateWithoutCharacter_bloodpotenciesInput, clan_compulsionsUncheckedUpdateWithoutCharacter_bloodpotenciesInput>
    create: XOR<clan_compulsionsCreateWithoutCharacter_bloodpotenciesInput, clan_compulsionsUncheckedCreateWithoutCharacter_bloodpotenciesInput>
    where?: clan_compulsionsWhereInput
  }

  export type clan_compulsionsUpdateToOneWithWhereWithoutCharacter_bloodpotenciesInput = {
    where?: clan_compulsionsWhereInput
    data: XOR<clan_compulsionsUpdateWithoutCharacter_bloodpotenciesInput, clan_compulsionsUncheckedUpdateWithoutCharacter_bloodpotenciesInput>
  }

  export type clan_compulsionsUpdateWithoutCharacter_bloodpotenciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    characters?: charactersUpdateManyWithoutClan_compulsionsNestedInput
    clans?: clansUpdateOneRequiredWithoutClan_compulsionsNestedInput
  }

  export type clan_compulsionsUncheckedUpdateWithoutCharacter_bloodpotenciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clan_id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    characters?: charactersUncheckedUpdateManyWithoutClan_compulsionsNestedInput
  }

  export type clan_banesUpsertWithoutCharacter_bloodpotenciesInput = {
    update: XOR<clan_banesUpdateWithoutCharacter_bloodpotenciesInput, clan_banesUncheckedUpdateWithoutCharacter_bloodpotenciesInput>
    create: XOR<clan_banesCreateWithoutCharacter_bloodpotenciesInput, clan_banesUncheckedCreateWithoutCharacter_bloodpotenciesInput>
    where?: clan_banesWhereInput
  }

  export type clan_banesUpdateToOneWithWhereWithoutCharacter_bloodpotenciesInput = {
    where?: clan_banesWhereInput
    data: XOR<clan_banesUpdateWithoutCharacter_bloodpotenciesInput, clan_banesUncheckedUpdateWithoutCharacter_bloodpotenciesInput>
  }

  export type clan_banesUpdateWithoutCharacter_bloodpotenciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    characters?: charactersUpdateManyWithoutClan_banesNestedInput
    clans?: clansUpdateOneRequiredWithoutClan_banesNestedInput
  }

  export type clan_banesUncheckedUpdateWithoutCharacter_bloodpotenciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clan_id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    characters?: charactersUncheckedUpdateManyWithoutClan_banesNestedInput
  }

  export type charactersCreateWithoutCharacter_discipline_powersInput = {
    id?: string
    name: string
    player: string
    generation: number
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesCreateNestedManyWithoutCharactersInput
    character_alchemy_powers?: character_alchemy_powersCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersCreateNestedManyWithoutCharactersInput
    chronicles?: chroniclesCreateNestedOneWithoutCharactersInput
    clan_banes?: clan_banesCreateNestedOneWithoutCharactersInput
    clan_compulsions?: clan_compulsionsCreateNestedOneWithoutCharactersInput
    clans?: clansCreateNestedOneWithoutCharactersInput
    char_groups: char_groupsCreateNestedOneWithoutCharactersInput
    predator_types: predator_typesCreateNestedOneWithoutCharactersInput
    sects?: sectsCreateNestedOneWithoutCharactersInput
    users: usersCreateNestedOneWithoutCharactersInput
    exp_logs?: exp_logsCreateNestedManyWithoutCharactersInput
  }

  export type charactersUncheckedCreateWithoutCharacter_discipline_powersInput = {
    id?: string
    user_id: string
    name: string
    clan_id?: string | null
    clan_bane?: string | null
    clan_compulsion?: string | null
    sect_id?: string | null
    player: string
    predator_type: string
    generation: number
    chronicle_id?: string | null
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    group_id: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesUncheckedCreateNestedManyWithoutCharactersInput
    character_alchemy_powers?: character_alchemy_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesUncheckedCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesUncheckedCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsUncheckedCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityUncheckedCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileUncheckedCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsUncheckedCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsUncheckedCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesUncheckedCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersUncheckedCreateNestedManyWithoutCharactersInput
    exp_logs?: exp_logsUncheckedCreateNestedManyWithoutCharactersInput
  }

  export type charactersCreateOrConnectWithoutCharacter_discipline_powersInput = {
    where: charactersWhereUniqueInput
    create: XOR<charactersCreateWithoutCharacter_discipline_powersInput, charactersUncheckedCreateWithoutCharacter_discipline_powersInput>
  }

  export type discipline_powersCreateWithoutCharacter_discipline_powersInput = {
    id?: string
    name: string
    level: number
    description: string
    dice_pool: string
    cost: string
    prerequisites: string
    amalgam: string
    system: string
    duration: string
    disciplines: disciplinesCreateNestedOneWithoutDiscipline_powersInput
  }

  export type discipline_powersUncheckedCreateWithoutCharacter_discipline_powersInput = {
    id?: string
    discipline_id: string
    name: string
    level: number
    description: string
    dice_pool: string
    cost: string
    prerequisites: string
    amalgam: string
    system: string
    duration: string
  }

  export type discipline_powersCreateOrConnectWithoutCharacter_discipline_powersInput = {
    where: discipline_powersWhereUniqueInput
    create: XOR<discipline_powersCreateWithoutCharacter_discipline_powersInput, discipline_powersUncheckedCreateWithoutCharacter_discipline_powersInput>
  }

  export type charactersUpsertWithoutCharacter_discipline_powersInput = {
    update: XOR<charactersUpdateWithoutCharacter_discipline_powersInput, charactersUncheckedUpdateWithoutCharacter_discipline_powersInput>
    create: XOR<charactersCreateWithoutCharacter_discipline_powersInput, charactersUncheckedCreateWithoutCharacter_discipline_powersInput>
    where?: charactersWhereInput
  }

  export type charactersUpdateToOneWithWhereWithoutCharacter_discipline_powersInput = {
    where?: charactersWhereInput
    data: XOR<charactersUpdateWithoutCharacter_discipline_powersInput, charactersUncheckedUpdateWithoutCharacter_discipline_powersInput>
  }

  export type charactersUpdateWithoutCharacter_discipline_powersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    player?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUpdateManyWithoutCharactersNestedInput
    character_alchemy_powers?: character_alchemy_powersUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUpdateManyWithoutCharactersNestedInput
    chronicles?: chroniclesUpdateOneWithoutCharactersNestedInput
    clan_banes?: clan_banesUpdateOneWithoutCharactersNestedInput
    clan_compulsions?: clan_compulsionsUpdateOneWithoutCharactersNestedInput
    clans?: clansUpdateOneWithoutCharactersNestedInput
    char_groups?: char_groupsUpdateOneRequiredWithoutCharactersNestedInput
    predator_types?: predator_typesUpdateOneRequiredWithoutCharactersNestedInput
    sects?: sectsUpdateOneWithoutCharactersNestedInput
    users?: usersUpdateOneRequiredWithoutCharactersNestedInput
    exp_logs?: exp_logsUpdateManyWithoutCharactersNestedInput
  }

  export type charactersUncheckedUpdateWithoutCharacter_discipline_powersInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clan_id?: NullableStringFieldUpdateOperationsInput | string | null
    clan_bane?: NullableStringFieldUpdateOperationsInput | string | null
    clan_compulsion?: NullableStringFieldUpdateOperationsInput | string | null
    sect_id?: NullableStringFieldUpdateOperationsInput | string | null
    player?: StringFieldUpdateOperationsInput | string
    predator_type?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    chronicle_id?: NullableStringFieldUpdateOperationsInput | string | null
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    group_id?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUncheckedUpdateManyWithoutCharactersNestedInput
    character_alchemy_powers?: character_alchemy_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUncheckedUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUncheckedUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUncheckedUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUncheckedUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUncheckedUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUncheckedUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUncheckedUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUncheckedUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUncheckedUpdateManyWithoutCharactersNestedInput
    exp_logs?: exp_logsUncheckedUpdateManyWithoutCharactersNestedInput
  }

  export type discipline_powersUpsertWithoutCharacter_discipline_powersInput = {
    update: XOR<discipline_powersUpdateWithoutCharacter_discipline_powersInput, discipline_powersUncheckedUpdateWithoutCharacter_discipline_powersInput>
    create: XOR<discipline_powersCreateWithoutCharacter_discipline_powersInput, discipline_powersUncheckedCreateWithoutCharacter_discipline_powersInput>
    where?: discipline_powersWhereInput
  }

  export type discipline_powersUpdateToOneWithWhereWithoutCharacter_discipline_powersInput = {
    where?: discipline_powersWhereInput
    data: XOR<discipline_powersUpdateWithoutCharacter_discipline_powersInput, discipline_powersUncheckedUpdateWithoutCharacter_discipline_powersInput>
  }

  export type discipline_powersUpdateWithoutCharacter_discipline_powersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    dice_pool?: StringFieldUpdateOperationsInput | string
    cost?: StringFieldUpdateOperationsInput | string
    prerequisites?: StringFieldUpdateOperationsInput | string
    amalgam?: StringFieldUpdateOperationsInput | string
    system?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    disciplines?: disciplinesUpdateOneRequiredWithoutDiscipline_powersNestedInput
  }

  export type discipline_powersUncheckedUpdateWithoutCharacter_discipline_powersInput = {
    id?: StringFieldUpdateOperationsInput | string
    discipline_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    dice_pool?: StringFieldUpdateOperationsInput | string
    cost?: StringFieldUpdateOperationsInput | string
    prerequisites?: StringFieldUpdateOperationsInput | string
    amalgam?: StringFieldUpdateOperationsInput | string
    system?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
  }

  export type charactersCreateWithoutCharacter_disciplinesInput = {
    id?: string
    name: string
    player: string
    generation: number
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesCreateNestedManyWithoutCharactersInput
    character_alchemy_powers?: character_alchemy_powersCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersCreateNestedManyWithoutCharactersInput
    chronicles?: chroniclesCreateNestedOneWithoutCharactersInput
    clan_banes?: clan_banesCreateNestedOneWithoutCharactersInput
    clan_compulsions?: clan_compulsionsCreateNestedOneWithoutCharactersInput
    clans?: clansCreateNestedOneWithoutCharactersInput
    char_groups: char_groupsCreateNestedOneWithoutCharactersInput
    predator_types: predator_typesCreateNestedOneWithoutCharactersInput
    sects?: sectsCreateNestedOneWithoutCharactersInput
    users: usersCreateNestedOneWithoutCharactersInput
    exp_logs?: exp_logsCreateNestedManyWithoutCharactersInput
  }

  export type charactersUncheckedCreateWithoutCharacter_disciplinesInput = {
    id?: string
    user_id: string
    name: string
    clan_id?: string | null
    clan_bane?: string | null
    clan_compulsion?: string | null
    sect_id?: string | null
    player: string
    predator_type: string
    generation: number
    chronicle_id?: string | null
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    group_id: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesUncheckedCreateNestedManyWithoutCharactersInput
    character_alchemy_powers?: character_alchemy_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesUncheckedCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsUncheckedCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityUncheckedCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileUncheckedCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsUncheckedCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsUncheckedCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesUncheckedCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersUncheckedCreateNestedManyWithoutCharactersInput
    exp_logs?: exp_logsUncheckedCreateNestedManyWithoutCharactersInput
  }

  export type charactersCreateOrConnectWithoutCharacter_disciplinesInput = {
    where: charactersWhereUniqueInput
    create: XOR<charactersCreateWithoutCharacter_disciplinesInput, charactersUncheckedCreateWithoutCharacter_disciplinesInput>
  }

  export type disciplinesCreateWithoutCharacter_disciplinesInput = {
    id?: string
    name: string
    description: string
    nicknames: string
    characteristics: string
    type: string
    masquerade_threat: string
    blood_resonance: string
    discipline_powers?: discipline_powersCreateNestedManyWithoutDisciplinesInput
  }

  export type disciplinesUncheckedCreateWithoutCharacter_disciplinesInput = {
    id?: string
    name: string
    description: string
    nicknames: string
    characteristics: string
    type: string
    masquerade_threat: string
    blood_resonance: string
    discipline_powers?: discipline_powersUncheckedCreateNestedManyWithoutDisciplinesInput
  }

  export type disciplinesCreateOrConnectWithoutCharacter_disciplinesInput = {
    where: disciplinesWhereUniqueInput
    create: XOR<disciplinesCreateWithoutCharacter_disciplinesInput, disciplinesUncheckedCreateWithoutCharacter_disciplinesInput>
  }

  export type charactersUpsertWithoutCharacter_disciplinesInput = {
    update: XOR<charactersUpdateWithoutCharacter_disciplinesInput, charactersUncheckedUpdateWithoutCharacter_disciplinesInput>
    create: XOR<charactersCreateWithoutCharacter_disciplinesInput, charactersUncheckedCreateWithoutCharacter_disciplinesInput>
    where?: charactersWhereInput
  }

  export type charactersUpdateToOneWithWhereWithoutCharacter_disciplinesInput = {
    where?: charactersWhereInput
    data: XOR<charactersUpdateWithoutCharacter_disciplinesInput, charactersUncheckedUpdateWithoutCharacter_disciplinesInput>
  }

  export type charactersUpdateWithoutCharacter_disciplinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    player?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUpdateManyWithoutCharactersNestedInput
    character_alchemy_powers?: character_alchemy_powersUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUpdateManyWithoutCharactersNestedInput
    chronicles?: chroniclesUpdateOneWithoutCharactersNestedInput
    clan_banes?: clan_banesUpdateOneWithoutCharactersNestedInput
    clan_compulsions?: clan_compulsionsUpdateOneWithoutCharactersNestedInput
    clans?: clansUpdateOneWithoutCharactersNestedInput
    char_groups?: char_groupsUpdateOneRequiredWithoutCharactersNestedInput
    predator_types?: predator_typesUpdateOneRequiredWithoutCharactersNestedInput
    sects?: sectsUpdateOneWithoutCharactersNestedInput
    users?: usersUpdateOneRequiredWithoutCharactersNestedInput
    exp_logs?: exp_logsUpdateManyWithoutCharactersNestedInput
  }

  export type charactersUncheckedUpdateWithoutCharacter_disciplinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clan_id?: NullableStringFieldUpdateOperationsInput | string | null
    clan_bane?: NullableStringFieldUpdateOperationsInput | string | null
    clan_compulsion?: NullableStringFieldUpdateOperationsInput | string | null
    sect_id?: NullableStringFieldUpdateOperationsInput | string | null
    player?: StringFieldUpdateOperationsInput | string
    predator_type?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    chronicle_id?: NullableStringFieldUpdateOperationsInput | string | null
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    group_id?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUncheckedUpdateManyWithoutCharactersNestedInput
    character_alchemy_powers?: character_alchemy_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUncheckedUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUncheckedUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUncheckedUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUncheckedUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUncheckedUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUncheckedUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUncheckedUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUncheckedUpdateManyWithoutCharactersNestedInput
    exp_logs?: exp_logsUncheckedUpdateManyWithoutCharactersNestedInput
  }

  export type disciplinesUpsertWithoutCharacter_disciplinesInput = {
    update: XOR<disciplinesUpdateWithoutCharacter_disciplinesInput, disciplinesUncheckedUpdateWithoutCharacter_disciplinesInput>
    create: XOR<disciplinesCreateWithoutCharacter_disciplinesInput, disciplinesUncheckedCreateWithoutCharacter_disciplinesInput>
    where?: disciplinesWhereInput
  }

  export type disciplinesUpdateToOneWithWhereWithoutCharacter_disciplinesInput = {
    where?: disciplinesWhereInput
    data: XOR<disciplinesUpdateWithoutCharacter_disciplinesInput, disciplinesUncheckedUpdateWithoutCharacter_disciplinesInput>
  }

  export type disciplinesUpdateWithoutCharacter_disciplinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    nicknames?: StringFieldUpdateOperationsInput | string
    characteristics?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    masquerade_threat?: StringFieldUpdateOperationsInput | string
    blood_resonance?: StringFieldUpdateOperationsInput | string
    discipline_powers?: discipline_powersUpdateManyWithoutDisciplinesNestedInput
  }

  export type disciplinesUncheckedUpdateWithoutCharacter_disciplinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    nicknames?: StringFieldUpdateOperationsInput | string
    characteristics?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    masquerade_threat?: StringFieldUpdateOperationsInput | string
    blood_resonance?: StringFieldUpdateOperationsInput | string
    discipline_powers?: discipline_powersUncheckedUpdateManyWithoutDisciplinesNestedInput
  }

  export type charactersCreateWithoutCharacter_healthsInput = {
    id?: string
    name: string
    player: string
    generation: number
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesCreateNestedManyWithoutCharactersInput
    character_alchemy_powers?: character_alchemy_powersCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersCreateNestedManyWithoutCharactersInput
    chronicles?: chroniclesCreateNestedOneWithoutCharactersInput
    clan_banes?: clan_banesCreateNestedOneWithoutCharactersInput
    clan_compulsions?: clan_compulsionsCreateNestedOneWithoutCharactersInput
    clans?: clansCreateNestedOneWithoutCharactersInput
    char_groups: char_groupsCreateNestedOneWithoutCharactersInput
    predator_types: predator_typesCreateNestedOneWithoutCharactersInput
    sects?: sectsCreateNestedOneWithoutCharactersInput
    users: usersCreateNestedOneWithoutCharactersInput
    exp_logs?: exp_logsCreateNestedManyWithoutCharactersInput
  }

  export type charactersUncheckedCreateWithoutCharacter_healthsInput = {
    id?: string
    user_id: string
    name: string
    clan_id?: string | null
    clan_bane?: string | null
    clan_compulsion?: string | null
    sect_id?: string | null
    player: string
    predator_type: string
    generation: number
    chronicle_id?: string | null
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    group_id: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesUncheckedCreateNestedManyWithoutCharactersInput
    character_alchemy_powers?: character_alchemy_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesUncheckedCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesUncheckedCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityUncheckedCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileUncheckedCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsUncheckedCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsUncheckedCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesUncheckedCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersUncheckedCreateNestedManyWithoutCharactersInput
    exp_logs?: exp_logsUncheckedCreateNestedManyWithoutCharactersInput
  }

  export type charactersCreateOrConnectWithoutCharacter_healthsInput = {
    where: charactersWhereUniqueInput
    create: XOR<charactersCreateWithoutCharacter_healthsInput, charactersUncheckedCreateWithoutCharacter_healthsInput>
  }

  export type charactersUpsertWithoutCharacter_healthsInput = {
    update: XOR<charactersUpdateWithoutCharacter_healthsInput, charactersUncheckedUpdateWithoutCharacter_healthsInput>
    create: XOR<charactersCreateWithoutCharacter_healthsInput, charactersUncheckedCreateWithoutCharacter_healthsInput>
    where?: charactersWhereInput
  }

  export type charactersUpdateToOneWithWhereWithoutCharacter_healthsInput = {
    where?: charactersWhereInput
    data: XOR<charactersUpdateWithoutCharacter_healthsInput, charactersUncheckedUpdateWithoutCharacter_healthsInput>
  }

  export type charactersUpdateWithoutCharacter_healthsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    player?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUpdateManyWithoutCharactersNestedInput
    character_alchemy_powers?: character_alchemy_powersUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUpdateManyWithoutCharactersNestedInput
    chronicles?: chroniclesUpdateOneWithoutCharactersNestedInput
    clan_banes?: clan_banesUpdateOneWithoutCharactersNestedInput
    clan_compulsions?: clan_compulsionsUpdateOneWithoutCharactersNestedInput
    clans?: clansUpdateOneWithoutCharactersNestedInput
    char_groups?: char_groupsUpdateOneRequiredWithoutCharactersNestedInput
    predator_types?: predator_typesUpdateOneRequiredWithoutCharactersNestedInput
    sects?: sectsUpdateOneWithoutCharactersNestedInput
    users?: usersUpdateOneRequiredWithoutCharactersNestedInput
    exp_logs?: exp_logsUpdateManyWithoutCharactersNestedInput
  }

  export type charactersUncheckedUpdateWithoutCharacter_healthsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clan_id?: NullableStringFieldUpdateOperationsInput | string | null
    clan_bane?: NullableStringFieldUpdateOperationsInput | string | null
    clan_compulsion?: NullableStringFieldUpdateOperationsInput | string | null
    sect_id?: NullableStringFieldUpdateOperationsInput | string | null
    player?: StringFieldUpdateOperationsInput | string
    predator_type?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    chronicle_id?: NullableStringFieldUpdateOperationsInput | string | null
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    group_id?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUncheckedUpdateManyWithoutCharactersNestedInput
    character_alchemy_powers?: character_alchemy_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUncheckedUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUncheckedUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUncheckedUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUncheckedUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUncheckedUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUncheckedUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUncheckedUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUncheckedUpdateManyWithoutCharactersNestedInput
    exp_logs?: exp_logsUncheckedUpdateManyWithoutCharactersNestedInput
  }

  export type charactersCreateWithoutCharacter_humanityInput = {
    id?: string
    name: string
    player: string
    generation: number
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesCreateNestedManyWithoutCharactersInput
    character_alchemy_powers?: character_alchemy_powersCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersCreateNestedManyWithoutCharactersInput
    chronicles?: chroniclesCreateNestedOneWithoutCharactersInput
    clan_banes?: clan_banesCreateNestedOneWithoutCharactersInput
    clan_compulsions?: clan_compulsionsCreateNestedOneWithoutCharactersInput
    clans?: clansCreateNestedOneWithoutCharactersInput
    char_groups: char_groupsCreateNestedOneWithoutCharactersInput
    predator_types: predator_typesCreateNestedOneWithoutCharactersInput
    sects?: sectsCreateNestedOneWithoutCharactersInput
    users: usersCreateNestedOneWithoutCharactersInput
    exp_logs?: exp_logsCreateNestedManyWithoutCharactersInput
  }

  export type charactersUncheckedCreateWithoutCharacter_humanityInput = {
    id?: string
    user_id: string
    name: string
    clan_id?: string | null
    clan_bane?: string | null
    clan_compulsion?: string | null
    sect_id?: string | null
    player: string
    predator_type: string
    generation: number
    chronicle_id?: string | null
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    group_id: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesUncheckedCreateNestedManyWithoutCharactersInput
    character_alchemy_powers?: character_alchemy_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesUncheckedCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesUncheckedCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsUncheckedCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileUncheckedCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsUncheckedCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsUncheckedCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesUncheckedCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersUncheckedCreateNestedManyWithoutCharactersInput
    exp_logs?: exp_logsUncheckedCreateNestedManyWithoutCharactersInput
  }

  export type charactersCreateOrConnectWithoutCharacter_humanityInput = {
    where: charactersWhereUniqueInput
    create: XOR<charactersCreateWithoutCharacter_humanityInput, charactersUncheckedCreateWithoutCharacter_humanityInput>
  }

  export type charactersUpsertWithoutCharacter_humanityInput = {
    update: XOR<charactersUpdateWithoutCharacter_humanityInput, charactersUncheckedUpdateWithoutCharacter_humanityInput>
    create: XOR<charactersCreateWithoutCharacter_humanityInput, charactersUncheckedCreateWithoutCharacter_humanityInput>
    where?: charactersWhereInput
  }

  export type charactersUpdateToOneWithWhereWithoutCharacter_humanityInput = {
    where?: charactersWhereInput
    data: XOR<charactersUpdateWithoutCharacter_humanityInput, charactersUncheckedUpdateWithoutCharacter_humanityInput>
  }

  export type charactersUpdateWithoutCharacter_humanityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    player?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUpdateManyWithoutCharactersNestedInput
    character_alchemy_powers?: character_alchemy_powersUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUpdateManyWithoutCharactersNestedInput
    chronicles?: chroniclesUpdateOneWithoutCharactersNestedInput
    clan_banes?: clan_banesUpdateOneWithoutCharactersNestedInput
    clan_compulsions?: clan_compulsionsUpdateOneWithoutCharactersNestedInput
    clans?: clansUpdateOneWithoutCharactersNestedInput
    char_groups?: char_groupsUpdateOneRequiredWithoutCharactersNestedInput
    predator_types?: predator_typesUpdateOneRequiredWithoutCharactersNestedInput
    sects?: sectsUpdateOneWithoutCharactersNestedInput
    users?: usersUpdateOneRequiredWithoutCharactersNestedInput
    exp_logs?: exp_logsUpdateManyWithoutCharactersNestedInput
  }

  export type charactersUncheckedUpdateWithoutCharacter_humanityInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clan_id?: NullableStringFieldUpdateOperationsInput | string | null
    clan_bane?: NullableStringFieldUpdateOperationsInput | string | null
    clan_compulsion?: NullableStringFieldUpdateOperationsInput | string | null
    sect_id?: NullableStringFieldUpdateOperationsInput | string | null
    player?: StringFieldUpdateOperationsInput | string
    predator_type?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    chronicle_id?: NullableStringFieldUpdateOperationsInput | string | null
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    group_id?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUncheckedUpdateManyWithoutCharactersNestedInput
    character_alchemy_powers?: character_alchemy_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUncheckedUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUncheckedUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUncheckedUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUncheckedUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUncheckedUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUncheckedUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUncheckedUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUncheckedUpdateManyWithoutCharactersNestedInput
    exp_logs?: exp_logsUncheckedUpdateManyWithoutCharactersNestedInput
  }

  export type charactersCreateWithoutCharacter_profileInput = {
    id?: string
    name: string
    player: string
    generation: number
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesCreateNestedManyWithoutCharactersInput
    character_alchemy_powers?: character_alchemy_powersCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersCreateNestedManyWithoutCharactersInput
    chronicles?: chroniclesCreateNestedOneWithoutCharactersInput
    clan_banes?: clan_banesCreateNestedOneWithoutCharactersInput
    clan_compulsions?: clan_compulsionsCreateNestedOneWithoutCharactersInput
    clans?: clansCreateNestedOneWithoutCharactersInput
    char_groups: char_groupsCreateNestedOneWithoutCharactersInput
    predator_types: predator_typesCreateNestedOneWithoutCharactersInput
    sects?: sectsCreateNestedOneWithoutCharactersInput
    users: usersCreateNestedOneWithoutCharactersInput
    exp_logs?: exp_logsCreateNestedManyWithoutCharactersInput
  }

  export type charactersUncheckedCreateWithoutCharacter_profileInput = {
    id?: string
    user_id: string
    name: string
    clan_id?: string | null
    clan_bane?: string | null
    clan_compulsion?: string | null
    sect_id?: string | null
    player: string
    predator_type: string
    generation: number
    chronicle_id?: string | null
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    group_id: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesUncheckedCreateNestedManyWithoutCharactersInput
    character_alchemy_powers?: character_alchemy_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesUncheckedCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesUncheckedCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsUncheckedCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityUncheckedCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsUncheckedCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsUncheckedCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesUncheckedCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersUncheckedCreateNestedManyWithoutCharactersInput
    exp_logs?: exp_logsUncheckedCreateNestedManyWithoutCharactersInput
  }

  export type charactersCreateOrConnectWithoutCharacter_profileInput = {
    where: charactersWhereUniqueInput
    create: XOR<charactersCreateWithoutCharacter_profileInput, charactersUncheckedCreateWithoutCharacter_profileInput>
  }

  export type charactersUpsertWithoutCharacter_profileInput = {
    update: XOR<charactersUpdateWithoutCharacter_profileInput, charactersUncheckedUpdateWithoutCharacter_profileInput>
    create: XOR<charactersCreateWithoutCharacter_profileInput, charactersUncheckedCreateWithoutCharacter_profileInput>
    where?: charactersWhereInput
  }

  export type charactersUpdateToOneWithWhereWithoutCharacter_profileInput = {
    where?: charactersWhereInput
    data: XOR<charactersUpdateWithoutCharacter_profileInput, charactersUncheckedUpdateWithoutCharacter_profileInput>
  }

  export type charactersUpdateWithoutCharacter_profileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    player?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUpdateManyWithoutCharactersNestedInput
    character_alchemy_powers?: character_alchemy_powersUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUpdateManyWithoutCharactersNestedInput
    chronicles?: chroniclesUpdateOneWithoutCharactersNestedInput
    clan_banes?: clan_banesUpdateOneWithoutCharactersNestedInput
    clan_compulsions?: clan_compulsionsUpdateOneWithoutCharactersNestedInput
    clans?: clansUpdateOneWithoutCharactersNestedInput
    char_groups?: char_groupsUpdateOneRequiredWithoutCharactersNestedInput
    predator_types?: predator_typesUpdateOneRequiredWithoutCharactersNestedInput
    sects?: sectsUpdateOneWithoutCharactersNestedInput
    users?: usersUpdateOneRequiredWithoutCharactersNestedInput
    exp_logs?: exp_logsUpdateManyWithoutCharactersNestedInput
  }

  export type charactersUncheckedUpdateWithoutCharacter_profileInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clan_id?: NullableStringFieldUpdateOperationsInput | string | null
    clan_bane?: NullableStringFieldUpdateOperationsInput | string | null
    clan_compulsion?: NullableStringFieldUpdateOperationsInput | string | null
    sect_id?: NullableStringFieldUpdateOperationsInput | string | null
    player?: StringFieldUpdateOperationsInput | string
    predator_type?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    chronicle_id?: NullableStringFieldUpdateOperationsInput | string | null
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    group_id?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUncheckedUpdateManyWithoutCharactersNestedInput
    character_alchemy_powers?: character_alchemy_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUncheckedUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUncheckedUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUncheckedUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUncheckedUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUncheckedUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUncheckedUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUncheckedUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUncheckedUpdateManyWithoutCharactersNestedInput
    exp_logs?: exp_logsUncheckedUpdateManyWithoutCharactersNestedInput
  }

  export type charactersCreateWithoutCharacter_ritualsInput = {
    id?: string
    name: string
    player: string
    generation: number
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesCreateNestedManyWithoutCharactersInput
    character_alchemy_powers?: character_alchemy_powersCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersCreateNestedManyWithoutCharactersInput
    chronicles?: chroniclesCreateNestedOneWithoutCharactersInput
    clan_banes?: clan_banesCreateNestedOneWithoutCharactersInput
    clan_compulsions?: clan_compulsionsCreateNestedOneWithoutCharactersInput
    clans?: clansCreateNestedOneWithoutCharactersInput
    char_groups: char_groupsCreateNestedOneWithoutCharactersInput
    predator_types: predator_typesCreateNestedOneWithoutCharactersInput
    sects?: sectsCreateNestedOneWithoutCharactersInput
    users: usersCreateNestedOneWithoutCharactersInput
    exp_logs?: exp_logsCreateNestedManyWithoutCharactersInput
  }

  export type charactersUncheckedCreateWithoutCharacter_ritualsInput = {
    id?: string
    user_id: string
    name: string
    clan_id?: string | null
    clan_bane?: string | null
    clan_compulsion?: string | null
    sect_id?: string | null
    player: string
    predator_type: string
    generation: number
    chronicle_id?: string | null
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    group_id: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesUncheckedCreateNestedManyWithoutCharactersInput
    character_alchemy_powers?: character_alchemy_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesUncheckedCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesUncheckedCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsUncheckedCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityUncheckedCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileUncheckedCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsUncheckedCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesUncheckedCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersUncheckedCreateNestedManyWithoutCharactersInput
    exp_logs?: exp_logsUncheckedCreateNestedManyWithoutCharactersInput
  }

  export type charactersCreateOrConnectWithoutCharacter_ritualsInput = {
    where: charactersWhereUniqueInput
    create: XOR<charactersCreateWithoutCharacter_ritualsInput, charactersUncheckedCreateWithoutCharacter_ritualsInput>
  }

  export type ritualsCreateWithoutCharacter_ritualsInput = {
    id?: string
    name: string
    description: string
    ingridients: string
    process: string
    system: string
    level: number
  }

  export type ritualsUncheckedCreateWithoutCharacter_ritualsInput = {
    id?: string
    name: string
    description: string
    ingridients: string
    process: string
    system: string
    level: number
  }

  export type ritualsCreateOrConnectWithoutCharacter_ritualsInput = {
    where: ritualsWhereUniqueInput
    create: XOR<ritualsCreateWithoutCharacter_ritualsInput, ritualsUncheckedCreateWithoutCharacter_ritualsInput>
  }

  export type charactersUpsertWithoutCharacter_ritualsInput = {
    update: XOR<charactersUpdateWithoutCharacter_ritualsInput, charactersUncheckedUpdateWithoutCharacter_ritualsInput>
    create: XOR<charactersCreateWithoutCharacter_ritualsInput, charactersUncheckedCreateWithoutCharacter_ritualsInput>
    where?: charactersWhereInput
  }

  export type charactersUpdateToOneWithWhereWithoutCharacter_ritualsInput = {
    where?: charactersWhereInput
    data: XOR<charactersUpdateWithoutCharacter_ritualsInput, charactersUncheckedUpdateWithoutCharacter_ritualsInput>
  }

  export type charactersUpdateWithoutCharacter_ritualsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    player?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUpdateManyWithoutCharactersNestedInput
    character_alchemy_powers?: character_alchemy_powersUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUpdateManyWithoutCharactersNestedInput
    chronicles?: chroniclesUpdateOneWithoutCharactersNestedInput
    clan_banes?: clan_banesUpdateOneWithoutCharactersNestedInput
    clan_compulsions?: clan_compulsionsUpdateOneWithoutCharactersNestedInput
    clans?: clansUpdateOneWithoutCharactersNestedInput
    char_groups?: char_groupsUpdateOneRequiredWithoutCharactersNestedInput
    predator_types?: predator_typesUpdateOneRequiredWithoutCharactersNestedInput
    sects?: sectsUpdateOneWithoutCharactersNestedInput
    users?: usersUpdateOneRequiredWithoutCharactersNestedInput
    exp_logs?: exp_logsUpdateManyWithoutCharactersNestedInput
  }

  export type charactersUncheckedUpdateWithoutCharacter_ritualsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clan_id?: NullableStringFieldUpdateOperationsInput | string | null
    clan_bane?: NullableStringFieldUpdateOperationsInput | string | null
    clan_compulsion?: NullableStringFieldUpdateOperationsInput | string | null
    sect_id?: NullableStringFieldUpdateOperationsInput | string | null
    player?: StringFieldUpdateOperationsInput | string
    predator_type?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    chronicle_id?: NullableStringFieldUpdateOperationsInput | string | null
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    group_id?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUncheckedUpdateManyWithoutCharactersNestedInput
    character_alchemy_powers?: character_alchemy_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUncheckedUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUncheckedUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUncheckedUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUncheckedUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUncheckedUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUncheckedUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUncheckedUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUncheckedUpdateManyWithoutCharactersNestedInput
    exp_logs?: exp_logsUncheckedUpdateManyWithoutCharactersNestedInput
  }

  export type ritualsUpsertWithoutCharacter_ritualsInput = {
    update: XOR<ritualsUpdateWithoutCharacter_ritualsInput, ritualsUncheckedUpdateWithoutCharacter_ritualsInput>
    create: XOR<ritualsCreateWithoutCharacter_ritualsInput, ritualsUncheckedCreateWithoutCharacter_ritualsInput>
    where?: ritualsWhereInput
  }

  export type ritualsUpdateToOneWithWhereWithoutCharacter_ritualsInput = {
    where?: ritualsWhereInput
    data: XOR<ritualsUpdateWithoutCharacter_ritualsInput, ritualsUncheckedUpdateWithoutCharacter_ritualsInput>
  }

  export type ritualsUpdateWithoutCharacter_ritualsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ingridients?: StringFieldUpdateOperationsInput | string
    process?: StringFieldUpdateOperationsInput | string
    system?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
  }

  export type ritualsUncheckedUpdateWithoutCharacter_ritualsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    ingridients?: StringFieldUpdateOperationsInput | string
    process?: StringFieldUpdateOperationsInput | string
    system?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
  }

  export type charactersCreateWithoutCharacter_skillsInput = {
    id?: string
    name: string
    player: string
    generation: number
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesCreateNestedManyWithoutCharactersInput
    character_alchemy_powers?: character_alchemy_powersCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersCreateNestedManyWithoutCharactersInput
    chronicles?: chroniclesCreateNestedOneWithoutCharactersInput
    clan_banes?: clan_banesCreateNestedOneWithoutCharactersInput
    clan_compulsions?: clan_compulsionsCreateNestedOneWithoutCharactersInput
    clans?: clansCreateNestedOneWithoutCharactersInput
    char_groups: char_groupsCreateNestedOneWithoutCharactersInput
    predator_types: predator_typesCreateNestedOneWithoutCharactersInput
    sects?: sectsCreateNestedOneWithoutCharactersInput
    users: usersCreateNestedOneWithoutCharactersInput
    exp_logs?: exp_logsCreateNestedManyWithoutCharactersInput
  }

  export type charactersUncheckedCreateWithoutCharacter_skillsInput = {
    id?: string
    user_id: string
    name: string
    clan_id?: string | null
    clan_bane?: string | null
    clan_compulsion?: string | null
    sect_id?: string | null
    player: string
    predator_type: string
    generation: number
    chronicle_id?: string | null
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    group_id: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesUncheckedCreateNestedManyWithoutCharactersInput
    character_alchemy_powers?: character_alchemy_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesUncheckedCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesUncheckedCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsUncheckedCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityUncheckedCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileUncheckedCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsUncheckedCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesUncheckedCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersUncheckedCreateNestedManyWithoutCharactersInput
    exp_logs?: exp_logsUncheckedCreateNestedManyWithoutCharactersInput
  }

  export type charactersCreateOrConnectWithoutCharacter_skillsInput = {
    where: charactersWhereUniqueInput
    create: XOR<charactersCreateWithoutCharacter_skillsInput, charactersUncheckedCreateWithoutCharacter_skillsInput>
  }

  export type skillsCreateWithoutCharacter_skillsInput = {
    id?: string
    name: string
    description: string
    character_specialties?: character_specialtiesCreateNestedManyWithoutSkillsInput
  }

  export type skillsUncheckedCreateWithoutCharacter_skillsInput = {
    id?: string
    name: string
    description: string
    character_specialties?: character_specialtiesUncheckedCreateNestedManyWithoutSkillsInput
  }

  export type skillsCreateOrConnectWithoutCharacter_skillsInput = {
    where: skillsWhereUniqueInput
    create: XOR<skillsCreateWithoutCharacter_skillsInput, skillsUncheckedCreateWithoutCharacter_skillsInput>
  }

  export type charactersUpsertWithoutCharacter_skillsInput = {
    update: XOR<charactersUpdateWithoutCharacter_skillsInput, charactersUncheckedUpdateWithoutCharacter_skillsInput>
    create: XOR<charactersCreateWithoutCharacter_skillsInput, charactersUncheckedCreateWithoutCharacter_skillsInput>
    where?: charactersWhereInput
  }

  export type charactersUpdateToOneWithWhereWithoutCharacter_skillsInput = {
    where?: charactersWhereInput
    data: XOR<charactersUpdateWithoutCharacter_skillsInput, charactersUncheckedUpdateWithoutCharacter_skillsInput>
  }

  export type charactersUpdateWithoutCharacter_skillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    player?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUpdateManyWithoutCharactersNestedInput
    character_alchemy_powers?: character_alchemy_powersUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUpdateManyWithoutCharactersNestedInput
    chronicles?: chroniclesUpdateOneWithoutCharactersNestedInput
    clan_banes?: clan_banesUpdateOneWithoutCharactersNestedInput
    clan_compulsions?: clan_compulsionsUpdateOneWithoutCharactersNestedInput
    clans?: clansUpdateOneWithoutCharactersNestedInput
    char_groups?: char_groupsUpdateOneRequiredWithoutCharactersNestedInput
    predator_types?: predator_typesUpdateOneRequiredWithoutCharactersNestedInput
    sects?: sectsUpdateOneWithoutCharactersNestedInput
    users?: usersUpdateOneRequiredWithoutCharactersNestedInput
    exp_logs?: exp_logsUpdateManyWithoutCharactersNestedInput
  }

  export type charactersUncheckedUpdateWithoutCharacter_skillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clan_id?: NullableStringFieldUpdateOperationsInput | string | null
    clan_bane?: NullableStringFieldUpdateOperationsInput | string | null
    clan_compulsion?: NullableStringFieldUpdateOperationsInput | string | null
    sect_id?: NullableStringFieldUpdateOperationsInput | string | null
    player?: StringFieldUpdateOperationsInput | string
    predator_type?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    chronicle_id?: NullableStringFieldUpdateOperationsInput | string | null
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    group_id?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUncheckedUpdateManyWithoutCharactersNestedInput
    character_alchemy_powers?: character_alchemy_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUncheckedUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUncheckedUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUncheckedUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUncheckedUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUncheckedUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUncheckedUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUncheckedUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUncheckedUpdateManyWithoutCharactersNestedInput
    exp_logs?: exp_logsUncheckedUpdateManyWithoutCharactersNestedInput
  }

  export type skillsUpsertWithoutCharacter_skillsInput = {
    update: XOR<skillsUpdateWithoutCharacter_skillsInput, skillsUncheckedUpdateWithoutCharacter_skillsInput>
    create: XOR<skillsCreateWithoutCharacter_skillsInput, skillsUncheckedCreateWithoutCharacter_skillsInput>
    where?: skillsWhereInput
  }

  export type skillsUpdateToOneWithWhereWithoutCharacter_skillsInput = {
    where?: skillsWhereInput
    data: XOR<skillsUpdateWithoutCharacter_skillsInput, skillsUncheckedUpdateWithoutCharacter_skillsInput>
  }

  export type skillsUpdateWithoutCharacter_skillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    character_specialties?: character_specialtiesUpdateManyWithoutSkillsNestedInput
  }

  export type skillsUncheckedUpdateWithoutCharacter_skillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    character_specialties?: character_specialtiesUncheckedUpdateManyWithoutSkillsNestedInput
  }

  export type charactersCreateWithoutCharacter_specialtiesInput = {
    id?: string
    name: string
    player: string
    generation: number
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesCreateNestedManyWithoutCharactersInput
    character_alchemy_powers?: character_alchemy_powersCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersCreateNestedManyWithoutCharactersInput
    chronicles?: chroniclesCreateNestedOneWithoutCharactersInput
    clan_banes?: clan_banesCreateNestedOneWithoutCharactersInput
    clan_compulsions?: clan_compulsionsCreateNestedOneWithoutCharactersInput
    clans?: clansCreateNestedOneWithoutCharactersInput
    char_groups: char_groupsCreateNestedOneWithoutCharactersInput
    predator_types: predator_typesCreateNestedOneWithoutCharactersInput
    sects?: sectsCreateNestedOneWithoutCharactersInput
    users: usersCreateNestedOneWithoutCharactersInput
    exp_logs?: exp_logsCreateNestedManyWithoutCharactersInput
  }

  export type charactersUncheckedCreateWithoutCharacter_specialtiesInput = {
    id?: string
    user_id: string
    name: string
    clan_id?: string | null
    clan_bane?: string | null
    clan_compulsion?: string | null
    sect_id?: string | null
    player: string
    predator_type: string
    generation: number
    chronicle_id?: string | null
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    group_id: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesUncheckedCreateNestedManyWithoutCharactersInput
    character_alchemy_powers?: character_alchemy_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesUncheckedCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesUncheckedCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsUncheckedCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityUncheckedCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileUncheckedCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsUncheckedCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsUncheckedCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersUncheckedCreateNestedManyWithoutCharactersInput
    exp_logs?: exp_logsUncheckedCreateNestedManyWithoutCharactersInput
  }

  export type charactersCreateOrConnectWithoutCharacter_specialtiesInput = {
    where: charactersWhereUniqueInput
    create: XOR<charactersCreateWithoutCharacter_specialtiesInput, charactersUncheckedCreateWithoutCharacter_specialtiesInput>
  }

  export type skillsCreateWithoutCharacter_specialtiesInput = {
    id?: string
    name: string
    description: string
    character_skills?: character_skillsCreateNestedManyWithoutSkillsInput
  }

  export type skillsUncheckedCreateWithoutCharacter_specialtiesInput = {
    id?: string
    name: string
    description: string
    character_skills?: character_skillsUncheckedCreateNestedManyWithoutSkillsInput
  }

  export type skillsCreateOrConnectWithoutCharacter_specialtiesInput = {
    where: skillsWhereUniqueInput
    create: XOR<skillsCreateWithoutCharacter_specialtiesInput, skillsUncheckedCreateWithoutCharacter_specialtiesInput>
  }

  export type charactersUpsertWithoutCharacter_specialtiesInput = {
    update: XOR<charactersUpdateWithoutCharacter_specialtiesInput, charactersUncheckedUpdateWithoutCharacter_specialtiesInput>
    create: XOR<charactersCreateWithoutCharacter_specialtiesInput, charactersUncheckedCreateWithoutCharacter_specialtiesInput>
    where?: charactersWhereInput
  }

  export type charactersUpdateToOneWithWhereWithoutCharacter_specialtiesInput = {
    where?: charactersWhereInput
    data: XOR<charactersUpdateWithoutCharacter_specialtiesInput, charactersUncheckedUpdateWithoutCharacter_specialtiesInput>
  }

  export type charactersUpdateWithoutCharacter_specialtiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    player?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUpdateManyWithoutCharactersNestedInput
    character_alchemy_powers?: character_alchemy_powersUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUpdateManyWithoutCharactersNestedInput
    chronicles?: chroniclesUpdateOneWithoutCharactersNestedInput
    clan_banes?: clan_banesUpdateOneWithoutCharactersNestedInput
    clan_compulsions?: clan_compulsionsUpdateOneWithoutCharactersNestedInput
    clans?: clansUpdateOneWithoutCharactersNestedInput
    char_groups?: char_groupsUpdateOneRequiredWithoutCharactersNestedInput
    predator_types?: predator_typesUpdateOneRequiredWithoutCharactersNestedInput
    sects?: sectsUpdateOneWithoutCharactersNestedInput
    users?: usersUpdateOneRequiredWithoutCharactersNestedInput
    exp_logs?: exp_logsUpdateManyWithoutCharactersNestedInput
  }

  export type charactersUncheckedUpdateWithoutCharacter_specialtiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clan_id?: NullableStringFieldUpdateOperationsInput | string | null
    clan_bane?: NullableStringFieldUpdateOperationsInput | string | null
    clan_compulsion?: NullableStringFieldUpdateOperationsInput | string | null
    sect_id?: NullableStringFieldUpdateOperationsInput | string | null
    player?: StringFieldUpdateOperationsInput | string
    predator_type?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    chronicle_id?: NullableStringFieldUpdateOperationsInput | string | null
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    group_id?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUncheckedUpdateManyWithoutCharactersNestedInput
    character_alchemy_powers?: character_alchemy_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUncheckedUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUncheckedUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUncheckedUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUncheckedUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUncheckedUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUncheckedUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUncheckedUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUncheckedUpdateManyWithoutCharactersNestedInput
    exp_logs?: exp_logsUncheckedUpdateManyWithoutCharactersNestedInput
  }

  export type skillsUpsertWithoutCharacter_specialtiesInput = {
    update: XOR<skillsUpdateWithoutCharacter_specialtiesInput, skillsUncheckedUpdateWithoutCharacter_specialtiesInput>
    create: XOR<skillsCreateWithoutCharacter_specialtiesInput, skillsUncheckedCreateWithoutCharacter_specialtiesInput>
    where?: skillsWhereInput
  }

  export type skillsUpdateToOneWithWhereWithoutCharacter_specialtiesInput = {
    where?: skillsWhereInput
    data: XOR<skillsUpdateWithoutCharacter_specialtiesInput, skillsUncheckedUpdateWithoutCharacter_specialtiesInput>
  }

  export type skillsUpdateWithoutCharacter_specialtiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    character_skills?: character_skillsUpdateManyWithoutSkillsNestedInput
  }

  export type skillsUncheckedUpdateWithoutCharacter_specialtiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    character_skills?: character_skillsUncheckedUpdateManyWithoutSkillsNestedInput
  }

  export type charactersCreateWithoutCharacter_willpowersInput = {
    id?: string
    name: string
    player: string
    generation: number
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesCreateNestedManyWithoutCharactersInput
    character_alchemy_powers?: character_alchemy_powersCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesCreateNestedManyWithoutCharactersInput
    chronicles?: chroniclesCreateNestedOneWithoutCharactersInput
    clan_banes?: clan_banesCreateNestedOneWithoutCharactersInput
    clan_compulsions?: clan_compulsionsCreateNestedOneWithoutCharactersInput
    clans?: clansCreateNestedOneWithoutCharactersInput
    char_groups: char_groupsCreateNestedOneWithoutCharactersInput
    predator_types: predator_typesCreateNestedOneWithoutCharactersInput
    sects?: sectsCreateNestedOneWithoutCharactersInput
    users: usersCreateNestedOneWithoutCharactersInput
    exp_logs?: exp_logsCreateNestedManyWithoutCharactersInput
  }

  export type charactersUncheckedCreateWithoutCharacter_willpowersInput = {
    id?: string
    user_id: string
    name: string
    clan_id?: string | null
    clan_bane?: string | null
    clan_compulsion?: string | null
    sect_id?: string | null
    player: string
    predator_type: string
    generation: number
    chronicle_id?: string | null
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    group_id: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesUncheckedCreateNestedManyWithoutCharactersInput
    character_alchemy_powers?: character_alchemy_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesUncheckedCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesUncheckedCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsUncheckedCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityUncheckedCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileUncheckedCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsUncheckedCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsUncheckedCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesUncheckedCreateNestedManyWithoutCharactersInput
    exp_logs?: exp_logsUncheckedCreateNestedManyWithoutCharactersInput
  }

  export type charactersCreateOrConnectWithoutCharacter_willpowersInput = {
    where: charactersWhereUniqueInput
    create: XOR<charactersCreateWithoutCharacter_willpowersInput, charactersUncheckedCreateWithoutCharacter_willpowersInput>
  }

  export type charactersUpsertWithoutCharacter_willpowersInput = {
    update: XOR<charactersUpdateWithoutCharacter_willpowersInput, charactersUncheckedUpdateWithoutCharacter_willpowersInput>
    create: XOR<charactersCreateWithoutCharacter_willpowersInput, charactersUncheckedCreateWithoutCharacter_willpowersInput>
    where?: charactersWhereInput
  }

  export type charactersUpdateToOneWithWhereWithoutCharacter_willpowersInput = {
    where?: charactersWhereInput
    data: XOR<charactersUpdateWithoutCharacter_willpowersInput, charactersUncheckedUpdateWithoutCharacter_willpowersInput>
  }

  export type charactersUpdateWithoutCharacter_willpowersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    player?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUpdateManyWithoutCharactersNestedInput
    character_alchemy_powers?: character_alchemy_powersUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUpdateManyWithoutCharactersNestedInput
    chronicles?: chroniclesUpdateOneWithoutCharactersNestedInput
    clan_banes?: clan_banesUpdateOneWithoutCharactersNestedInput
    clan_compulsions?: clan_compulsionsUpdateOneWithoutCharactersNestedInput
    clans?: clansUpdateOneWithoutCharactersNestedInput
    char_groups?: char_groupsUpdateOneRequiredWithoutCharactersNestedInput
    predator_types?: predator_typesUpdateOneRequiredWithoutCharactersNestedInput
    sects?: sectsUpdateOneWithoutCharactersNestedInput
    users?: usersUpdateOneRequiredWithoutCharactersNestedInput
    exp_logs?: exp_logsUpdateManyWithoutCharactersNestedInput
  }

  export type charactersUncheckedUpdateWithoutCharacter_willpowersInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clan_id?: NullableStringFieldUpdateOperationsInput | string | null
    clan_bane?: NullableStringFieldUpdateOperationsInput | string | null
    clan_compulsion?: NullableStringFieldUpdateOperationsInput | string | null
    sect_id?: NullableStringFieldUpdateOperationsInput | string | null
    player?: StringFieldUpdateOperationsInput | string
    predator_type?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    chronicle_id?: NullableStringFieldUpdateOperationsInput | string | null
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    group_id?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUncheckedUpdateManyWithoutCharactersNestedInput
    character_alchemy_powers?: character_alchemy_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUncheckedUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUncheckedUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUncheckedUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUncheckedUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUncheckedUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUncheckedUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUncheckedUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUncheckedUpdateManyWithoutCharactersNestedInput
    exp_logs?: exp_logsUncheckedUpdateManyWithoutCharactersNestedInput
  }

  export type character_advantagesCreateWithoutCharactersInput = {
    id?: string
    advantages: advantagesCreateNestedOneWithoutCharacter_advantagesInput
  }

  export type character_advantagesUncheckedCreateWithoutCharactersInput = {
    id?: string
    advantage_id: string
  }

  export type character_advantagesCreateOrConnectWithoutCharactersInput = {
    where: character_advantagesWhereUniqueInput
    create: XOR<character_advantagesCreateWithoutCharactersInput, character_advantagesUncheckedCreateWithoutCharactersInput>
  }

  export type character_advantagesCreateManyCharactersInputEnvelope = {
    data: character_advantagesCreateManyCharactersInput | character_advantagesCreateManyCharactersInput[]
    skipDuplicates?: boolean
  }

  export type character_alchemy_powersCreateWithoutCharactersInput = {
    id?: string
    alchemy_powers: alchemy_powersCreateNestedOneWithoutCharacter_alchemy_powersInput
  }

  export type character_alchemy_powersUncheckedCreateWithoutCharactersInput = {
    id?: string
    alchemy_power_id: string
  }

  export type character_alchemy_powersCreateOrConnectWithoutCharactersInput = {
    where: character_alchemy_powersWhereUniqueInput
    create: XOR<character_alchemy_powersCreateWithoutCharactersInput, character_alchemy_powersUncheckedCreateWithoutCharactersInput>
  }

  export type character_alchemy_powersCreateManyCharactersInputEnvelope = {
    data: character_alchemy_powersCreateManyCharactersInput | character_alchemy_powersCreateManyCharactersInput[]
    skipDuplicates?: boolean
  }

  export type character_attributesCreateWithoutCharactersInput = {
    id?: string
    level?: number
    attributes: attributesCreateNestedOneWithoutCharacter_attributesInput
  }

  export type character_attributesUncheckedCreateWithoutCharactersInput = {
    id?: string
    attribute_id: string
    level?: number
  }

  export type character_attributesCreateOrConnectWithoutCharactersInput = {
    where: character_attributesWhereUniqueInput
    create: XOR<character_attributesCreateWithoutCharactersInput, character_attributesUncheckedCreateWithoutCharactersInput>
  }

  export type character_attributesCreateManyCharactersInputEnvelope = {
    data: character_attributesCreateManyCharactersInput | character_attributesCreateManyCharactersInput[]
    skipDuplicates?: boolean
  }

  export type character_bloodpotenciesCreateWithoutCharactersInput = {
    id?: string
    blood_surge?: string | null
    bane_severity?: number | null
    power_bonus?: string | null
    feeding_penalty?: string | null
    mend_amount?: number | null
    rc_reroll?: string | null
    blood_potency?: blood_potencyCreateNestedOneWithoutCharacter_bloodpotenciesInput
    clan_compulsions?: clan_compulsionsCreateNestedOneWithoutCharacter_bloodpotenciesInput
    clan_banes?: clan_banesCreateNestedOneWithoutCharacter_bloodpotenciesInput
  }

  export type character_bloodpotenciesUncheckedCreateWithoutCharactersInput = {
    id?: string
    blood_potency_level?: string | null
    blood_surge?: string | null
    bane_severity?: number | null
    power_bonus?: string | null
    feeding_penalty?: string | null
    mend_amount?: number | null
    rc_reroll?: string | null
    clane_bane?: string | null
    clan_compulsion?: string | null
  }

  export type character_bloodpotenciesCreateOrConnectWithoutCharactersInput = {
    where: character_bloodpotenciesWhereUniqueInput
    create: XOR<character_bloodpotenciesCreateWithoutCharactersInput, character_bloodpotenciesUncheckedCreateWithoutCharactersInput>
  }

  export type character_bloodpotenciesCreateManyCharactersInputEnvelope = {
    data: character_bloodpotenciesCreateManyCharactersInput | character_bloodpotenciesCreateManyCharactersInput[]
    skipDuplicates?: boolean
  }

  export type character_discipline_powersCreateWithoutCharactersInput = {
    id?: string
    discipline_powers: discipline_powersCreateNestedOneWithoutCharacter_discipline_powersInput
  }

  export type character_discipline_powersUncheckedCreateWithoutCharactersInput = {
    id?: string
    discipline_power_id: string
  }

  export type character_discipline_powersCreateOrConnectWithoutCharactersInput = {
    where: character_discipline_powersWhereUniqueInput
    create: XOR<character_discipline_powersCreateWithoutCharactersInput, character_discipline_powersUncheckedCreateWithoutCharactersInput>
  }

  export type character_discipline_powersCreateManyCharactersInputEnvelope = {
    data: character_discipline_powersCreateManyCharactersInput | character_discipline_powersCreateManyCharactersInput[]
    skipDuplicates?: boolean
  }

  export type character_disciplinesCreateWithoutCharactersInput = {
    id?: string
    disciplines: disciplinesCreateNestedOneWithoutCharacter_disciplinesInput
  }

  export type character_disciplinesUncheckedCreateWithoutCharactersInput = {
    id?: string
    discipline_id: string
  }

  export type character_disciplinesCreateOrConnectWithoutCharactersInput = {
    where: character_disciplinesWhereUniqueInput
    create: XOR<character_disciplinesCreateWithoutCharactersInput, character_disciplinesUncheckedCreateWithoutCharactersInput>
  }

  export type character_disciplinesCreateManyCharactersInputEnvelope = {
    data: character_disciplinesCreateManyCharactersInput | character_disciplinesCreateManyCharactersInput[]
    skipDuplicates?: boolean
  }

  export type character_healthsCreateWithoutCharactersInput = {
    id?: string
    max_health: number
    current_aggravated?: number
    current_superficial?: number
  }

  export type character_healthsUncheckedCreateWithoutCharactersInput = {
    id?: string
    max_health: number
    current_aggravated?: number
    current_superficial?: number
  }

  export type character_healthsCreateOrConnectWithoutCharactersInput = {
    where: character_healthsWhereUniqueInput
    create: XOR<character_healthsCreateWithoutCharactersInput, character_healthsUncheckedCreateWithoutCharactersInput>
  }

  export type character_healthsCreateManyCharactersInputEnvelope = {
    data: character_healthsCreateManyCharactersInput | character_healthsCreateManyCharactersInput[]
    skipDuplicates?: boolean
  }

  export type character_humanityCreateWithoutCharactersInput = {
    id?: string
    level?: number
    stain_count?: number
  }

  export type character_humanityUncheckedCreateWithoutCharactersInput = {
    id?: string
    level?: number
    stain_count?: number
  }

  export type character_humanityCreateOrConnectWithoutCharactersInput = {
    where: character_humanityWhereUniqueInput
    create: XOR<character_humanityCreateWithoutCharactersInput, character_humanityUncheckedCreateWithoutCharactersInput>
  }

  export type character_humanityCreateManyCharactersInputEnvelope = {
    data: character_humanityCreateManyCharactersInput | character_humanityCreateManyCharactersInput[]
    skipDuplicates?: boolean
  }

  export type character_profileCreateWithoutCharactersInput = {
    id?: string
    description: string
    birthday: Date | string
    notes?: string | null
    age: number
    embraced_at: Date | string
    apparent_age: number
    concept?: string | null
  }

  export type character_profileUncheckedCreateWithoutCharactersInput = {
    id?: string
    description: string
    birthday: Date | string
    notes?: string | null
    age: number
    embraced_at: Date | string
    apparent_age: number
    concept?: string | null
  }

  export type character_profileCreateOrConnectWithoutCharactersInput = {
    where: character_profileWhereUniqueInput
    create: XOR<character_profileCreateWithoutCharactersInput, character_profileUncheckedCreateWithoutCharactersInput>
  }

  export type character_profileCreateManyCharactersInputEnvelope = {
    data: character_profileCreateManyCharactersInput | character_profileCreateManyCharactersInput[]
    skipDuplicates?: boolean
  }

  export type character_ritualsCreateWithoutCharactersInput = {
    id?: string
    rituals: ritualsCreateNestedOneWithoutCharacter_ritualsInput
  }

  export type character_ritualsUncheckedCreateWithoutCharactersInput = {
    id?: string
    ritual_id: string
  }

  export type character_ritualsCreateOrConnectWithoutCharactersInput = {
    where: character_ritualsWhereUniqueInput
    create: XOR<character_ritualsCreateWithoutCharactersInput, character_ritualsUncheckedCreateWithoutCharactersInput>
  }

  export type character_ritualsCreateManyCharactersInputEnvelope = {
    data: character_ritualsCreateManyCharactersInput | character_ritualsCreateManyCharactersInput[]
    skipDuplicates?: boolean
  }

  export type character_skillsCreateWithoutCharactersInput = {
    id?: string
    level?: number
    skills: skillsCreateNestedOneWithoutCharacter_skillsInput
  }

  export type character_skillsUncheckedCreateWithoutCharactersInput = {
    id?: string
    skill_id: string
    level?: number
  }

  export type character_skillsCreateOrConnectWithoutCharactersInput = {
    where: character_skillsWhereUniqueInput
    create: XOR<character_skillsCreateWithoutCharactersInput, character_skillsUncheckedCreateWithoutCharactersInput>
  }

  export type character_skillsCreateManyCharactersInputEnvelope = {
    data: character_skillsCreateManyCharactersInput | character_skillsCreateManyCharactersInput[]
    skipDuplicates?: boolean
  }

  export type character_specialtiesCreateWithoutCharactersInput = {
    id?: string
    specialty_name: string
    skills: skillsCreateNestedOneWithoutCharacter_specialtiesInput
  }

  export type character_specialtiesUncheckedCreateWithoutCharactersInput = {
    id?: string
    skill_id: string
    specialty_name: string
  }

  export type character_specialtiesCreateOrConnectWithoutCharactersInput = {
    where: character_specialtiesWhereUniqueInput
    create: XOR<character_specialtiesCreateWithoutCharactersInput, character_specialtiesUncheckedCreateWithoutCharactersInput>
  }

  export type character_specialtiesCreateManyCharactersInputEnvelope = {
    data: character_specialtiesCreateManyCharactersInput | character_specialtiesCreateManyCharactersInput[]
    skipDuplicates?: boolean
  }

  export type character_willpowersCreateWithoutCharactersInput = {
    id?: string
    max_willpower: number
    current_aggravated?: number
    current_superficial?: number
  }

  export type character_willpowersUncheckedCreateWithoutCharactersInput = {
    id?: string
    max_willpower: number
    current_aggravated?: number
    current_superficial?: number
  }

  export type character_willpowersCreateOrConnectWithoutCharactersInput = {
    where: character_willpowersWhereUniqueInput
    create: XOR<character_willpowersCreateWithoutCharactersInput, character_willpowersUncheckedCreateWithoutCharactersInput>
  }

  export type character_willpowersCreateManyCharactersInputEnvelope = {
    data: character_willpowersCreateManyCharactersInput | character_willpowersCreateManyCharactersInput[]
    skipDuplicates?: boolean
  }

  export type chroniclesCreateWithoutCharactersInput = {
    id?: string
    name: string
    description: string
    created_at?: Date | string
    updated_at?: Date | string
    users: usersCreateNestedOneWithoutChroniclesInput
  }

  export type chroniclesUncheckedCreateWithoutCharactersInput = {
    id?: string
    user_id: string
    name: string
    description: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type chroniclesCreateOrConnectWithoutCharactersInput = {
    where: chroniclesWhereUniqueInput
    create: XOR<chroniclesCreateWithoutCharactersInput, chroniclesUncheckedCreateWithoutCharactersInput>
  }

  export type clan_banesCreateWithoutCharactersInput = {
    id?: string
    name: string
    description: string
    character_bloodpotencies?: character_bloodpotenciesCreateNestedManyWithoutClan_banesInput
    clans: clansCreateNestedOneWithoutClan_banesInput
  }

  export type clan_banesUncheckedCreateWithoutCharactersInput = {
    id?: string
    name: string
    clan_id: string
    description: string
    character_bloodpotencies?: character_bloodpotenciesUncheckedCreateNestedManyWithoutClan_banesInput
  }

  export type clan_banesCreateOrConnectWithoutCharactersInput = {
    where: clan_banesWhereUniqueInput
    create: XOR<clan_banesCreateWithoutCharactersInput, clan_banesUncheckedCreateWithoutCharactersInput>
  }

  export type clan_compulsionsCreateWithoutCharactersInput = {
    id?: string
    name: string
    description: string
    character_bloodpotencies?: character_bloodpotenciesCreateNestedManyWithoutClan_compulsionsInput
    clans: clansCreateNestedOneWithoutClan_compulsionsInput
  }

  export type clan_compulsionsUncheckedCreateWithoutCharactersInput = {
    id?: string
    name: string
    clan_id: string
    description: string
    character_bloodpotencies?: character_bloodpotenciesUncheckedCreateNestedManyWithoutClan_compulsionsInput
  }

  export type clan_compulsionsCreateOrConnectWithoutCharactersInput = {
    where: clan_compulsionsWhereUniqueInput
    create: XOR<clan_compulsionsCreateWithoutCharactersInput, clan_compulsionsUncheckedCreateWithoutCharactersInput>
  }

  export type clansCreateWithoutCharactersInput = {
    id?: string
    name: string
    description: string
    advantages?: advantagesCreateNestedManyWithoutClansInput
    clan_banes?: clan_banesCreateNestedManyWithoutClansInput
    clan_compulsions?: clan_compulsionsCreateNestedManyWithoutClansInput
  }

  export type clansUncheckedCreateWithoutCharactersInput = {
    id?: string
    name: string
    description: string
    advantages?: advantagesUncheckedCreateNestedManyWithoutClansInput
    clan_banes?: clan_banesUncheckedCreateNestedManyWithoutClansInput
    clan_compulsions?: clan_compulsionsUncheckedCreateNestedManyWithoutClansInput
  }

  export type clansCreateOrConnectWithoutCharactersInput = {
    where: clansWhereUniqueInput
    create: XOR<clansCreateWithoutCharactersInput, clansUncheckedCreateWithoutCharactersInput>
  }

  export type char_groupsCreateWithoutCharactersInput = {
    id?: string
    name: string
    description: string
    char_groups?: char_groupsCreateNestedOneWithoutOther_char_groupsInput
    other_char_groups?: char_groupsCreateNestedManyWithoutChar_groupsInput
    users: usersCreateNestedOneWithoutChar_groupsInput
  }

  export type char_groupsUncheckedCreateWithoutCharactersInput = {
    id?: string
    user_id: string
    parent_id?: string | null
    name: string
    description: string
    other_char_groups?: char_groupsUncheckedCreateNestedManyWithoutChar_groupsInput
  }

  export type char_groupsCreateOrConnectWithoutCharactersInput = {
    where: char_groupsWhereUniqueInput
    create: XOR<char_groupsCreateWithoutCharactersInput, char_groupsUncheckedCreateWithoutCharactersInput>
  }

  export type predator_typesCreateWithoutCharactersInput = {
    id?: string
    name: string
    description: string
    dice_pool: string
    benefits: string
  }

  export type predator_typesUncheckedCreateWithoutCharactersInput = {
    id?: string
    name: string
    description: string
    dice_pool: string
    benefits: string
  }

  export type predator_typesCreateOrConnectWithoutCharactersInput = {
    where: predator_typesWhereUniqueInput
    create: XOR<predator_typesCreateWithoutCharactersInput, predator_typesUncheckedCreateWithoutCharactersInput>
  }

  export type sectsCreateWithoutCharactersInput = {
    id?: string
    name: string
    description: string
    advantages?: advantagesCreateNestedManyWithoutSectsInput
  }

  export type sectsUncheckedCreateWithoutCharactersInput = {
    id?: string
    name: string
    description: string
    advantages?: advantagesUncheckedCreateNestedManyWithoutSectsInput
  }

  export type sectsCreateOrConnectWithoutCharactersInput = {
    where: sectsWhereUniqueInput
    create: XOR<sectsCreateWithoutCharactersInput, sectsUncheckedCreateWithoutCharactersInput>
  }

  export type usersCreateWithoutCharactersInput = {
    id?: string
    clerk_user_id: string
    email: string
    name: string
    image_url?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    char_groups?: char_groupsCreateNestedManyWithoutUsersInput
    chronicles?: chroniclesCreateNestedManyWithoutUsersInput
    exp_logs?: exp_logsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutCharactersInput = {
    id?: string
    clerk_user_id: string
    email: string
    name: string
    image_url?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    char_groups?: char_groupsUncheckedCreateNestedManyWithoutUsersInput
    chronicles?: chroniclesUncheckedCreateNestedManyWithoutUsersInput
    exp_logs?: exp_logsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutCharactersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutCharactersInput, usersUncheckedCreateWithoutCharactersInput>
  }

  export type exp_logsCreateWithoutCharactersInput = {
    id?: string
    section?: string | null
    name?: string | null
    prev_level?: number | null
    new_level?: number | null
    expanditure?: number | null
    created_at?: Date | string
    users: usersCreateNestedOneWithoutExp_logsInput
  }

  export type exp_logsUncheckedCreateWithoutCharactersInput = {
    id?: string
    user_id: string
    section?: string | null
    name?: string | null
    prev_level?: number | null
    new_level?: number | null
    expanditure?: number | null
    created_at?: Date | string
  }

  export type exp_logsCreateOrConnectWithoutCharactersInput = {
    where: exp_logsWhereUniqueInput
    create: XOR<exp_logsCreateWithoutCharactersInput, exp_logsUncheckedCreateWithoutCharactersInput>
  }

  export type exp_logsCreateManyCharactersInputEnvelope = {
    data: exp_logsCreateManyCharactersInput | exp_logsCreateManyCharactersInput[]
    skipDuplicates?: boolean
  }

  export type character_advantagesUpsertWithWhereUniqueWithoutCharactersInput = {
    where: character_advantagesWhereUniqueInput
    update: XOR<character_advantagesUpdateWithoutCharactersInput, character_advantagesUncheckedUpdateWithoutCharactersInput>
    create: XOR<character_advantagesCreateWithoutCharactersInput, character_advantagesUncheckedCreateWithoutCharactersInput>
  }

  export type character_advantagesUpdateWithWhereUniqueWithoutCharactersInput = {
    where: character_advantagesWhereUniqueInput
    data: XOR<character_advantagesUpdateWithoutCharactersInput, character_advantagesUncheckedUpdateWithoutCharactersInput>
  }

  export type character_advantagesUpdateManyWithWhereWithoutCharactersInput = {
    where: character_advantagesScalarWhereInput
    data: XOR<character_advantagesUpdateManyMutationInput, character_advantagesUncheckedUpdateManyWithoutCharactersInput>
  }

  export type character_alchemy_powersUpsertWithWhereUniqueWithoutCharactersInput = {
    where: character_alchemy_powersWhereUniqueInput
    update: XOR<character_alchemy_powersUpdateWithoutCharactersInput, character_alchemy_powersUncheckedUpdateWithoutCharactersInput>
    create: XOR<character_alchemy_powersCreateWithoutCharactersInput, character_alchemy_powersUncheckedCreateWithoutCharactersInput>
  }

  export type character_alchemy_powersUpdateWithWhereUniqueWithoutCharactersInput = {
    where: character_alchemy_powersWhereUniqueInput
    data: XOR<character_alchemy_powersUpdateWithoutCharactersInput, character_alchemy_powersUncheckedUpdateWithoutCharactersInput>
  }

  export type character_alchemy_powersUpdateManyWithWhereWithoutCharactersInput = {
    where: character_alchemy_powersScalarWhereInput
    data: XOR<character_alchemy_powersUpdateManyMutationInput, character_alchemy_powersUncheckedUpdateManyWithoutCharactersInput>
  }

  export type character_attributesUpsertWithWhereUniqueWithoutCharactersInput = {
    where: character_attributesWhereUniqueInput
    update: XOR<character_attributesUpdateWithoutCharactersInput, character_attributesUncheckedUpdateWithoutCharactersInput>
    create: XOR<character_attributesCreateWithoutCharactersInput, character_attributesUncheckedCreateWithoutCharactersInput>
  }

  export type character_attributesUpdateWithWhereUniqueWithoutCharactersInput = {
    where: character_attributesWhereUniqueInput
    data: XOR<character_attributesUpdateWithoutCharactersInput, character_attributesUncheckedUpdateWithoutCharactersInput>
  }

  export type character_attributesUpdateManyWithWhereWithoutCharactersInput = {
    where: character_attributesScalarWhereInput
    data: XOR<character_attributesUpdateManyMutationInput, character_attributesUncheckedUpdateManyWithoutCharactersInput>
  }

  export type character_bloodpotenciesUpsertWithWhereUniqueWithoutCharactersInput = {
    where: character_bloodpotenciesWhereUniqueInput
    update: XOR<character_bloodpotenciesUpdateWithoutCharactersInput, character_bloodpotenciesUncheckedUpdateWithoutCharactersInput>
    create: XOR<character_bloodpotenciesCreateWithoutCharactersInput, character_bloodpotenciesUncheckedCreateWithoutCharactersInput>
  }

  export type character_bloodpotenciesUpdateWithWhereUniqueWithoutCharactersInput = {
    where: character_bloodpotenciesWhereUniqueInput
    data: XOR<character_bloodpotenciesUpdateWithoutCharactersInput, character_bloodpotenciesUncheckedUpdateWithoutCharactersInput>
  }

  export type character_bloodpotenciesUpdateManyWithWhereWithoutCharactersInput = {
    where: character_bloodpotenciesScalarWhereInput
    data: XOR<character_bloodpotenciesUpdateManyMutationInput, character_bloodpotenciesUncheckedUpdateManyWithoutCharactersInput>
  }

  export type character_discipline_powersUpsertWithWhereUniqueWithoutCharactersInput = {
    where: character_discipline_powersWhereUniqueInput
    update: XOR<character_discipline_powersUpdateWithoutCharactersInput, character_discipline_powersUncheckedUpdateWithoutCharactersInput>
    create: XOR<character_discipline_powersCreateWithoutCharactersInput, character_discipline_powersUncheckedCreateWithoutCharactersInput>
  }

  export type character_discipline_powersUpdateWithWhereUniqueWithoutCharactersInput = {
    where: character_discipline_powersWhereUniqueInput
    data: XOR<character_discipline_powersUpdateWithoutCharactersInput, character_discipline_powersUncheckedUpdateWithoutCharactersInput>
  }

  export type character_discipline_powersUpdateManyWithWhereWithoutCharactersInput = {
    where: character_discipline_powersScalarWhereInput
    data: XOR<character_discipline_powersUpdateManyMutationInput, character_discipline_powersUncheckedUpdateManyWithoutCharactersInput>
  }

  export type character_discipline_powersScalarWhereInput = {
    AND?: character_discipline_powersScalarWhereInput | character_discipline_powersScalarWhereInput[]
    OR?: character_discipline_powersScalarWhereInput[]
    NOT?: character_discipline_powersScalarWhereInput | character_discipline_powersScalarWhereInput[]
    id?: UuidFilter<"character_discipline_powers"> | string
    char_id?: UuidFilter<"character_discipline_powers"> | string
    discipline_power_id?: UuidFilter<"character_discipline_powers"> | string
  }

  export type character_disciplinesUpsertWithWhereUniqueWithoutCharactersInput = {
    where: character_disciplinesWhereUniqueInput
    update: XOR<character_disciplinesUpdateWithoutCharactersInput, character_disciplinesUncheckedUpdateWithoutCharactersInput>
    create: XOR<character_disciplinesCreateWithoutCharactersInput, character_disciplinesUncheckedCreateWithoutCharactersInput>
  }

  export type character_disciplinesUpdateWithWhereUniqueWithoutCharactersInput = {
    where: character_disciplinesWhereUniqueInput
    data: XOR<character_disciplinesUpdateWithoutCharactersInput, character_disciplinesUncheckedUpdateWithoutCharactersInput>
  }

  export type character_disciplinesUpdateManyWithWhereWithoutCharactersInput = {
    where: character_disciplinesScalarWhereInput
    data: XOR<character_disciplinesUpdateManyMutationInput, character_disciplinesUncheckedUpdateManyWithoutCharactersInput>
  }

  export type character_disciplinesScalarWhereInput = {
    AND?: character_disciplinesScalarWhereInput | character_disciplinesScalarWhereInput[]
    OR?: character_disciplinesScalarWhereInput[]
    NOT?: character_disciplinesScalarWhereInput | character_disciplinesScalarWhereInput[]
    id?: UuidFilter<"character_disciplines"> | string
    char_id?: UuidFilter<"character_disciplines"> | string
    discipline_id?: UuidFilter<"character_disciplines"> | string
  }

  export type character_healthsUpsertWithWhereUniqueWithoutCharactersInput = {
    where: character_healthsWhereUniqueInput
    update: XOR<character_healthsUpdateWithoutCharactersInput, character_healthsUncheckedUpdateWithoutCharactersInput>
    create: XOR<character_healthsCreateWithoutCharactersInput, character_healthsUncheckedCreateWithoutCharactersInput>
  }

  export type character_healthsUpdateWithWhereUniqueWithoutCharactersInput = {
    where: character_healthsWhereUniqueInput
    data: XOR<character_healthsUpdateWithoutCharactersInput, character_healthsUncheckedUpdateWithoutCharactersInput>
  }

  export type character_healthsUpdateManyWithWhereWithoutCharactersInput = {
    where: character_healthsScalarWhereInput
    data: XOR<character_healthsUpdateManyMutationInput, character_healthsUncheckedUpdateManyWithoutCharactersInput>
  }

  export type character_healthsScalarWhereInput = {
    AND?: character_healthsScalarWhereInput | character_healthsScalarWhereInput[]
    OR?: character_healthsScalarWhereInput[]
    NOT?: character_healthsScalarWhereInput | character_healthsScalarWhereInput[]
    id?: UuidFilter<"character_healths"> | string
    char_id?: UuidFilter<"character_healths"> | string
    max_health?: IntFilter<"character_healths"> | number
    current_aggravated?: IntFilter<"character_healths"> | number
    current_superficial?: IntFilter<"character_healths"> | number
  }

  export type character_humanityUpsertWithWhereUniqueWithoutCharactersInput = {
    where: character_humanityWhereUniqueInput
    update: XOR<character_humanityUpdateWithoutCharactersInput, character_humanityUncheckedUpdateWithoutCharactersInput>
    create: XOR<character_humanityCreateWithoutCharactersInput, character_humanityUncheckedCreateWithoutCharactersInput>
  }

  export type character_humanityUpdateWithWhereUniqueWithoutCharactersInput = {
    where: character_humanityWhereUniqueInput
    data: XOR<character_humanityUpdateWithoutCharactersInput, character_humanityUncheckedUpdateWithoutCharactersInput>
  }

  export type character_humanityUpdateManyWithWhereWithoutCharactersInput = {
    where: character_humanityScalarWhereInput
    data: XOR<character_humanityUpdateManyMutationInput, character_humanityUncheckedUpdateManyWithoutCharactersInput>
  }

  export type character_humanityScalarWhereInput = {
    AND?: character_humanityScalarWhereInput | character_humanityScalarWhereInput[]
    OR?: character_humanityScalarWhereInput[]
    NOT?: character_humanityScalarWhereInput | character_humanityScalarWhereInput[]
    id?: UuidFilter<"character_humanity"> | string
    char_id?: UuidFilter<"character_humanity"> | string
    level?: IntFilter<"character_humanity"> | number
    stain_count?: IntFilter<"character_humanity"> | number
  }

  export type character_profileUpsertWithWhereUniqueWithoutCharactersInput = {
    where: character_profileWhereUniqueInput
    update: XOR<character_profileUpdateWithoutCharactersInput, character_profileUncheckedUpdateWithoutCharactersInput>
    create: XOR<character_profileCreateWithoutCharactersInput, character_profileUncheckedCreateWithoutCharactersInput>
  }

  export type character_profileUpdateWithWhereUniqueWithoutCharactersInput = {
    where: character_profileWhereUniqueInput
    data: XOR<character_profileUpdateWithoutCharactersInput, character_profileUncheckedUpdateWithoutCharactersInput>
  }

  export type character_profileUpdateManyWithWhereWithoutCharactersInput = {
    where: character_profileScalarWhereInput
    data: XOR<character_profileUpdateManyMutationInput, character_profileUncheckedUpdateManyWithoutCharactersInput>
  }

  export type character_profileScalarWhereInput = {
    AND?: character_profileScalarWhereInput | character_profileScalarWhereInput[]
    OR?: character_profileScalarWhereInput[]
    NOT?: character_profileScalarWhereInput | character_profileScalarWhereInput[]
    id?: UuidFilter<"character_profile"> | string
    char_id?: UuidFilter<"character_profile"> | string
    description?: StringFilter<"character_profile"> | string
    birthday?: DateTimeFilter<"character_profile"> | Date | string
    notes?: StringNullableFilter<"character_profile"> | string | null
    age?: IntFilter<"character_profile"> | number
    embraced_at?: DateTimeFilter<"character_profile"> | Date | string
    apparent_age?: IntFilter<"character_profile"> | number
    concept?: StringNullableFilter<"character_profile"> | string | null
  }

  export type character_ritualsUpsertWithWhereUniqueWithoutCharactersInput = {
    where: character_ritualsWhereUniqueInput
    update: XOR<character_ritualsUpdateWithoutCharactersInput, character_ritualsUncheckedUpdateWithoutCharactersInput>
    create: XOR<character_ritualsCreateWithoutCharactersInput, character_ritualsUncheckedCreateWithoutCharactersInput>
  }

  export type character_ritualsUpdateWithWhereUniqueWithoutCharactersInput = {
    where: character_ritualsWhereUniqueInput
    data: XOR<character_ritualsUpdateWithoutCharactersInput, character_ritualsUncheckedUpdateWithoutCharactersInput>
  }

  export type character_ritualsUpdateManyWithWhereWithoutCharactersInput = {
    where: character_ritualsScalarWhereInput
    data: XOR<character_ritualsUpdateManyMutationInput, character_ritualsUncheckedUpdateManyWithoutCharactersInput>
  }

  export type character_ritualsScalarWhereInput = {
    AND?: character_ritualsScalarWhereInput | character_ritualsScalarWhereInput[]
    OR?: character_ritualsScalarWhereInput[]
    NOT?: character_ritualsScalarWhereInput | character_ritualsScalarWhereInput[]
    id?: UuidFilter<"character_rituals"> | string
    char_id?: UuidFilter<"character_rituals"> | string
    ritual_id?: UuidFilter<"character_rituals"> | string
  }

  export type character_skillsUpsertWithWhereUniqueWithoutCharactersInput = {
    where: character_skillsWhereUniqueInput
    update: XOR<character_skillsUpdateWithoutCharactersInput, character_skillsUncheckedUpdateWithoutCharactersInput>
    create: XOR<character_skillsCreateWithoutCharactersInput, character_skillsUncheckedCreateWithoutCharactersInput>
  }

  export type character_skillsUpdateWithWhereUniqueWithoutCharactersInput = {
    where: character_skillsWhereUniqueInput
    data: XOR<character_skillsUpdateWithoutCharactersInput, character_skillsUncheckedUpdateWithoutCharactersInput>
  }

  export type character_skillsUpdateManyWithWhereWithoutCharactersInput = {
    where: character_skillsScalarWhereInput
    data: XOR<character_skillsUpdateManyMutationInput, character_skillsUncheckedUpdateManyWithoutCharactersInput>
  }

  export type character_skillsScalarWhereInput = {
    AND?: character_skillsScalarWhereInput | character_skillsScalarWhereInput[]
    OR?: character_skillsScalarWhereInput[]
    NOT?: character_skillsScalarWhereInput | character_skillsScalarWhereInput[]
    id?: UuidFilter<"character_skills"> | string
    char_id?: UuidFilter<"character_skills"> | string
    skill_id?: UuidFilter<"character_skills"> | string
    level?: IntFilter<"character_skills"> | number
  }

  export type character_specialtiesUpsertWithWhereUniqueWithoutCharactersInput = {
    where: character_specialtiesWhereUniqueInput
    update: XOR<character_specialtiesUpdateWithoutCharactersInput, character_specialtiesUncheckedUpdateWithoutCharactersInput>
    create: XOR<character_specialtiesCreateWithoutCharactersInput, character_specialtiesUncheckedCreateWithoutCharactersInput>
  }

  export type character_specialtiesUpdateWithWhereUniqueWithoutCharactersInput = {
    where: character_specialtiesWhereUniqueInput
    data: XOR<character_specialtiesUpdateWithoutCharactersInput, character_specialtiesUncheckedUpdateWithoutCharactersInput>
  }

  export type character_specialtiesUpdateManyWithWhereWithoutCharactersInput = {
    where: character_specialtiesScalarWhereInput
    data: XOR<character_specialtiesUpdateManyMutationInput, character_specialtiesUncheckedUpdateManyWithoutCharactersInput>
  }

  export type character_specialtiesScalarWhereInput = {
    AND?: character_specialtiesScalarWhereInput | character_specialtiesScalarWhereInput[]
    OR?: character_specialtiesScalarWhereInput[]
    NOT?: character_specialtiesScalarWhereInput | character_specialtiesScalarWhereInput[]
    id?: UuidFilter<"character_specialties"> | string
    char_id?: UuidFilter<"character_specialties"> | string
    skill_id?: UuidFilter<"character_specialties"> | string
    specialty_name?: StringFilter<"character_specialties"> | string
  }

  export type character_willpowersUpsertWithWhereUniqueWithoutCharactersInput = {
    where: character_willpowersWhereUniqueInput
    update: XOR<character_willpowersUpdateWithoutCharactersInput, character_willpowersUncheckedUpdateWithoutCharactersInput>
    create: XOR<character_willpowersCreateWithoutCharactersInput, character_willpowersUncheckedCreateWithoutCharactersInput>
  }

  export type character_willpowersUpdateWithWhereUniqueWithoutCharactersInput = {
    where: character_willpowersWhereUniqueInput
    data: XOR<character_willpowersUpdateWithoutCharactersInput, character_willpowersUncheckedUpdateWithoutCharactersInput>
  }

  export type character_willpowersUpdateManyWithWhereWithoutCharactersInput = {
    where: character_willpowersScalarWhereInput
    data: XOR<character_willpowersUpdateManyMutationInput, character_willpowersUncheckedUpdateManyWithoutCharactersInput>
  }

  export type character_willpowersScalarWhereInput = {
    AND?: character_willpowersScalarWhereInput | character_willpowersScalarWhereInput[]
    OR?: character_willpowersScalarWhereInput[]
    NOT?: character_willpowersScalarWhereInput | character_willpowersScalarWhereInput[]
    id?: UuidFilter<"character_willpowers"> | string
    char_id?: UuidFilter<"character_willpowers"> | string
    max_willpower?: IntFilter<"character_willpowers"> | number
    current_aggravated?: IntFilter<"character_willpowers"> | number
    current_superficial?: IntFilter<"character_willpowers"> | number
  }

  export type chroniclesUpsertWithoutCharactersInput = {
    update: XOR<chroniclesUpdateWithoutCharactersInput, chroniclesUncheckedUpdateWithoutCharactersInput>
    create: XOR<chroniclesCreateWithoutCharactersInput, chroniclesUncheckedCreateWithoutCharactersInput>
    where?: chroniclesWhereInput
  }

  export type chroniclesUpdateToOneWithWhereWithoutCharactersInput = {
    where?: chroniclesWhereInput
    data: XOR<chroniclesUpdateWithoutCharactersInput, chroniclesUncheckedUpdateWithoutCharactersInput>
  }

  export type chroniclesUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutChroniclesNestedInput
  }

  export type chroniclesUncheckedUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type clan_banesUpsertWithoutCharactersInput = {
    update: XOR<clan_banesUpdateWithoutCharactersInput, clan_banesUncheckedUpdateWithoutCharactersInput>
    create: XOR<clan_banesCreateWithoutCharactersInput, clan_banesUncheckedCreateWithoutCharactersInput>
    where?: clan_banesWhereInput
  }

  export type clan_banesUpdateToOneWithWhereWithoutCharactersInput = {
    where?: clan_banesWhereInput
    data: XOR<clan_banesUpdateWithoutCharactersInput, clan_banesUncheckedUpdateWithoutCharactersInput>
  }

  export type clan_banesUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    character_bloodpotencies?: character_bloodpotenciesUpdateManyWithoutClan_banesNestedInput
    clans?: clansUpdateOneRequiredWithoutClan_banesNestedInput
  }

  export type clan_banesUncheckedUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clan_id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    character_bloodpotencies?: character_bloodpotenciesUncheckedUpdateManyWithoutClan_banesNestedInput
  }

  export type clan_compulsionsUpsertWithoutCharactersInput = {
    update: XOR<clan_compulsionsUpdateWithoutCharactersInput, clan_compulsionsUncheckedUpdateWithoutCharactersInput>
    create: XOR<clan_compulsionsCreateWithoutCharactersInput, clan_compulsionsUncheckedCreateWithoutCharactersInput>
    where?: clan_compulsionsWhereInput
  }

  export type clan_compulsionsUpdateToOneWithWhereWithoutCharactersInput = {
    where?: clan_compulsionsWhereInput
    data: XOR<clan_compulsionsUpdateWithoutCharactersInput, clan_compulsionsUncheckedUpdateWithoutCharactersInput>
  }

  export type clan_compulsionsUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    character_bloodpotencies?: character_bloodpotenciesUpdateManyWithoutClan_compulsionsNestedInput
    clans?: clansUpdateOneRequiredWithoutClan_compulsionsNestedInput
  }

  export type clan_compulsionsUncheckedUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clan_id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    character_bloodpotencies?: character_bloodpotenciesUncheckedUpdateManyWithoutClan_compulsionsNestedInput
  }

  export type clansUpsertWithoutCharactersInput = {
    update: XOR<clansUpdateWithoutCharactersInput, clansUncheckedUpdateWithoutCharactersInput>
    create: XOR<clansCreateWithoutCharactersInput, clansUncheckedCreateWithoutCharactersInput>
    where?: clansWhereInput
  }

  export type clansUpdateToOneWithWhereWithoutCharactersInput = {
    where?: clansWhereInput
    data: XOR<clansUpdateWithoutCharactersInput, clansUncheckedUpdateWithoutCharactersInput>
  }

  export type clansUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    advantages?: advantagesUpdateManyWithoutClansNestedInput
    clan_banes?: clan_banesUpdateManyWithoutClansNestedInput
    clan_compulsions?: clan_compulsionsUpdateManyWithoutClansNestedInput
  }

  export type clansUncheckedUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    advantages?: advantagesUncheckedUpdateManyWithoutClansNestedInput
    clan_banes?: clan_banesUncheckedUpdateManyWithoutClansNestedInput
    clan_compulsions?: clan_compulsionsUncheckedUpdateManyWithoutClansNestedInput
  }

  export type char_groupsUpsertWithoutCharactersInput = {
    update: XOR<char_groupsUpdateWithoutCharactersInput, char_groupsUncheckedUpdateWithoutCharactersInput>
    create: XOR<char_groupsCreateWithoutCharactersInput, char_groupsUncheckedCreateWithoutCharactersInput>
    where?: char_groupsWhereInput
  }

  export type char_groupsUpdateToOneWithWhereWithoutCharactersInput = {
    where?: char_groupsWhereInput
    data: XOR<char_groupsUpdateWithoutCharactersInput, char_groupsUncheckedUpdateWithoutCharactersInput>
  }

  export type char_groupsUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    char_groups?: char_groupsUpdateOneWithoutOther_char_groupsNestedInput
    other_char_groups?: char_groupsUpdateManyWithoutChar_groupsNestedInput
    users?: usersUpdateOneRequiredWithoutChar_groupsNestedInput
  }

  export type char_groupsUncheckedUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    other_char_groups?: char_groupsUncheckedUpdateManyWithoutChar_groupsNestedInput
  }

  export type predator_typesUpsertWithoutCharactersInput = {
    update: XOR<predator_typesUpdateWithoutCharactersInput, predator_typesUncheckedUpdateWithoutCharactersInput>
    create: XOR<predator_typesCreateWithoutCharactersInput, predator_typesUncheckedCreateWithoutCharactersInput>
    where?: predator_typesWhereInput
  }

  export type predator_typesUpdateToOneWithWhereWithoutCharactersInput = {
    where?: predator_typesWhereInput
    data: XOR<predator_typesUpdateWithoutCharactersInput, predator_typesUncheckedUpdateWithoutCharactersInput>
  }

  export type predator_typesUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dice_pool?: StringFieldUpdateOperationsInput | string
    benefits?: StringFieldUpdateOperationsInput | string
  }

  export type predator_typesUncheckedUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    dice_pool?: StringFieldUpdateOperationsInput | string
    benefits?: StringFieldUpdateOperationsInput | string
  }

  export type sectsUpsertWithoutCharactersInput = {
    update: XOR<sectsUpdateWithoutCharactersInput, sectsUncheckedUpdateWithoutCharactersInput>
    create: XOR<sectsCreateWithoutCharactersInput, sectsUncheckedCreateWithoutCharactersInput>
    where?: sectsWhereInput
  }

  export type sectsUpdateToOneWithWhereWithoutCharactersInput = {
    where?: sectsWhereInput
    data: XOR<sectsUpdateWithoutCharactersInput, sectsUncheckedUpdateWithoutCharactersInput>
  }

  export type sectsUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    advantages?: advantagesUpdateManyWithoutSectsNestedInput
  }

  export type sectsUncheckedUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    advantages?: advantagesUncheckedUpdateManyWithoutSectsNestedInput
  }

  export type usersUpsertWithoutCharactersInput = {
    update: XOR<usersUpdateWithoutCharactersInput, usersUncheckedUpdateWithoutCharactersInput>
    create: XOR<usersCreateWithoutCharactersInput, usersUncheckedCreateWithoutCharactersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutCharactersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutCharactersInput, usersUncheckedUpdateWithoutCharactersInput>
  }

  export type usersUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerk_user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    char_groups?: char_groupsUpdateManyWithoutUsersNestedInput
    chronicles?: chroniclesUpdateManyWithoutUsersNestedInput
    exp_logs?: exp_logsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerk_user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    char_groups?: char_groupsUncheckedUpdateManyWithoutUsersNestedInput
    chronicles?: chroniclesUncheckedUpdateManyWithoutUsersNestedInput
    exp_logs?: exp_logsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type exp_logsUpsertWithWhereUniqueWithoutCharactersInput = {
    where: exp_logsWhereUniqueInput
    update: XOR<exp_logsUpdateWithoutCharactersInput, exp_logsUncheckedUpdateWithoutCharactersInput>
    create: XOR<exp_logsCreateWithoutCharactersInput, exp_logsUncheckedCreateWithoutCharactersInput>
  }

  export type exp_logsUpdateWithWhereUniqueWithoutCharactersInput = {
    where: exp_logsWhereUniqueInput
    data: XOR<exp_logsUpdateWithoutCharactersInput, exp_logsUncheckedUpdateWithoutCharactersInput>
  }

  export type exp_logsUpdateManyWithWhereWithoutCharactersInput = {
    where: exp_logsScalarWhereInput
    data: XOR<exp_logsUpdateManyMutationInput, exp_logsUncheckedUpdateManyWithoutCharactersInput>
  }

  export type exp_logsScalarWhereInput = {
    AND?: exp_logsScalarWhereInput | exp_logsScalarWhereInput[]
    OR?: exp_logsScalarWhereInput[]
    NOT?: exp_logsScalarWhereInput | exp_logsScalarWhereInput[]
    id?: UuidFilter<"exp_logs"> | string
    user_id?: UuidFilter<"exp_logs"> | string
    char_id?: UuidFilter<"exp_logs"> | string
    section?: StringNullableFilter<"exp_logs"> | string | null
    name?: StringNullableFilter<"exp_logs"> | string | null
    prev_level?: IntNullableFilter<"exp_logs"> | number | null
    new_level?: IntNullableFilter<"exp_logs"> | number | null
    expanditure?: IntNullableFilter<"exp_logs"> | number | null
    created_at?: DateTimeFilter<"exp_logs"> | Date | string
  }

  export type charactersCreateWithoutChroniclesInput = {
    id?: string
    name: string
    player: string
    generation: number
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesCreateNestedManyWithoutCharactersInput
    character_alchemy_powers?: character_alchemy_powersCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersCreateNestedManyWithoutCharactersInput
    clan_banes?: clan_banesCreateNestedOneWithoutCharactersInput
    clan_compulsions?: clan_compulsionsCreateNestedOneWithoutCharactersInput
    clans?: clansCreateNestedOneWithoutCharactersInput
    char_groups: char_groupsCreateNestedOneWithoutCharactersInput
    predator_types: predator_typesCreateNestedOneWithoutCharactersInput
    sects?: sectsCreateNestedOneWithoutCharactersInput
    users: usersCreateNestedOneWithoutCharactersInput
    exp_logs?: exp_logsCreateNestedManyWithoutCharactersInput
  }

  export type charactersUncheckedCreateWithoutChroniclesInput = {
    id?: string
    user_id: string
    name: string
    clan_id?: string | null
    clan_bane?: string | null
    clan_compulsion?: string | null
    sect_id?: string | null
    player: string
    predator_type: string
    generation: number
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    group_id: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesUncheckedCreateNestedManyWithoutCharactersInput
    character_alchemy_powers?: character_alchemy_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesUncheckedCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesUncheckedCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsUncheckedCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityUncheckedCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileUncheckedCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsUncheckedCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsUncheckedCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesUncheckedCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersUncheckedCreateNestedManyWithoutCharactersInput
    exp_logs?: exp_logsUncheckedCreateNestedManyWithoutCharactersInput
  }

  export type charactersCreateOrConnectWithoutChroniclesInput = {
    where: charactersWhereUniqueInput
    create: XOR<charactersCreateWithoutChroniclesInput, charactersUncheckedCreateWithoutChroniclesInput>
  }

  export type charactersCreateManyChroniclesInputEnvelope = {
    data: charactersCreateManyChroniclesInput | charactersCreateManyChroniclesInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutChroniclesInput = {
    id?: string
    clerk_user_id: string
    email: string
    name: string
    image_url?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    char_groups?: char_groupsCreateNestedManyWithoutUsersInput
    characters?: charactersCreateNestedManyWithoutUsersInput
    exp_logs?: exp_logsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutChroniclesInput = {
    id?: string
    clerk_user_id: string
    email: string
    name: string
    image_url?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    char_groups?: char_groupsUncheckedCreateNestedManyWithoutUsersInput
    characters?: charactersUncheckedCreateNestedManyWithoutUsersInput
    exp_logs?: exp_logsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutChroniclesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutChroniclesInput, usersUncheckedCreateWithoutChroniclesInput>
  }

  export type charactersUpsertWithWhereUniqueWithoutChroniclesInput = {
    where: charactersWhereUniqueInput
    update: XOR<charactersUpdateWithoutChroniclesInput, charactersUncheckedUpdateWithoutChroniclesInput>
    create: XOR<charactersCreateWithoutChroniclesInput, charactersUncheckedCreateWithoutChroniclesInput>
  }

  export type charactersUpdateWithWhereUniqueWithoutChroniclesInput = {
    where: charactersWhereUniqueInput
    data: XOR<charactersUpdateWithoutChroniclesInput, charactersUncheckedUpdateWithoutChroniclesInput>
  }

  export type charactersUpdateManyWithWhereWithoutChroniclesInput = {
    where: charactersScalarWhereInput
    data: XOR<charactersUpdateManyMutationInput, charactersUncheckedUpdateManyWithoutChroniclesInput>
  }

  export type usersUpsertWithoutChroniclesInput = {
    update: XOR<usersUpdateWithoutChroniclesInput, usersUncheckedUpdateWithoutChroniclesInput>
    create: XOR<usersCreateWithoutChroniclesInput, usersUncheckedCreateWithoutChroniclesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutChroniclesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutChroniclesInput, usersUncheckedUpdateWithoutChroniclesInput>
  }

  export type usersUpdateWithoutChroniclesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerk_user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    char_groups?: char_groupsUpdateManyWithoutUsersNestedInput
    characters?: charactersUpdateManyWithoutUsersNestedInput
    exp_logs?: exp_logsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutChroniclesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerk_user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    char_groups?: char_groupsUncheckedUpdateManyWithoutUsersNestedInput
    characters?: charactersUncheckedUpdateManyWithoutUsersNestedInput
    exp_logs?: exp_logsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type character_bloodpotenciesCreateWithoutClan_banesInput = {
    id?: string
    blood_surge?: string | null
    bane_severity?: number | null
    power_bonus?: string | null
    feeding_penalty?: string | null
    mend_amount?: number | null
    rc_reroll?: string | null
    blood_potency?: blood_potencyCreateNestedOneWithoutCharacter_bloodpotenciesInput
    characters: charactersCreateNestedOneWithoutCharacter_bloodpotenciesInput
    clan_compulsions?: clan_compulsionsCreateNestedOneWithoutCharacter_bloodpotenciesInput
  }

  export type character_bloodpotenciesUncheckedCreateWithoutClan_banesInput = {
    id?: string
    char_id: string
    blood_potency_level?: string | null
    blood_surge?: string | null
    bane_severity?: number | null
    power_bonus?: string | null
    feeding_penalty?: string | null
    mend_amount?: number | null
    rc_reroll?: string | null
    clan_compulsion?: string | null
  }

  export type character_bloodpotenciesCreateOrConnectWithoutClan_banesInput = {
    where: character_bloodpotenciesWhereUniqueInput
    create: XOR<character_bloodpotenciesCreateWithoutClan_banesInput, character_bloodpotenciesUncheckedCreateWithoutClan_banesInput>
  }

  export type character_bloodpotenciesCreateManyClan_banesInputEnvelope = {
    data: character_bloodpotenciesCreateManyClan_banesInput | character_bloodpotenciesCreateManyClan_banesInput[]
    skipDuplicates?: boolean
  }

  export type charactersCreateWithoutClan_banesInput = {
    id?: string
    name: string
    player: string
    generation: number
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesCreateNestedManyWithoutCharactersInput
    character_alchemy_powers?: character_alchemy_powersCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersCreateNestedManyWithoutCharactersInput
    chronicles?: chroniclesCreateNestedOneWithoutCharactersInput
    clan_compulsions?: clan_compulsionsCreateNestedOneWithoutCharactersInput
    clans?: clansCreateNestedOneWithoutCharactersInput
    char_groups: char_groupsCreateNestedOneWithoutCharactersInput
    predator_types: predator_typesCreateNestedOneWithoutCharactersInput
    sects?: sectsCreateNestedOneWithoutCharactersInput
    users: usersCreateNestedOneWithoutCharactersInput
    exp_logs?: exp_logsCreateNestedManyWithoutCharactersInput
  }

  export type charactersUncheckedCreateWithoutClan_banesInput = {
    id?: string
    user_id: string
    name: string
    clan_id?: string | null
    clan_compulsion?: string | null
    sect_id?: string | null
    player: string
    predator_type: string
    generation: number
    chronicle_id?: string | null
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    group_id: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesUncheckedCreateNestedManyWithoutCharactersInput
    character_alchemy_powers?: character_alchemy_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesUncheckedCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesUncheckedCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsUncheckedCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityUncheckedCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileUncheckedCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsUncheckedCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsUncheckedCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesUncheckedCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersUncheckedCreateNestedManyWithoutCharactersInput
    exp_logs?: exp_logsUncheckedCreateNestedManyWithoutCharactersInput
  }

  export type charactersCreateOrConnectWithoutClan_banesInput = {
    where: charactersWhereUniqueInput
    create: XOR<charactersCreateWithoutClan_banesInput, charactersUncheckedCreateWithoutClan_banesInput>
  }

  export type charactersCreateManyClan_banesInputEnvelope = {
    data: charactersCreateManyClan_banesInput | charactersCreateManyClan_banesInput[]
    skipDuplicates?: boolean
  }

  export type clansCreateWithoutClan_banesInput = {
    id?: string
    name: string
    description: string
    advantages?: advantagesCreateNestedManyWithoutClansInput
    characters?: charactersCreateNestedManyWithoutClansInput
    clan_compulsions?: clan_compulsionsCreateNestedManyWithoutClansInput
  }

  export type clansUncheckedCreateWithoutClan_banesInput = {
    id?: string
    name: string
    description: string
    advantages?: advantagesUncheckedCreateNestedManyWithoutClansInput
    characters?: charactersUncheckedCreateNestedManyWithoutClansInput
    clan_compulsions?: clan_compulsionsUncheckedCreateNestedManyWithoutClansInput
  }

  export type clansCreateOrConnectWithoutClan_banesInput = {
    where: clansWhereUniqueInput
    create: XOR<clansCreateWithoutClan_banesInput, clansUncheckedCreateWithoutClan_banesInput>
  }

  export type character_bloodpotenciesUpsertWithWhereUniqueWithoutClan_banesInput = {
    where: character_bloodpotenciesWhereUniqueInput
    update: XOR<character_bloodpotenciesUpdateWithoutClan_banesInput, character_bloodpotenciesUncheckedUpdateWithoutClan_banesInput>
    create: XOR<character_bloodpotenciesCreateWithoutClan_banesInput, character_bloodpotenciesUncheckedCreateWithoutClan_banesInput>
  }

  export type character_bloodpotenciesUpdateWithWhereUniqueWithoutClan_banesInput = {
    where: character_bloodpotenciesWhereUniqueInput
    data: XOR<character_bloodpotenciesUpdateWithoutClan_banesInput, character_bloodpotenciesUncheckedUpdateWithoutClan_banesInput>
  }

  export type character_bloodpotenciesUpdateManyWithWhereWithoutClan_banesInput = {
    where: character_bloodpotenciesScalarWhereInput
    data: XOR<character_bloodpotenciesUpdateManyMutationInput, character_bloodpotenciesUncheckedUpdateManyWithoutClan_banesInput>
  }

  export type charactersUpsertWithWhereUniqueWithoutClan_banesInput = {
    where: charactersWhereUniqueInput
    update: XOR<charactersUpdateWithoutClan_banesInput, charactersUncheckedUpdateWithoutClan_banesInput>
    create: XOR<charactersCreateWithoutClan_banesInput, charactersUncheckedCreateWithoutClan_banesInput>
  }

  export type charactersUpdateWithWhereUniqueWithoutClan_banesInput = {
    where: charactersWhereUniqueInput
    data: XOR<charactersUpdateWithoutClan_banesInput, charactersUncheckedUpdateWithoutClan_banesInput>
  }

  export type charactersUpdateManyWithWhereWithoutClan_banesInput = {
    where: charactersScalarWhereInput
    data: XOR<charactersUpdateManyMutationInput, charactersUncheckedUpdateManyWithoutClan_banesInput>
  }

  export type clansUpsertWithoutClan_banesInput = {
    update: XOR<clansUpdateWithoutClan_banesInput, clansUncheckedUpdateWithoutClan_banesInput>
    create: XOR<clansCreateWithoutClan_banesInput, clansUncheckedCreateWithoutClan_banesInput>
    where?: clansWhereInput
  }

  export type clansUpdateToOneWithWhereWithoutClan_banesInput = {
    where?: clansWhereInput
    data: XOR<clansUpdateWithoutClan_banesInput, clansUncheckedUpdateWithoutClan_banesInput>
  }

  export type clansUpdateWithoutClan_banesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    advantages?: advantagesUpdateManyWithoutClansNestedInput
    characters?: charactersUpdateManyWithoutClansNestedInput
    clan_compulsions?: clan_compulsionsUpdateManyWithoutClansNestedInput
  }

  export type clansUncheckedUpdateWithoutClan_banesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    advantages?: advantagesUncheckedUpdateManyWithoutClansNestedInput
    characters?: charactersUncheckedUpdateManyWithoutClansNestedInput
    clan_compulsions?: clan_compulsionsUncheckedUpdateManyWithoutClansNestedInput
  }

  export type character_bloodpotenciesCreateWithoutClan_compulsionsInput = {
    id?: string
    blood_surge?: string | null
    bane_severity?: number | null
    power_bonus?: string | null
    feeding_penalty?: string | null
    mend_amount?: number | null
    rc_reroll?: string | null
    blood_potency?: blood_potencyCreateNestedOneWithoutCharacter_bloodpotenciesInput
    characters: charactersCreateNestedOneWithoutCharacter_bloodpotenciesInput
    clan_banes?: clan_banesCreateNestedOneWithoutCharacter_bloodpotenciesInput
  }

  export type character_bloodpotenciesUncheckedCreateWithoutClan_compulsionsInput = {
    id?: string
    char_id: string
    blood_potency_level?: string | null
    blood_surge?: string | null
    bane_severity?: number | null
    power_bonus?: string | null
    feeding_penalty?: string | null
    mend_amount?: number | null
    rc_reroll?: string | null
    clane_bane?: string | null
  }

  export type character_bloodpotenciesCreateOrConnectWithoutClan_compulsionsInput = {
    where: character_bloodpotenciesWhereUniqueInput
    create: XOR<character_bloodpotenciesCreateWithoutClan_compulsionsInput, character_bloodpotenciesUncheckedCreateWithoutClan_compulsionsInput>
  }

  export type character_bloodpotenciesCreateManyClan_compulsionsInputEnvelope = {
    data: character_bloodpotenciesCreateManyClan_compulsionsInput | character_bloodpotenciesCreateManyClan_compulsionsInput[]
    skipDuplicates?: boolean
  }

  export type charactersCreateWithoutClan_compulsionsInput = {
    id?: string
    name: string
    player: string
    generation: number
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesCreateNestedManyWithoutCharactersInput
    character_alchemy_powers?: character_alchemy_powersCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersCreateNestedManyWithoutCharactersInput
    chronicles?: chroniclesCreateNestedOneWithoutCharactersInput
    clan_banes?: clan_banesCreateNestedOneWithoutCharactersInput
    clans?: clansCreateNestedOneWithoutCharactersInput
    char_groups: char_groupsCreateNestedOneWithoutCharactersInput
    predator_types: predator_typesCreateNestedOneWithoutCharactersInput
    sects?: sectsCreateNestedOneWithoutCharactersInput
    users: usersCreateNestedOneWithoutCharactersInput
    exp_logs?: exp_logsCreateNestedManyWithoutCharactersInput
  }

  export type charactersUncheckedCreateWithoutClan_compulsionsInput = {
    id?: string
    user_id: string
    name: string
    clan_id?: string | null
    clan_bane?: string | null
    sect_id?: string | null
    player: string
    predator_type: string
    generation: number
    chronicle_id?: string | null
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    group_id: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesUncheckedCreateNestedManyWithoutCharactersInput
    character_alchemy_powers?: character_alchemy_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesUncheckedCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesUncheckedCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsUncheckedCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityUncheckedCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileUncheckedCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsUncheckedCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsUncheckedCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesUncheckedCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersUncheckedCreateNestedManyWithoutCharactersInput
    exp_logs?: exp_logsUncheckedCreateNestedManyWithoutCharactersInput
  }

  export type charactersCreateOrConnectWithoutClan_compulsionsInput = {
    where: charactersWhereUniqueInput
    create: XOR<charactersCreateWithoutClan_compulsionsInput, charactersUncheckedCreateWithoutClan_compulsionsInput>
  }

  export type charactersCreateManyClan_compulsionsInputEnvelope = {
    data: charactersCreateManyClan_compulsionsInput | charactersCreateManyClan_compulsionsInput[]
    skipDuplicates?: boolean
  }

  export type clansCreateWithoutClan_compulsionsInput = {
    id?: string
    name: string
    description: string
    advantages?: advantagesCreateNestedManyWithoutClansInput
    characters?: charactersCreateNestedManyWithoutClansInput
    clan_banes?: clan_banesCreateNestedManyWithoutClansInput
  }

  export type clansUncheckedCreateWithoutClan_compulsionsInput = {
    id?: string
    name: string
    description: string
    advantages?: advantagesUncheckedCreateNestedManyWithoutClansInput
    characters?: charactersUncheckedCreateNestedManyWithoutClansInput
    clan_banes?: clan_banesUncheckedCreateNestedManyWithoutClansInput
  }

  export type clansCreateOrConnectWithoutClan_compulsionsInput = {
    where: clansWhereUniqueInput
    create: XOR<clansCreateWithoutClan_compulsionsInput, clansUncheckedCreateWithoutClan_compulsionsInput>
  }

  export type character_bloodpotenciesUpsertWithWhereUniqueWithoutClan_compulsionsInput = {
    where: character_bloodpotenciesWhereUniqueInput
    update: XOR<character_bloodpotenciesUpdateWithoutClan_compulsionsInput, character_bloodpotenciesUncheckedUpdateWithoutClan_compulsionsInput>
    create: XOR<character_bloodpotenciesCreateWithoutClan_compulsionsInput, character_bloodpotenciesUncheckedCreateWithoutClan_compulsionsInput>
  }

  export type character_bloodpotenciesUpdateWithWhereUniqueWithoutClan_compulsionsInput = {
    where: character_bloodpotenciesWhereUniqueInput
    data: XOR<character_bloodpotenciesUpdateWithoutClan_compulsionsInput, character_bloodpotenciesUncheckedUpdateWithoutClan_compulsionsInput>
  }

  export type character_bloodpotenciesUpdateManyWithWhereWithoutClan_compulsionsInput = {
    where: character_bloodpotenciesScalarWhereInput
    data: XOR<character_bloodpotenciesUpdateManyMutationInput, character_bloodpotenciesUncheckedUpdateManyWithoutClan_compulsionsInput>
  }

  export type charactersUpsertWithWhereUniqueWithoutClan_compulsionsInput = {
    where: charactersWhereUniqueInput
    update: XOR<charactersUpdateWithoutClan_compulsionsInput, charactersUncheckedUpdateWithoutClan_compulsionsInput>
    create: XOR<charactersCreateWithoutClan_compulsionsInput, charactersUncheckedCreateWithoutClan_compulsionsInput>
  }

  export type charactersUpdateWithWhereUniqueWithoutClan_compulsionsInput = {
    where: charactersWhereUniqueInput
    data: XOR<charactersUpdateWithoutClan_compulsionsInput, charactersUncheckedUpdateWithoutClan_compulsionsInput>
  }

  export type charactersUpdateManyWithWhereWithoutClan_compulsionsInput = {
    where: charactersScalarWhereInput
    data: XOR<charactersUpdateManyMutationInput, charactersUncheckedUpdateManyWithoutClan_compulsionsInput>
  }

  export type clansUpsertWithoutClan_compulsionsInput = {
    update: XOR<clansUpdateWithoutClan_compulsionsInput, clansUncheckedUpdateWithoutClan_compulsionsInput>
    create: XOR<clansCreateWithoutClan_compulsionsInput, clansUncheckedCreateWithoutClan_compulsionsInput>
    where?: clansWhereInput
  }

  export type clansUpdateToOneWithWhereWithoutClan_compulsionsInput = {
    where?: clansWhereInput
    data: XOR<clansUpdateWithoutClan_compulsionsInput, clansUncheckedUpdateWithoutClan_compulsionsInput>
  }

  export type clansUpdateWithoutClan_compulsionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    advantages?: advantagesUpdateManyWithoutClansNestedInput
    characters?: charactersUpdateManyWithoutClansNestedInput
    clan_banes?: clan_banesUpdateManyWithoutClansNestedInput
  }

  export type clansUncheckedUpdateWithoutClan_compulsionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    advantages?: advantagesUncheckedUpdateManyWithoutClansNestedInput
    characters?: charactersUncheckedUpdateManyWithoutClansNestedInput
    clan_banes?: clan_banesUncheckedUpdateManyWithoutClansNestedInput
  }

  export type advantagesCreateWithoutClansInput = {
    id?: string
    parent_name?: string | null
    name: string
    description: string
    type: $Enums.type
    level: number
    for: $Enums.forWhom
    sects?: sectsCreateNestedOneWithoutAdvantagesInput
    character_advantages?: character_advantagesCreateNestedManyWithoutAdvantagesInput
  }

  export type advantagesUncheckedCreateWithoutClansInput = {
    id?: string
    parent_name?: string | null
    name: string
    description: string
    type: $Enums.type
    level: number
    for: $Enums.forWhom
    sect_req?: string | null
    character_advantages?: character_advantagesUncheckedCreateNestedManyWithoutAdvantagesInput
  }

  export type advantagesCreateOrConnectWithoutClansInput = {
    where: advantagesWhereUniqueInput
    create: XOR<advantagesCreateWithoutClansInput, advantagesUncheckedCreateWithoutClansInput>
  }

  export type advantagesCreateManyClansInputEnvelope = {
    data: advantagesCreateManyClansInput | advantagesCreateManyClansInput[]
    skipDuplicates?: boolean
  }

  export type charactersCreateWithoutClansInput = {
    id?: string
    name: string
    player: string
    generation: number
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesCreateNestedManyWithoutCharactersInput
    character_alchemy_powers?: character_alchemy_powersCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersCreateNestedManyWithoutCharactersInput
    chronicles?: chroniclesCreateNestedOneWithoutCharactersInput
    clan_banes?: clan_banesCreateNestedOneWithoutCharactersInput
    clan_compulsions?: clan_compulsionsCreateNestedOneWithoutCharactersInput
    char_groups: char_groupsCreateNestedOneWithoutCharactersInput
    predator_types: predator_typesCreateNestedOneWithoutCharactersInput
    sects?: sectsCreateNestedOneWithoutCharactersInput
    users: usersCreateNestedOneWithoutCharactersInput
    exp_logs?: exp_logsCreateNestedManyWithoutCharactersInput
  }

  export type charactersUncheckedCreateWithoutClansInput = {
    id?: string
    user_id: string
    name: string
    clan_bane?: string | null
    clan_compulsion?: string | null
    sect_id?: string | null
    player: string
    predator_type: string
    generation: number
    chronicle_id?: string | null
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    group_id: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesUncheckedCreateNestedManyWithoutCharactersInput
    character_alchemy_powers?: character_alchemy_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesUncheckedCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesUncheckedCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsUncheckedCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityUncheckedCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileUncheckedCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsUncheckedCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsUncheckedCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesUncheckedCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersUncheckedCreateNestedManyWithoutCharactersInput
    exp_logs?: exp_logsUncheckedCreateNestedManyWithoutCharactersInput
  }

  export type charactersCreateOrConnectWithoutClansInput = {
    where: charactersWhereUniqueInput
    create: XOR<charactersCreateWithoutClansInput, charactersUncheckedCreateWithoutClansInput>
  }

  export type charactersCreateManyClansInputEnvelope = {
    data: charactersCreateManyClansInput | charactersCreateManyClansInput[]
    skipDuplicates?: boolean
  }

  export type clan_banesCreateWithoutClansInput = {
    id?: string
    name: string
    description: string
    character_bloodpotencies?: character_bloodpotenciesCreateNestedManyWithoutClan_banesInput
    characters?: charactersCreateNestedManyWithoutClan_banesInput
  }

  export type clan_banesUncheckedCreateWithoutClansInput = {
    id?: string
    name: string
    description: string
    character_bloodpotencies?: character_bloodpotenciesUncheckedCreateNestedManyWithoutClan_banesInput
    characters?: charactersUncheckedCreateNestedManyWithoutClan_banesInput
  }

  export type clan_banesCreateOrConnectWithoutClansInput = {
    where: clan_banesWhereUniqueInput
    create: XOR<clan_banesCreateWithoutClansInput, clan_banesUncheckedCreateWithoutClansInput>
  }

  export type clan_banesCreateManyClansInputEnvelope = {
    data: clan_banesCreateManyClansInput | clan_banesCreateManyClansInput[]
    skipDuplicates?: boolean
  }

  export type clan_compulsionsCreateWithoutClansInput = {
    id?: string
    name: string
    description: string
    character_bloodpotencies?: character_bloodpotenciesCreateNestedManyWithoutClan_compulsionsInput
    characters?: charactersCreateNestedManyWithoutClan_compulsionsInput
  }

  export type clan_compulsionsUncheckedCreateWithoutClansInput = {
    id?: string
    name: string
    description: string
    character_bloodpotencies?: character_bloodpotenciesUncheckedCreateNestedManyWithoutClan_compulsionsInput
    characters?: charactersUncheckedCreateNestedManyWithoutClan_compulsionsInput
  }

  export type clan_compulsionsCreateOrConnectWithoutClansInput = {
    where: clan_compulsionsWhereUniqueInput
    create: XOR<clan_compulsionsCreateWithoutClansInput, clan_compulsionsUncheckedCreateWithoutClansInput>
  }

  export type clan_compulsionsCreateManyClansInputEnvelope = {
    data: clan_compulsionsCreateManyClansInput | clan_compulsionsCreateManyClansInput[]
    skipDuplicates?: boolean
  }

  export type advantagesUpsertWithWhereUniqueWithoutClansInput = {
    where: advantagesWhereUniqueInput
    update: XOR<advantagesUpdateWithoutClansInput, advantagesUncheckedUpdateWithoutClansInput>
    create: XOR<advantagesCreateWithoutClansInput, advantagesUncheckedCreateWithoutClansInput>
  }

  export type advantagesUpdateWithWhereUniqueWithoutClansInput = {
    where: advantagesWhereUniqueInput
    data: XOR<advantagesUpdateWithoutClansInput, advantagesUncheckedUpdateWithoutClansInput>
  }

  export type advantagesUpdateManyWithWhereWithoutClansInput = {
    where: advantagesScalarWhereInput
    data: XOR<advantagesUpdateManyMutationInput, advantagesUncheckedUpdateManyWithoutClansInput>
  }

  export type advantagesScalarWhereInput = {
    AND?: advantagesScalarWhereInput | advantagesScalarWhereInput[]
    OR?: advantagesScalarWhereInput[]
    NOT?: advantagesScalarWhereInput | advantagesScalarWhereInput[]
    id?: UuidFilter<"advantages"> | string
    parent_name?: StringNullableFilter<"advantages"> | string | null
    name?: StringFilter<"advantages"> | string
    description?: StringFilter<"advantages"> | string
    type?: EnumtypeFilter<"advantages"> | $Enums.type
    level?: IntFilter<"advantages"> | number
    for?: EnumforWhomFilter<"advantages"> | $Enums.forWhom
    clan_req?: UuidNullableFilter<"advantages"> | string | null
    sect_req?: UuidNullableFilter<"advantages"> | string | null
  }

  export type charactersUpsertWithWhereUniqueWithoutClansInput = {
    where: charactersWhereUniqueInput
    update: XOR<charactersUpdateWithoutClansInput, charactersUncheckedUpdateWithoutClansInput>
    create: XOR<charactersCreateWithoutClansInput, charactersUncheckedCreateWithoutClansInput>
  }

  export type charactersUpdateWithWhereUniqueWithoutClansInput = {
    where: charactersWhereUniqueInput
    data: XOR<charactersUpdateWithoutClansInput, charactersUncheckedUpdateWithoutClansInput>
  }

  export type charactersUpdateManyWithWhereWithoutClansInput = {
    where: charactersScalarWhereInput
    data: XOR<charactersUpdateManyMutationInput, charactersUncheckedUpdateManyWithoutClansInput>
  }

  export type clan_banesUpsertWithWhereUniqueWithoutClansInput = {
    where: clan_banesWhereUniqueInput
    update: XOR<clan_banesUpdateWithoutClansInput, clan_banesUncheckedUpdateWithoutClansInput>
    create: XOR<clan_banesCreateWithoutClansInput, clan_banesUncheckedCreateWithoutClansInput>
  }

  export type clan_banesUpdateWithWhereUniqueWithoutClansInput = {
    where: clan_banesWhereUniqueInput
    data: XOR<clan_banesUpdateWithoutClansInput, clan_banesUncheckedUpdateWithoutClansInput>
  }

  export type clan_banesUpdateManyWithWhereWithoutClansInput = {
    where: clan_banesScalarWhereInput
    data: XOR<clan_banesUpdateManyMutationInput, clan_banesUncheckedUpdateManyWithoutClansInput>
  }

  export type clan_banesScalarWhereInput = {
    AND?: clan_banesScalarWhereInput | clan_banesScalarWhereInput[]
    OR?: clan_banesScalarWhereInput[]
    NOT?: clan_banesScalarWhereInput | clan_banesScalarWhereInput[]
    id?: UuidFilter<"clan_banes"> | string
    name?: StringFilter<"clan_banes"> | string
    clan_id?: UuidFilter<"clan_banes"> | string
    description?: StringFilter<"clan_banes"> | string
  }

  export type clan_compulsionsUpsertWithWhereUniqueWithoutClansInput = {
    where: clan_compulsionsWhereUniqueInput
    update: XOR<clan_compulsionsUpdateWithoutClansInput, clan_compulsionsUncheckedUpdateWithoutClansInput>
    create: XOR<clan_compulsionsCreateWithoutClansInput, clan_compulsionsUncheckedCreateWithoutClansInput>
  }

  export type clan_compulsionsUpdateWithWhereUniqueWithoutClansInput = {
    where: clan_compulsionsWhereUniqueInput
    data: XOR<clan_compulsionsUpdateWithoutClansInput, clan_compulsionsUncheckedUpdateWithoutClansInput>
  }

  export type clan_compulsionsUpdateManyWithWhereWithoutClansInput = {
    where: clan_compulsionsScalarWhereInput
    data: XOR<clan_compulsionsUpdateManyMutationInput, clan_compulsionsUncheckedUpdateManyWithoutClansInput>
  }

  export type clan_compulsionsScalarWhereInput = {
    AND?: clan_compulsionsScalarWhereInput | clan_compulsionsScalarWhereInput[]
    OR?: clan_compulsionsScalarWhereInput[]
    NOT?: clan_compulsionsScalarWhereInput | clan_compulsionsScalarWhereInput[]
    id?: UuidFilter<"clan_compulsions"> | string
    name?: StringFilter<"clan_compulsions"> | string
    clan_id?: UuidFilter<"clan_compulsions"> | string
    description?: StringFilter<"clan_compulsions"> | string
  }

  export type character_discipline_powersCreateWithoutDiscipline_powersInput = {
    id?: string
    characters: charactersCreateNestedOneWithoutCharacter_discipline_powersInput
  }

  export type character_discipline_powersUncheckedCreateWithoutDiscipline_powersInput = {
    id?: string
    char_id: string
  }

  export type character_discipline_powersCreateOrConnectWithoutDiscipline_powersInput = {
    where: character_discipline_powersWhereUniqueInput
    create: XOR<character_discipline_powersCreateWithoutDiscipline_powersInput, character_discipline_powersUncheckedCreateWithoutDiscipline_powersInput>
  }

  export type character_discipline_powersCreateManyDiscipline_powersInputEnvelope = {
    data: character_discipline_powersCreateManyDiscipline_powersInput | character_discipline_powersCreateManyDiscipline_powersInput[]
    skipDuplicates?: boolean
  }

  export type disciplinesCreateWithoutDiscipline_powersInput = {
    id?: string
    name: string
    description: string
    nicknames: string
    characteristics: string
    type: string
    masquerade_threat: string
    blood_resonance: string
    character_disciplines?: character_disciplinesCreateNestedManyWithoutDisciplinesInput
  }

  export type disciplinesUncheckedCreateWithoutDiscipline_powersInput = {
    id?: string
    name: string
    description: string
    nicknames: string
    characteristics: string
    type: string
    masquerade_threat: string
    blood_resonance: string
    character_disciplines?: character_disciplinesUncheckedCreateNestedManyWithoutDisciplinesInput
  }

  export type disciplinesCreateOrConnectWithoutDiscipline_powersInput = {
    where: disciplinesWhereUniqueInput
    create: XOR<disciplinesCreateWithoutDiscipline_powersInput, disciplinesUncheckedCreateWithoutDiscipline_powersInput>
  }

  export type character_discipline_powersUpsertWithWhereUniqueWithoutDiscipline_powersInput = {
    where: character_discipline_powersWhereUniqueInput
    update: XOR<character_discipline_powersUpdateWithoutDiscipline_powersInput, character_discipline_powersUncheckedUpdateWithoutDiscipline_powersInput>
    create: XOR<character_discipline_powersCreateWithoutDiscipline_powersInput, character_discipline_powersUncheckedCreateWithoutDiscipline_powersInput>
  }

  export type character_discipline_powersUpdateWithWhereUniqueWithoutDiscipline_powersInput = {
    where: character_discipline_powersWhereUniqueInput
    data: XOR<character_discipline_powersUpdateWithoutDiscipline_powersInput, character_discipline_powersUncheckedUpdateWithoutDiscipline_powersInput>
  }

  export type character_discipline_powersUpdateManyWithWhereWithoutDiscipline_powersInput = {
    where: character_discipline_powersScalarWhereInput
    data: XOR<character_discipline_powersUpdateManyMutationInput, character_discipline_powersUncheckedUpdateManyWithoutDiscipline_powersInput>
  }

  export type disciplinesUpsertWithoutDiscipline_powersInput = {
    update: XOR<disciplinesUpdateWithoutDiscipline_powersInput, disciplinesUncheckedUpdateWithoutDiscipline_powersInput>
    create: XOR<disciplinesCreateWithoutDiscipline_powersInput, disciplinesUncheckedCreateWithoutDiscipline_powersInput>
    where?: disciplinesWhereInput
  }

  export type disciplinesUpdateToOneWithWhereWithoutDiscipline_powersInput = {
    where?: disciplinesWhereInput
    data: XOR<disciplinesUpdateWithoutDiscipline_powersInput, disciplinesUncheckedUpdateWithoutDiscipline_powersInput>
  }

  export type disciplinesUpdateWithoutDiscipline_powersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    nicknames?: StringFieldUpdateOperationsInput | string
    characteristics?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    masquerade_threat?: StringFieldUpdateOperationsInput | string
    blood_resonance?: StringFieldUpdateOperationsInput | string
    character_disciplines?: character_disciplinesUpdateManyWithoutDisciplinesNestedInput
  }

  export type disciplinesUncheckedUpdateWithoutDiscipline_powersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    nicknames?: StringFieldUpdateOperationsInput | string
    characteristics?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    masquerade_threat?: StringFieldUpdateOperationsInput | string
    blood_resonance?: StringFieldUpdateOperationsInput | string
    character_disciplines?: character_disciplinesUncheckedUpdateManyWithoutDisciplinesNestedInput
  }

  export type character_disciplinesCreateWithoutDisciplinesInput = {
    id?: string
    characters: charactersCreateNestedOneWithoutCharacter_disciplinesInput
  }

  export type character_disciplinesUncheckedCreateWithoutDisciplinesInput = {
    id?: string
    char_id: string
  }

  export type character_disciplinesCreateOrConnectWithoutDisciplinesInput = {
    where: character_disciplinesWhereUniqueInput
    create: XOR<character_disciplinesCreateWithoutDisciplinesInput, character_disciplinesUncheckedCreateWithoutDisciplinesInput>
  }

  export type character_disciplinesCreateManyDisciplinesInputEnvelope = {
    data: character_disciplinesCreateManyDisciplinesInput | character_disciplinesCreateManyDisciplinesInput[]
    skipDuplicates?: boolean
  }

  export type discipline_powersCreateWithoutDisciplinesInput = {
    id?: string
    name: string
    level: number
    description: string
    dice_pool: string
    cost: string
    prerequisites: string
    amalgam: string
    system: string
    duration: string
    character_discipline_powers?: character_discipline_powersCreateNestedManyWithoutDiscipline_powersInput
  }

  export type discipline_powersUncheckedCreateWithoutDisciplinesInput = {
    id?: string
    name: string
    level: number
    description: string
    dice_pool: string
    cost: string
    prerequisites: string
    amalgam: string
    system: string
    duration: string
    character_discipline_powers?: character_discipline_powersUncheckedCreateNestedManyWithoutDiscipline_powersInput
  }

  export type discipline_powersCreateOrConnectWithoutDisciplinesInput = {
    where: discipline_powersWhereUniqueInput
    create: XOR<discipline_powersCreateWithoutDisciplinesInput, discipline_powersUncheckedCreateWithoutDisciplinesInput>
  }

  export type discipline_powersCreateManyDisciplinesInputEnvelope = {
    data: discipline_powersCreateManyDisciplinesInput | discipline_powersCreateManyDisciplinesInput[]
    skipDuplicates?: boolean
  }

  export type character_disciplinesUpsertWithWhereUniqueWithoutDisciplinesInput = {
    where: character_disciplinesWhereUniqueInput
    update: XOR<character_disciplinesUpdateWithoutDisciplinesInput, character_disciplinesUncheckedUpdateWithoutDisciplinesInput>
    create: XOR<character_disciplinesCreateWithoutDisciplinesInput, character_disciplinesUncheckedCreateWithoutDisciplinesInput>
  }

  export type character_disciplinesUpdateWithWhereUniqueWithoutDisciplinesInput = {
    where: character_disciplinesWhereUniqueInput
    data: XOR<character_disciplinesUpdateWithoutDisciplinesInput, character_disciplinesUncheckedUpdateWithoutDisciplinesInput>
  }

  export type character_disciplinesUpdateManyWithWhereWithoutDisciplinesInput = {
    where: character_disciplinesScalarWhereInput
    data: XOR<character_disciplinesUpdateManyMutationInput, character_disciplinesUncheckedUpdateManyWithoutDisciplinesInput>
  }

  export type discipline_powersUpsertWithWhereUniqueWithoutDisciplinesInput = {
    where: discipline_powersWhereUniqueInput
    update: XOR<discipline_powersUpdateWithoutDisciplinesInput, discipline_powersUncheckedUpdateWithoutDisciplinesInput>
    create: XOR<discipline_powersCreateWithoutDisciplinesInput, discipline_powersUncheckedCreateWithoutDisciplinesInput>
  }

  export type discipline_powersUpdateWithWhereUniqueWithoutDisciplinesInput = {
    where: discipline_powersWhereUniqueInput
    data: XOR<discipline_powersUpdateWithoutDisciplinesInput, discipline_powersUncheckedUpdateWithoutDisciplinesInput>
  }

  export type discipline_powersUpdateManyWithWhereWithoutDisciplinesInput = {
    where: discipline_powersScalarWhereInput
    data: XOR<discipline_powersUpdateManyMutationInput, discipline_powersUncheckedUpdateManyWithoutDisciplinesInput>
  }

  export type discipline_powersScalarWhereInput = {
    AND?: discipline_powersScalarWhereInput | discipline_powersScalarWhereInput[]
    OR?: discipline_powersScalarWhereInput[]
    NOT?: discipline_powersScalarWhereInput | discipline_powersScalarWhereInput[]
    id?: UuidFilter<"discipline_powers"> | string
    discipline_id?: UuidFilter<"discipline_powers"> | string
    name?: StringFilter<"discipline_powers"> | string
    level?: IntFilter<"discipline_powers"> | number
    description?: StringFilter<"discipline_powers"> | string
    dice_pool?: StringFilter<"discipline_powers"> | string
    cost?: StringFilter<"discipline_powers"> | string
    prerequisites?: StringFilter<"discipline_powers"> | string
    amalgam?: StringFilter<"discipline_powers"> | string
    system?: StringFilter<"discipline_powers"> | string
    duration?: StringFilter<"discipline_powers"> | string
  }

  export type charactersCreateWithoutExp_logsInput = {
    id?: string
    name: string
    player: string
    generation: number
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesCreateNestedManyWithoutCharactersInput
    character_alchemy_powers?: character_alchemy_powersCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersCreateNestedManyWithoutCharactersInput
    chronicles?: chroniclesCreateNestedOneWithoutCharactersInput
    clan_banes?: clan_banesCreateNestedOneWithoutCharactersInput
    clan_compulsions?: clan_compulsionsCreateNestedOneWithoutCharactersInput
    clans?: clansCreateNestedOneWithoutCharactersInput
    char_groups: char_groupsCreateNestedOneWithoutCharactersInput
    predator_types: predator_typesCreateNestedOneWithoutCharactersInput
    sects?: sectsCreateNestedOneWithoutCharactersInput
    users: usersCreateNestedOneWithoutCharactersInput
  }

  export type charactersUncheckedCreateWithoutExp_logsInput = {
    id?: string
    user_id: string
    name: string
    clan_id?: string | null
    clan_bane?: string | null
    clan_compulsion?: string | null
    sect_id?: string | null
    player: string
    predator_type: string
    generation: number
    chronicle_id?: string | null
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    group_id: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesUncheckedCreateNestedManyWithoutCharactersInput
    character_alchemy_powers?: character_alchemy_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesUncheckedCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesUncheckedCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsUncheckedCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityUncheckedCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileUncheckedCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsUncheckedCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsUncheckedCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesUncheckedCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersUncheckedCreateNestedManyWithoutCharactersInput
  }

  export type charactersCreateOrConnectWithoutExp_logsInput = {
    where: charactersWhereUniqueInput
    create: XOR<charactersCreateWithoutExp_logsInput, charactersUncheckedCreateWithoutExp_logsInput>
  }

  export type usersCreateWithoutExp_logsInput = {
    id?: string
    clerk_user_id: string
    email: string
    name: string
    image_url?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    char_groups?: char_groupsCreateNestedManyWithoutUsersInput
    characters?: charactersCreateNestedManyWithoutUsersInput
    chronicles?: chroniclesCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutExp_logsInput = {
    id?: string
    clerk_user_id: string
    email: string
    name: string
    image_url?: string | null
    deleted_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    char_groups?: char_groupsUncheckedCreateNestedManyWithoutUsersInput
    characters?: charactersUncheckedCreateNestedManyWithoutUsersInput
    chronicles?: chroniclesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutExp_logsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutExp_logsInput, usersUncheckedCreateWithoutExp_logsInput>
  }

  export type charactersUpsertWithoutExp_logsInput = {
    update: XOR<charactersUpdateWithoutExp_logsInput, charactersUncheckedUpdateWithoutExp_logsInput>
    create: XOR<charactersCreateWithoutExp_logsInput, charactersUncheckedCreateWithoutExp_logsInput>
    where?: charactersWhereInput
  }

  export type charactersUpdateToOneWithWhereWithoutExp_logsInput = {
    where?: charactersWhereInput
    data: XOR<charactersUpdateWithoutExp_logsInput, charactersUncheckedUpdateWithoutExp_logsInput>
  }

  export type charactersUpdateWithoutExp_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    player?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUpdateManyWithoutCharactersNestedInput
    character_alchemy_powers?: character_alchemy_powersUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUpdateManyWithoutCharactersNestedInput
    chronicles?: chroniclesUpdateOneWithoutCharactersNestedInput
    clan_banes?: clan_banesUpdateOneWithoutCharactersNestedInput
    clan_compulsions?: clan_compulsionsUpdateOneWithoutCharactersNestedInput
    clans?: clansUpdateOneWithoutCharactersNestedInput
    char_groups?: char_groupsUpdateOneRequiredWithoutCharactersNestedInput
    predator_types?: predator_typesUpdateOneRequiredWithoutCharactersNestedInput
    sects?: sectsUpdateOneWithoutCharactersNestedInput
    users?: usersUpdateOneRequiredWithoutCharactersNestedInput
  }

  export type charactersUncheckedUpdateWithoutExp_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clan_id?: NullableStringFieldUpdateOperationsInput | string | null
    clan_bane?: NullableStringFieldUpdateOperationsInput | string | null
    clan_compulsion?: NullableStringFieldUpdateOperationsInput | string | null
    sect_id?: NullableStringFieldUpdateOperationsInput | string | null
    player?: StringFieldUpdateOperationsInput | string
    predator_type?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    chronicle_id?: NullableStringFieldUpdateOperationsInput | string | null
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    group_id?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUncheckedUpdateManyWithoutCharactersNestedInput
    character_alchemy_powers?: character_alchemy_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUncheckedUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUncheckedUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUncheckedUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUncheckedUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUncheckedUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUncheckedUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUncheckedUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUncheckedUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUncheckedUpdateManyWithoutCharactersNestedInput
  }

  export type usersUpsertWithoutExp_logsInput = {
    update: XOR<usersUpdateWithoutExp_logsInput, usersUncheckedUpdateWithoutExp_logsInput>
    create: XOR<usersCreateWithoutExp_logsInput, usersUncheckedCreateWithoutExp_logsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutExp_logsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutExp_logsInput, usersUncheckedUpdateWithoutExp_logsInput>
  }

  export type usersUpdateWithoutExp_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerk_user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    char_groups?: char_groupsUpdateManyWithoutUsersNestedInput
    characters?: charactersUpdateManyWithoutUsersNestedInput
    chronicles?: chroniclesUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutExp_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerk_user_id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    deleted_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    char_groups?: char_groupsUncheckedUpdateManyWithoutUsersNestedInput
    characters?: charactersUncheckedUpdateManyWithoutUsersNestedInput
    chronicles?: chroniclesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type charactersCreateWithoutPredator_typesInput = {
    id?: string
    name: string
    player: string
    generation: number
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesCreateNestedManyWithoutCharactersInput
    character_alchemy_powers?: character_alchemy_powersCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersCreateNestedManyWithoutCharactersInput
    chronicles?: chroniclesCreateNestedOneWithoutCharactersInput
    clan_banes?: clan_banesCreateNestedOneWithoutCharactersInput
    clan_compulsions?: clan_compulsionsCreateNestedOneWithoutCharactersInput
    clans?: clansCreateNestedOneWithoutCharactersInput
    char_groups: char_groupsCreateNestedOneWithoutCharactersInput
    sects?: sectsCreateNestedOneWithoutCharactersInput
    users: usersCreateNestedOneWithoutCharactersInput
    exp_logs?: exp_logsCreateNestedManyWithoutCharactersInput
  }

  export type charactersUncheckedCreateWithoutPredator_typesInput = {
    id?: string
    user_id: string
    name: string
    clan_id?: string | null
    clan_bane?: string | null
    clan_compulsion?: string | null
    sect_id?: string | null
    player: string
    generation: number
    chronicle_id?: string | null
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    group_id: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesUncheckedCreateNestedManyWithoutCharactersInput
    character_alchemy_powers?: character_alchemy_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesUncheckedCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesUncheckedCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsUncheckedCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityUncheckedCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileUncheckedCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsUncheckedCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsUncheckedCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesUncheckedCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersUncheckedCreateNestedManyWithoutCharactersInput
    exp_logs?: exp_logsUncheckedCreateNestedManyWithoutCharactersInput
  }

  export type charactersCreateOrConnectWithoutPredator_typesInput = {
    where: charactersWhereUniqueInput
    create: XOR<charactersCreateWithoutPredator_typesInput, charactersUncheckedCreateWithoutPredator_typesInput>
  }

  export type charactersCreateManyPredator_typesInputEnvelope = {
    data: charactersCreateManyPredator_typesInput | charactersCreateManyPredator_typesInput[]
    skipDuplicates?: boolean
  }

  export type charactersUpsertWithWhereUniqueWithoutPredator_typesInput = {
    where: charactersWhereUniqueInput
    update: XOR<charactersUpdateWithoutPredator_typesInput, charactersUncheckedUpdateWithoutPredator_typesInput>
    create: XOR<charactersCreateWithoutPredator_typesInput, charactersUncheckedCreateWithoutPredator_typesInput>
  }

  export type charactersUpdateWithWhereUniqueWithoutPredator_typesInput = {
    where: charactersWhereUniqueInput
    data: XOR<charactersUpdateWithoutPredator_typesInput, charactersUncheckedUpdateWithoutPredator_typesInput>
  }

  export type charactersUpdateManyWithWhereWithoutPredator_typesInput = {
    where: charactersScalarWhereInput
    data: XOR<charactersUpdateManyMutationInput, charactersUncheckedUpdateManyWithoutPredator_typesInput>
  }

  export type character_ritualsCreateWithoutRitualsInput = {
    id?: string
    characters: charactersCreateNestedOneWithoutCharacter_ritualsInput
  }

  export type character_ritualsUncheckedCreateWithoutRitualsInput = {
    id?: string
    char_id: string
  }

  export type character_ritualsCreateOrConnectWithoutRitualsInput = {
    where: character_ritualsWhereUniqueInput
    create: XOR<character_ritualsCreateWithoutRitualsInput, character_ritualsUncheckedCreateWithoutRitualsInput>
  }

  export type character_ritualsCreateManyRitualsInputEnvelope = {
    data: character_ritualsCreateManyRitualsInput | character_ritualsCreateManyRitualsInput[]
    skipDuplicates?: boolean
  }

  export type character_ritualsUpsertWithWhereUniqueWithoutRitualsInput = {
    where: character_ritualsWhereUniqueInput
    update: XOR<character_ritualsUpdateWithoutRitualsInput, character_ritualsUncheckedUpdateWithoutRitualsInput>
    create: XOR<character_ritualsCreateWithoutRitualsInput, character_ritualsUncheckedCreateWithoutRitualsInput>
  }

  export type character_ritualsUpdateWithWhereUniqueWithoutRitualsInput = {
    where: character_ritualsWhereUniqueInput
    data: XOR<character_ritualsUpdateWithoutRitualsInput, character_ritualsUncheckedUpdateWithoutRitualsInput>
  }

  export type character_ritualsUpdateManyWithWhereWithoutRitualsInput = {
    where: character_ritualsScalarWhereInput
    data: XOR<character_ritualsUpdateManyMutationInput, character_ritualsUncheckedUpdateManyWithoutRitualsInput>
  }

  export type advantagesCreateWithoutSectsInput = {
    id?: string
    parent_name?: string | null
    name: string
    description: string
    type: $Enums.type
    level: number
    for: $Enums.forWhom
    clans?: clansCreateNestedOneWithoutAdvantagesInput
    character_advantages?: character_advantagesCreateNestedManyWithoutAdvantagesInput
  }

  export type advantagesUncheckedCreateWithoutSectsInput = {
    id?: string
    parent_name?: string | null
    name: string
    description: string
    type: $Enums.type
    level: number
    for: $Enums.forWhom
    clan_req?: string | null
    character_advantages?: character_advantagesUncheckedCreateNestedManyWithoutAdvantagesInput
  }

  export type advantagesCreateOrConnectWithoutSectsInput = {
    where: advantagesWhereUniqueInput
    create: XOR<advantagesCreateWithoutSectsInput, advantagesUncheckedCreateWithoutSectsInput>
  }

  export type advantagesCreateManySectsInputEnvelope = {
    data: advantagesCreateManySectsInput | advantagesCreateManySectsInput[]
    skipDuplicates?: boolean
  }

  export type charactersCreateWithoutSectsInput = {
    id?: string
    name: string
    player: string
    generation: number
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesCreateNestedManyWithoutCharactersInput
    character_alchemy_powers?: character_alchemy_powersCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersCreateNestedManyWithoutCharactersInput
    chronicles?: chroniclesCreateNestedOneWithoutCharactersInput
    clan_banes?: clan_banesCreateNestedOneWithoutCharactersInput
    clan_compulsions?: clan_compulsionsCreateNestedOneWithoutCharactersInput
    clans?: clansCreateNestedOneWithoutCharactersInput
    char_groups: char_groupsCreateNestedOneWithoutCharactersInput
    predator_types: predator_typesCreateNestedOneWithoutCharactersInput
    users: usersCreateNestedOneWithoutCharactersInput
    exp_logs?: exp_logsCreateNestedManyWithoutCharactersInput
  }

  export type charactersUncheckedCreateWithoutSectsInput = {
    id?: string
    user_id: string
    name: string
    clan_id?: string | null
    clan_bane?: string | null
    clan_compulsion?: string | null
    player: string
    predator_type: string
    generation: number
    chronicle_id?: string | null
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    group_id: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesUncheckedCreateNestedManyWithoutCharactersInput
    character_alchemy_powers?: character_alchemy_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesUncheckedCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesUncheckedCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsUncheckedCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityUncheckedCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileUncheckedCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsUncheckedCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsUncheckedCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesUncheckedCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersUncheckedCreateNestedManyWithoutCharactersInput
    exp_logs?: exp_logsUncheckedCreateNestedManyWithoutCharactersInput
  }

  export type charactersCreateOrConnectWithoutSectsInput = {
    where: charactersWhereUniqueInput
    create: XOR<charactersCreateWithoutSectsInput, charactersUncheckedCreateWithoutSectsInput>
  }

  export type charactersCreateManySectsInputEnvelope = {
    data: charactersCreateManySectsInput | charactersCreateManySectsInput[]
    skipDuplicates?: boolean
  }

  export type advantagesUpsertWithWhereUniqueWithoutSectsInput = {
    where: advantagesWhereUniqueInput
    update: XOR<advantagesUpdateWithoutSectsInput, advantagesUncheckedUpdateWithoutSectsInput>
    create: XOR<advantagesCreateWithoutSectsInput, advantagesUncheckedCreateWithoutSectsInput>
  }

  export type advantagesUpdateWithWhereUniqueWithoutSectsInput = {
    where: advantagesWhereUniqueInput
    data: XOR<advantagesUpdateWithoutSectsInput, advantagesUncheckedUpdateWithoutSectsInput>
  }

  export type advantagesUpdateManyWithWhereWithoutSectsInput = {
    where: advantagesScalarWhereInput
    data: XOR<advantagesUpdateManyMutationInput, advantagesUncheckedUpdateManyWithoutSectsInput>
  }

  export type charactersUpsertWithWhereUniqueWithoutSectsInput = {
    where: charactersWhereUniqueInput
    update: XOR<charactersUpdateWithoutSectsInput, charactersUncheckedUpdateWithoutSectsInput>
    create: XOR<charactersCreateWithoutSectsInput, charactersUncheckedCreateWithoutSectsInput>
  }

  export type charactersUpdateWithWhereUniqueWithoutSectsInput = {
    where: charactersWhereUniqueInput
    data: XOR<charactersUpdateWithoutSectsInput, charactersUncheckedUpdateWithoutSectsInput>
  }

  export type charactersUpdateManyWithWhereWithoutSectsInput = {
    where: charactersScalarWhereInput
    data: XOR<charactersUpdateManyMutationInput, charactersUncheckedUpdateManyWithoutSectsInput>
  }

  export type character_skillsCreateWithoutSkillsInput = {
    id?: string
    level?: number
    characters: charactersCreateNestedOneWithoutCharacter_skillsInput
  }

  export type character_skillsUncheckedCreateWithoutSkillsInput = {
    id?: string
    char_id: string
    level?: number
  }

  export type character_skillsCreateOrConnectWithoutSkillsInput = {
    where: character_skillsWhereUniqueInput
    create: XOR<character_skillsCreateWithoutSkillsInput, character_skillsUncheckedCreateWithoutSkillsInput>
  }

  export type character_skillsCreateManySkillsInputEnvelope = {
    data: character_skillsCreateManySkillsInput | character_skillsCreateManySkillsInput[]
    skipDuplicates?: boolean
  }

  export type character_specialtiesCreateWithoutSkillsInput = {
    id?: string
    specialty_name: string
    characters: charactersCreateNestedOneWithoutCharacter_specialtiesInput
  }

  export type character_specialtiesUncheckedCreateWithoutSkillsInput = {
    id?: string
    char_id: string
    specialty_name: string
  }

  export type character_specialtiesCreateOrConnectWithoutSkillsInput = {
    where: character_specialtiesWhereUniqueInput
    create: XOR<character_specialtiesCreateWithoutSkillsInput, character_specialtiesUncheckedCreateWithoutSkillsInput>
  }

  export type character_specialtiesCreateManySkillsInputEnvelope = {
    data: character_specialtiesCreateManySkillsInput | character_specialtiesCreateManySkillsInput[]
    skipDuplicates?: boolean
  }

  export type character_skillsUpsertWithWhereUniqueWithoutSkillsInput = {
    where: character_skillsWhereUniqueInput
    update: XOR<character_skillsUpdateWithoutSkillsInput, character_skillsUncheckedUpdateWithoutSkillsInput>
    create: XOR<character_skillsCreateWithoutSkillsInput, character_skillsUncheckedCreateWithoutSkillsInput>
  }

  export type character_skillsUpdateWithWhereUniqueWithoutSkillsInput = {
    where: character_skillsWhereUniqueInput
    data: XOR<character_skillsUpdateWithoutSkillsInput, character_skillsUncheckedUpdateWithoutSkillsInput>
  }

  export type character_skillsUpdateManyWithWhereWithoutSkillsInput = {
    where: character_skillsScalarWhereInput
    data: XOR<character_skillsUpdateManyMutationInput, character_skillsUncheckedUpdateManyWithoutSkillsInput>
  }

  export type character_specialtiesUpsertWithWhereUniqueWithoutSkillsInput = {
    where: character_specialtiesWhereUniqueInput
    update: XOR<character_specialtiesUpdateWithoutSkillsInput, character_specialtiesUncheckedUpdateWithoutSkillsInput>
    create: XOR<character_specialtiesCreateWithoutSkillsInput, character_specialtiesUncheckedCreateWithoutSkillsInput>
  }

  export type character_specialtiesUpdateWithWhereUniqueWithoutSkillsInput = {
    where: character_specialtiesWhereUniqueInput
    data: XOR<character_specialtiesUpdateWithoutSkillsInput, character_specialtiesUncheckedUpdateWithoutSkillsInput>
  }

  export type character_specialtiesUpdateManyWithWhereWithoutSkillsInput = {
    where: character_specialtiesScalarWhereInput
    data: XOR<character_specialtiesUpdateManyMutationInput, character_specialtiesUncheckedUpdateManyWithoutSkillsInput>
  }

  export type char_groupsCreateWithoutUsersInput = {
    id?: string
    name: string
    description: string
    char_groups?: char_groupsCreateNestedOneWithoutOther_char_groupsInput
    other_char_groups?: char_groupsCreateNestedManyWithoutChar_groupsInput
    characters?: charactersCreateNestedManyWithoutChar_groupsInput
  }

  export type char_groupsUncheckedCreateWithoutUsersInput = {
    id?: string
    parent_id?: string | null
    name: string
    description: string
    other_char_groups?: char_groupsUncheckedCreateNestedManyWithoutChar_groupsInput
    characters?: charactersUncheckedCreateNestedManyWithoutChar_groupsInput
  }

  export type char_groupsCreateOrConnectWithoutUsersInput = {
    where: char_groupsWhereUniqueInput
    create: XOR<char_groupsCreateWithoutUsersInput, char_groupsUncheckedCreateWithoutUsersInput>
  }

  export type char_groupsCreateManyUsersInputEnvelope = {
    data: char_groupsCreateManyUsersInput | char_groupsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type charactersCreateWithoutUsersInput = {
    id?: string
    name: string
    player: string
    generation: number
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesCreateNestedManyWithoutCharactersInput
    character_alchemy_powers?: character_alchemy_powersCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersCreateNestedManyWithoutCharactersInput
    chronicles?: chroniclesCreateNestedOneWithoutCharactersInput
    clan_banes?: clan_banesCreateNestedOneWithoutCharactersInput
    clan_compulsions?: clan_compulsionsCreateNestedOneWithoutCharactersInput
    clans?: clansCreateNestedOneWithoutCharactersInput
    char_groups: char_groupsCreateNestedOneWithoutCharactersInput
    predator_types: predator_typesCreateNestedOneWithoutCharactersInput
    sects?: sectsCreateNestedOneWithoutCharactersInput
    exp_logs?: exp_logsCreateNestedManyWithoutCharactersInput
  }

  export type charactersUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    clan_id?: string | null
    clan_bane?: string | null
    clan_compulsion?: string | null
    sect_id?: string | null
    player: string
    predator_type: string
    generation: number
    chronicle_id?: string | null
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    group_id: string
    type?: $Enums.Entity
    character_advantages?: character_advantagesUncheckedCreateNestedManyWithoutCharactersInput
    character_alchemy_powers?: character_alchemy_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_attributes?: character_attributesUncheckedCreateNestedManyWithoutCharactersInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedCreateNestedManyWithoutCharactersInput
    character_discipline_powers?: character_discipline_powersUncheckedCreateNestedManyWithoutCharactersInput
    character_disciplines?: character_disciplinesUncheckedCreateNestedManyWithoutCharactersInput
    character_healths?: character_healthsUncheckedCreateNestedManyWithoutCharactersInput
    character_humanity?: character_humanityUncheckedCreateNestedManyWithoutCharactersInput
    character_profile?: character_profileUncheckedCreateNestedManyWithoutCharactersInput
    character_rituals?: character_ritualsUncheckedCreateNestedManyWithoutCharactersInput
    character_skills?: character_skillsUncheckedCreateNestedManyWithoutCharactersInput
    character_specialties?: character_specialtiesUncheckedCreateNestedManyWithoutCharactersInput
    character_willpowers?: character_willpowersUncheckedCreateNestedManyWithoutCharactersInput
    exp_logs?: exp_logsUncheckedCreateNestedManyWithoutCharactersInput
  }

  export type charactersCreateOrConnectWithoutUsersInput = {
    where: charactersWhereUniqueInput
    create: XOR<charactersCreateWithoutUsersInput, charactersUncheckedCreateWithoutUsersInput>
  }

  export type charactersCreateManyUsersInputEnvelope = {
    data: charactersCreateManyUsersInput | charactersCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type chroniclesCreateWithoutUsersInput = {
    id?: string
    name: string
    description: string
    created_at?: Date | string
    updated_at?: Date | string
    characters?: charactersCreateNestedManyWithoutChroniclesInput
  }

  export type chroniclesUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    description: string
    created_at?: Date | string
    updated_at?: Date | string
    characters?: charactersUncheckedCreateNestedManyWithoutChroniclesInput
  }

  export type chroniclesCreateOrConnectWithoutUsersInput = {
    where: chroniclesWhereUniqueInput
    create: XOR<chroniclesCreateWithoutUsersInput, chroniclesUncheckedCreateWithoutUsersInput>
  }

  export type chroniclesCreateManyUsersInputEnvelope = {
    data: chroniclesCreateManyUsersInput | chroniclesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type exp_logsCreateWithoutUsersInput = {
    id?: string
    section?: string | null
    name?: string | null
    prev_level?: number | null
    new_level?: number | null
    expanditure?: number | null
    created_at?: Date | string
    characters: charactersCreateNestedOneWithoutExp_logsInput
  }

  export type exp_logsUncheckedCreateWithoutUsersInput = {
    id?: string
    char_id: string
    section?: string | null
    name?: string | null
    prev_level?: number | null
    new_level?: number | null
    expanditure?: number | null
    created_at?: Date | string
  }

  export type exp_logsCreateOrConnectWithoutUsersInput = {
    where: exp_logsWhereUniqueInput
    create: XOR<exp_logsCreateWithoutUsersInput, exp_logsUncheckedCreateWithoutUsersInput>
  }

  export type exp_logsCreateManyUsersInputEnvelope = {
    data: exp_logsCreateManyUsersInput | exp_logsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type char_groupsUpsertWithWhereUniqueWithoutUsersInput = {
    where: char_groupsWhereUniqueInput
    update: XOR<char_groupsUpdateWithoutUsersInput, char_groupsUncheckedUpdateWithoutUsersInput>
    create: XOR<char_groupsCreateWithoutUsersInput, char_groupsUncheckedCreateWithoutUsersInput>
  }

  export type char_groupsUpdateWithWhereUniqueWithoutUsersInput = {
    where: char_groupsWhereUniqueInput
    data: XOR<char_groupsUpdateWithoutUsersInput, char_groupsUncheckedUpdateWithoutUsersInput>
  }

  export type char_groupsUpdateManyWithWhereWithoutUsersInput = {
    where: char_groupsScalarWhereInput
    data: XOR<char_groupsUpdateManyMutationInput, char_groupsUncheckedUpdateManyWithoutUsersInput>
  }

  export type charactersUpsertWithWhereUniqueWithoutUsersInput = {
    where: charactersWhereUniqueInput
    update: XOR<charactersUpdateWithoutUsersInput, charactersUncheckedUpdateWithoutUsersInput>
    create: XOR<charactersCreateWithoutUsersInput, charactersUncheckedCreateWithoutUsersInput>
  }

  export type charactersUpdateWithWhereUniqueWithoutUsersInput = {
    where: charactersWhereUniqueInput
    data: XOR<charactersUpdateWithoutUsersInput, charactersUncheckedUpdateWithoutUsersInput>
  }

  export type charactersUpdateManyWithWhereWithoutUsersInput = {
    where: charactersScalarWhereInput
    data: XOR<charactersUpdateManyMutationInput, charactersUncheckedUpdateManyWithoutUsersInput>
  }

  export type chroniclesUpsertWithWhereUniqueWithoutUsersInput = {
    where: chroniclesWhereUniqueInput
    update: XOR<chroniclesUpdateWithoutUsersInput, chroniclesUncheckedUpdateWithoutUsersInput>
    create: XOR<chroniclesCreateWithoutUsersInput, chroniclesUncheckedCreateWithoutUsersInput>
  }

  export type chroniclesUpdateWithWhereUniqueWithoutUsersInput = {
    where: chroniclesWhereUniqueInput
    data: XOR<chroniclesUpdateWithoutUsersInput, chroniclesUncheckedUpdateWithoutUsersInput>
  }

  export type chroniclesUpdateManyWithWhereWithoutUsersInput = {
    where: chroniclesScalarWhereInput
    data: XOR<chroniclesUpdateManyMutationInput, chroniclesUncheckedUpdateManyWithoutUsersInput>
  }

  export type chroniclesScalarWhereInput = {
    AND?: chroniclesScalarWhereInput | chroniclesScalarWhereInput[]
    OR?: chroniclesScalarWhereInput[]
    NOT?: chroniclesScalarWhereInput | chroniclesScalarWhereInput[]
    id?: UuidFilter<"chronicles"> | string
    user_id?: UuidFilter<"chronicles"> | string
    name?: StringFilter<"chronicles"> | string
    description?: StringFilter<"chronicles"> | string
    created_at?: DateTimeFilter<"chronicles"> | Date | string
    updated_at?: DateTimeFilter<"chronicles"> | Date | string
  }

  export type exp_logsUpsertWithWhereUniqueWithoutUsersInput = {
    where: exp_logsWhereUniqueInput
    update: XOR<exp_logsUpdateWithoutUsersInput, exp_logsUncheckedUpdateWithoutUsersInput>
    create: XOR<exp_logsCreateWithoutUsersInput, exp_logsUncheckedCreateWithoutUsersInput>
  }

  export type exp_logsUpdateWithWhereUniqueWithoutUsersInput = {
    where: exp_logsWhereUniqueInput
    data: XOR<exp_logsUpdateWithoutUsersInput, exp_logsUncheckedUpdateWithoutUsersInput>
  }

  export type exp_logsUpdateManyWithWhereWithoutUsersInput = {
    where: exp_logsScalarWhereInput
    data: XOR<exp_logsUpdateManyMutationInput, exp_logsUncheckedUpdateManyWithoutUsersInput>
  }

  export type character_advantagesCreateManyAdvantagesInput = {
    id?: string
    char_id: string
  }

  export type character_advantagesUpdateWithoutAdvantagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    characters?: charactersUpdateOneRequiredWithoutCharacter_advantagesNestedInput
  }

  export type character_advantagesUncheckedUpdateWithoutAdvantagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
  }

  export type character_advantagesUncheckedUpdateManyWithoutAdvantagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
  }

  export type character_alchemy_powersCreateManyAlchemy_powersInput = {
    id?: string
    char_id: string
  }

  export type character_alchemy_powersUpdateWithoutAlchemy_powersInput = {
    id?: StringFieldUpdateOperationsInput | string
    characters?: charactersUpdateOneRequiredWithoutCharacter_alchemy_powersNestedInput
  }

  export type character_alchemy_powersUncheckedUpdateWithoutAlchemy_powersInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
  }

  export type character_alchemy_powersUncheckedUpdateManyWithoutAlchemy_powersInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
  }

  export type character_attributesCreateManyAttributesInput = {
    id?: string
    char_id: string
    level?: number
  }

  export type character_attributesUpdateWithoutAttributesInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    characters?: charactersUpdateOneRequiredWithoutCharacter_attributesNestedInput
  }

  export type character_attributesUncheckedUpdateWithoutAttributesInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
  }

  export type character_attributesUncheckedUpdateManyWithoutAttributesInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
  }

  export type character_bloodpotenciesCreateManyBlood_potencyInput = {
    id?: string
    char_id: string
    blood_surge?: string | null
    bane_severity?: number | null
    power_bonus?: string | null
    feeding_penalty?: string | null
    mend_amount?: number | null
    rc_reroll?: string | null
    clane_bane?: string | null
    clan_compulsion?: string | null
  }

  export type character_bloodpotenciesUpdateWithoutBlood_potencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    blood_surge?: NullableStringFieldUpdateOperationsInput | string | null
    bane_severity?: NullableIntFieldUpdateOperationsInput | number | null
    power_bonus?: NullableStringFieldUpdateOperationsInput | string | null
    feeding_penalty?: NullableStringFieldUpdateOperationsInput | string | null
    mend_amount?: NullableIntFieldUpdateOperationsInput | number | null
    rc_reroll?: NullableStringFieldUpdateOperationsInput | string | null
    characters?: charactersUpdateOneRequiredWithoutCharacter_bloodpotenciesNestedInput
    clan_compulsions?: clan_compulsionsUpdateOneWithoutCharacter_bloodpotenciesNestedInput
    clan_banes?: clan_banesUpdateOneWithoutCharacter_bloodpotenciesNestedInput
  }

  export type character_bloodpotenciesUncheckedUpdateWithoutBlood_potencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
    blood_surge?: NullableStringFieldUpdateOperationsInput | string | null
    bane_severity?: NullableIntFieldUpdateOperationsInput | number | null
    power_bonus?: NullableStringFieldUpdateOperationsInput | string | null
    feeding_penalty?: NullableStringFieldUpdateOperationsInput | string | null
    mend_amount?: NullableIntFieldUpdateOperationsInput | number | null
    rc_reroll?: NullableStringFieldUpdateOperationsInput | string | null
    clane_bane?: NullableStringFieldUpdateOperationsInput | string | null
    clan_compulsion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type character_bloodpotenciesUncheckedUpdateManyWithoutBlood_potencyInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
    blood_surge?: NullableStringFieldUpdateOperationsInput | string | null
    bane_severity?: NullableIntFieldUpdateOperationsInput | number | null
    power_bonus?: NullableStringFieldUpdateOperationsInput | string | null
    feeding_penalty?: NullableStringFieldUpdateOperationsInput | string | null
    mend_amount?: NullableIntFieldUpdateOperationsInput | number | null
    rc_reroll?: NullableStringFieldUpdateOperationsInput | string | null
    clane_bane?: NullableStringFieldUpdateOperationsInput | string | null
    clan_compulsion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type char_groupsCreateManyChar_groupsInput = {
    id?: string
    user_id: string
    name: string
    description: string
  }

  export type charactersCreateManyChar_groupsInput = {
    id?: string
    user_id: string
    name: string
    clan_id?: string | null
    clan_bane?: string | null
    clan_compulsion?: string | null
    sect_id?: string | null
    player: string
    predator_type: string
    generation: number
    chronicle_id?: string | null
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    type?: $Enums.Entity
  }

  export type char_groupsUpdateWithoutChar_groupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    other_char_groups?: char_groupsUpdateManyWithoutChar_groupsNestedInput
    users?: usersUpdateOneRequiredWithoutChar_groupsNestedInput
    characters?: charactersUpdateManyWithoutChar_groupsNestedInput
  }

  export type char_groupsUncheckedUpdateWithoutChar_groupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    other_char_groups?: char_groupsUncheckedUpdateManyWithoutChar_groupsNestedInput
    characters?: charactersUncheckedUpdateManyWithoutChar_groupsNestedInput
  }

  export type char_groupsUncheckedUpdateManyWithoutChar_groupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type charactersUpdateWithoutChar_groupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    player?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUpdateManyWithoutCharactersNestedInput
    character_alchemy_powers?: character_alchemy_powersUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUpdateManyWithoutCharactersNestedInput
    chronicles?: chroniclesUpdateOneWithoutCharactersNestedInput
    clan_banes?: clan_banesUpdateOneWithoutCharactersNestedInput
    clan_compulsions?: clan_compulsionsUpdateOneWithoutCharactersNestedInput
    clans?: clansUpdateOneWithoutCharactersNestedInput
    predator_types?: predator_typesUpdateOneRequiredWithoutCharactersNestedInput
    sects?: sectsUpdateOneWithoutCharactersNestedInput
    users?: usersUpdateOneRequiredWithoutCharactersNestedInput
    exp_logs?: exp_logsUpdateManyWithoutCharactersNestedInput
  }

  export type charactersUncheckedUpdateWithoutChar_groupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clan_id?: NullableStringFieldUpdateOperationsInput | string | null
    clan_bane?: NullableStringFieldUpdateOperationsInput | string | null
    clan_compulsion?: NullableStringFieldUpdateOperationsInput | string | null
    sect_id?: NullableStringFieldUpdateOperationsInput | string | null
    player?: StringFieldUpdateOperationsInput | string
    predator_type?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    chronicle_id?: NullableStringFieldUpdateOperationsInput | string | null
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUncheckedUpdateManyWithoutCharactersNestedInput
    character_alchemy_powers?: character_alchemy_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUncheckedUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUncheckedUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUncheckedUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUncheckedUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUncheckedUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUncheckedUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUncheckedUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUncheckedUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUncheckedUpdateManyWithoutCharactersNestedInput
    exp_logs?: exp_logsUncheckedUpdateManyWithoutCharactersNestedInput
  }

  export type charactersUncheckedUpdateManyWithoutChar_groupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clan_id?: NullableStringFieldUpdateOperationsInput | string | null
    clan_bane?: NullableStringFieldUpdateOperationsInput | string | null
    clan_compulsion?: NullableStringFieldUpdateOperationsInput | string | null
    sect_id?: NullableStringFieldUpdateOperationsInput | string | null
    player?: StringFieldUpdateOperationsInput | string
    predator_type?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    chronicle_id?: NullableStringFieldUpdateOperationsInput | string | null
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
  }

  export type character_advantagesCreateManyCharactersInput = {
    id?: string
    advantage_id: string
  }

  export type character_alchemy_powersCreateManyCharactersInput = {
    id?: string
    alchemy_power_id: string
  }

  export type character_attributesCreateManyCharactersInput = {
    id?: string
    attribute_id: string
    level?: number
  }

  export type character_bloodpotenciesCreateManyCharactersInput = {
    id?: string
    blood_potency_level?: string | null
    blood_surge?: string | null
    bane_severity?: number | null
    power_bonus?: string | null
    feeding_penalty?: string | null
    mend_amount?: number | null
    rc_reroll?: string | null
    clane_bane?: string | null
    clan_compulsion?: string | null
  }

  export type character_discipline_powersCreateManyCharactersInput = {
    id?: string
    discipline_power_id: string
  }

  export type character_disciplinesCreateManyCharactersInput = {
    id?: string
    discipline_id: string
  }

  export type character_healthsCreateManyCharactersInput = {
    id?: string
    max_health: number
    current_aggravated?: number
    current_superficial?: number
  }

  export type character_humanityCreateManyCharactersInput = {
    id?: string
    level?: number
    stain_count?: number
  }

  export type character_profileCreateManyCharactersInput = {
    id?: string
    description: string
    birthday: Date | string
    notes?: string | null
    age: number
    embraced_at: Date | string
    apparent_age: number
    concept?: string | null
  }

  export type character_ritualsCreateManyCharactersInput = {
    id?: string
    ritual_id: string
  }

  export type character_skillsCreateManyCharactersInput = {
    id?: string
    skill_id: string
    level?: number
  }

  export type character_specialtiesCreateManyCharactersInput = {
    id?: string
    skill_id: string
    specialty_name: string
  }

  export type character_willpowersCreateManyCharactersInput = {
    id?: string
    max_willpower: number
    current_aggravated?: number
    current_superficial?: number
  }

  export type exp_logsCreateManyCharactersInput = {
    id?: string
    user_id: string
    section?: string | null
    name?: string | null
    prev_level?: number | null
    new_level?: number | null
    expanditure?: number | null
    created_at?: Date | string
  }

  export type character_advantagesUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    advantages?: advantagesUpdateOneRequiredWithoutCharacter_advantagesNestedInput
  }

  export type character_advantagesUncheckedUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    advantage_id?: StringFieldUpdateOperationsInput | string
  }

  export type character_advantagesUncheckedUpdateManyWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    advantage_id?: StringFieldUpdateOperationsInput | string
  }

  export type character_alchemy_powersUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    alchemy_powers?: alchemy_powersUpdateOneRequiredWithoutCharacter_alchemy_powersNestedInput
  }

  export type character_alchemy_powersUncheckedUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    alchemy_power_id?: StringFieldUpdateOperationsInput | string
  }

  export type character_alchemy_powersUncheckedUpdateManyWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    alchemy_power_id?: StringFieldUpdateOperationsInput | string
  }

  export type character_attributesUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    attributes?: attributesUpdateOneRequiredWithoutCharacter_attributesNestedInput
  }

  export type character_attributesUncheckedUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    attribute_id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
  }

  export type character_attributesUncheckedUpdateManyWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    attribute_id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
  }

  export type character_bloodpotenciesUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    blood_surge?: NullableStringFieldUpdateOperationsInput | string | null
    bane_severity?: NullableIntFieldUpdateOperationsInput | number | null
    power_bonus?: NullableStringFieldUpdateOperationsInput | string | null
    feeding_penalty?: NullableStringFieldUpdateOperationsInput | string | null
    mend_amount?: NullableIntFieldUpdateOperationsInput | number | null
    rc_reroll?: NullableStringFieldUpdateOperationsInput | string | null
    blood_potency?: blood_potencyUpdateOneWithoutCharacter_bloodpotenciesNestedInput
    clan_compulsions?: clan_compulsionsUpdateOneWithoutCharacter_bloodpotenciesNestedInput
    clan_banes?: clan_banesUpdateOneWithoutCharacter_bloodpotenciesNestedInput
  }

  export type character_bloodpotenciesUncheckedUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    blood_potency_level?: NullableStringFieldUpdateOperationsInput | string | null
    blood_surge?: NullableStringFieldUpdateOperationsInput | string | null
    bane_severity?: NullableIntFieldUpdateOperationsInput | number | null
    power_bonus?: NullableStringFieldUpdateOperationsInput | string | null
    feeding_penalty?: NullableStringFieldUpdateOperationsInput | string | null
    mend_amount?: NullableIntFieldUpdateOperationsInput | number | null
    rc_reroll?: NullableStringFieldUpdateOperationsInput | string | null
    clane_bane?: NullableStringFieldUpdateOperationsInput | string | null
    clan_compulsion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type character_bloodpotenciesUncheckedUpdateManyWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    blood_potency_level?: NullableStringFieldUpdateOperationsInput | string | null
    blood_surge?: NullableStringFieldUpdateOperationsInput | string | null
    bane_severity?: NullableIntFieldUpdateOperationsInput | number | null
    power_bonus?: NullableStringFieldUpdateOperationsInput | string | null
    feeding_penalty?: NullableStringFieldUpdateOperationsInput | string | null
    mend_amount?: NullableIntFieldUpdateOperationsInput | number | null
    rc_reroll?: NullableStringFieldUpdateOperationsInput | string | null
    clane_bane?: NullableStringFieldUpdateOperationsInput | string | null
    clan_compulsion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type character_discipline_powersUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    discipline_powers?: discipline_powersUpdateOneRequiredWithoutCharacter_discipline_powersNestedInput
  }

  export type character_discipline_powersUncheckedUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    discipline_power_id?: StringFieldUpdateOperationsInput | string
  }

  export type character_discipline_powersUncheckedUpdateManyWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    discipline_power_id?: StringFieldUpdateOperationsInput | string
  }

  export type character_disciplinesUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    disciplines?: disciplinesUpdateOneRequiredWithoutCharacter_disciplinesNestedInput
  }

  export type character_disciplinesUncheckedUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    discipline_id?: StringFieldUpdateOperationsInput | string
  }

  export type character_disciplinesUncheckedUpdateManyWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    discipline_id?: StringFieldUpdateOperationsInput | string
  }

  export type character_healthsUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    max_health?: IntFieldUpdateOperationsInput | number
    current_aggravated?: IntFieldUpdateOperationsInput | number
    current_superficial?: IntFieldUpdateOperationsInput | number
  }

  export type character_healthsUncheckedUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    max_health?: IntFieldUpdateOperationsInput | number
    current_aggravated?: IntFieldUpdateOperationsInput | number
    current_superficial?: IntFieldUpdateOperationsInput | number
  }

  export type character_healthsUncheckedUpdateManyWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    max_health?: IntFieldUpdateOperationsInput | number
    current_aggravated?: IntFieldUpdateOperationsInput | number
    current_superficial?: IntFieldUpdateOperationsInput | number
  }

  export type character_humanityUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    stain_count?: IntFieldUpdateOperationsInput | number
  }

  export type character_humanityUncheckedUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    stain_count?: IntFieldUpdateOperationsInput | number
  }

  export type character_humanityUncheckedUpdateManyWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    stain_count?: IntFieldUpdateOperationsInput | number
  }

  export type character_profileUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    birthday?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    age?: IntFieldUpdateOperationsInput | number
    embraced_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apparent_age?: IntFieldUpdateOperationsInput | number
    concept?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type character_profileUncheckedUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    birthday?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    age?: IntFieldUpdateOperationsInput | number
    embraced_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apparent_age?: IntFieldUpdateOperationsInput | number
    concept?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type character_profileUncheckedUpdateManyWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    birthday?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    age?: IntFieldUpdateOperationsInput | number
    embraced_at?: DateTimeFieldUpdateOperationsInput | Date | string
    apparent_age?: IntFieldUpdateOperationsInput | number
    concept?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type character_ritualsUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    rituals?: ritualsUpdateOneRequiredWithoutCharacter_ritualsNestedInput
  }

  export type character_ritualsUncheckedUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    ritual_id?: StringFieldUpdateOperationsInput | string
  }

  export type character_ritualsUncheckedUpdateManyWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    ritual_id?: StringFieldUpdateOperationsInput | string
  }

  export type character_skillsUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    skills?: skillsUpdateOneRequiredWithoutCharacter_skillsNestedInput
  }

  export type character_skillsUncheckedUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    skill_id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
  }

  export type character_skillsUncheckedUpdateManyWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    skill_id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
  }

  export type character_specialtiesUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialty_name?: StringFieldUpdateOperationsInput | string
    skills?: skillsUpdateOneRequiredWithoutCharacter_specialtiesNestedInput
  }

  export type character_specialtiesUncheckedUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    skill_id?: StringFieldUpdateOperationsInput | string
    specialty_name?: StringFieldUpdateOperationsInput | string
  }

  export type character_specialtiesUncheckedUpdateManyWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    skill_id?: StringFieldUpdateOperationsInput | string
    specialty_name?: StringFieldUpdateOperationsInput | string
  }

  export type character_willpowersUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    max_willpower?: IntFieldUpdateOperationsInput | number
    current_aggravated?: IntFieldUpdateOperationsInput | number
    current_superficial?: IntFieldUpdateOperationsInput | number
  }

  export type character_willpowersUncheckedUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    max_willpower?: IntFieldUpdateOperationsInput | number
    current_aggravated?: IntFieldUpdateOperationsInput | number
    current_superficial?: IntFieldUpdateOperationsInput | number
  }

  export type character_willpowersUncheckedUpdateManyWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    max_willpower?: IntFieldUpdateOperationsInput | number
    current_aggravated?: IntFieldUpdateOperationsInput | number
    current_superficial?: IntFieldUpdateOperationsInput | number
  }

  export type exp_logsUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    prev_level?: NullableIntFieldUpdateOperationsInput | number | null
    new_level?: NullableIntFieldUpdateOperationsInput | number | null
    expanditure?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutExp_logsNestedInput
  }

  export type exp_logsUncheckedUpdateWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    prev_level?: NullableIntFieldUpdateOperationsInput | number | null
    new_level?: NullableIntFieldUpdateOperationsInput | number | null
    expanditure?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type exp_logsUncheckedUpdateManyWithoutCharactersInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    prev_level?: NullableIntFieldUpdateOperationsInput | number | null
    new_level?: NullableIntFieldUpdateOperationsInput | number | null
    expanditure?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type charactersCreateManyChroniclesInput = {
    id?: string
    user_id: string
    name: string
    clan_id?: string | null
    clan_bane?: string | null
    clan_compulsion?: string | null
    sect_id?: string | null
    player: string
    predator_type: string
    generation: number
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    group_id: string
    type?: $Enums.Entity
  }

  export type charactersUpdateWithoutChroniclesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    player?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUpdateManyWithoutCharactersNestedInput
    character_alchemy_powers?: character_alchemy_powersUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUpdateManyWithoutCharactersNestedInput
    clan_banes?: clan_banesUpdateOneWithoutCharactersNestedInput
    clan_compulsions?: clan_compulsionsUpdateOneWithoutCharactersNestedInput
    clans?: clansUpdateOneWithoutCharactersNestedInput
    char_groups?: char_groupsUpdateOneRequiredWithoutCharactersNestedInput
    predator_types?: predator_typesUpdateOneRequiredWithoutCharactersNestedInput
    sects?: sectsUpdateOneWithoutCharactersNestedInput
    users?: usersUpdateOneRequiredWithoutCharactersNestedInput
    exp_logs?: exp_logsUpdateManyWithoutCharactersNestedInput
  }

  export type charactersUncheckedUpdateWithoutChroniclesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clan_id?: NullableStringFieldUpdateOperationsInput | string | null
    clan_bane?: NullableStringFieldUpdateOperationsInput | string | null
    clan_compulsion?: NullableStringFieldUpdateOperationsInput | string | null
    sect_id?: NullableStringFieldUpdateOperationsInput | string | null
    player?: StringFieldUpdateOperationsInput | string
    predator_type?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    group_id?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUncheckedUpdateManyWithoutCharactersNestedInput
    character_alchemy_powers?: character_alchemy_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUncheckedUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUncheckedUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUncheckedUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUncheckedUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUncheckedUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUncheckedUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUncheckedUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUncheckedUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUncheckedUpdateManyWithoutCharactersNestedInput
    exp_logs?: exp_logsUncheckedUpdateManyWithoutCharactersNestedInput
  }

  export type charactersUncheckedUpdateManyWithoutChroniclesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clan_id?: NullableStringFieldUpdateOperationsInput | string | null
    clan_bane?: NullableStringFieldUpdateOperationsInput | string | null
    clan_compulsion?: NullableStringFieldUpdateOperationsInput | string | null
    sect_id?: NullableStringFieldUpdateOperationsInput | string | null
    player?: StringFieldUpdateOperationsInput | string
    predator_type?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    group_id?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
  }

  export type character_bloodpotenciesCreateManyClan_banesInput = {
    id?: string
    char_id: string
    blood_potency_level?: string | null
    blood_surge?: string | null
    bane_severity?: number | null
    power_bonus?: string | null
    feeding_penalty?: string | null
    mend_amount?: number | null
    rc_reroll?: string | null
    clan_compulsion?: string | null
  }

  export type charactersCreateManyClan_banesInput = {
    id?: string
    user_id: string
    name: string
    clan_id?: string | null
    clan_compulsion?: string | null
    sect_id?: string | null
    player: string
    predator_type: string
    generation: number
    chronicle_id?: string | null
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    group_id: string
    type?: $Enums.Entity
  }

  export type character_bloodpotenciesUpdateWithoutClan_banesInput = {
    id?: StringFieldUpdateOperationsInput | string
    blood_surge?: NullableStringFieldUpdateOperationsInput | string | null
    bane_severity?: NullableIntFieldUpdateOperationsInput | number | null
    power_bonus?: NullableStringFieldUpdateOperationsInput | string | null
    feeding_penalty?: NullableStringFieldUpdateOperationsInput | string | null
    mend_amount?: NullableIntFieldUpdateOperationsInput | number | null
    rc_reroll?: NullableStringFieldUpdateOperationsInput | string | null
    blood_potency?: blood_potencyUpdateOneWithoutCharacter_bloodpotenciesNestedInput
    characters?: charactersUpdateOneRequiredWithoutCharacter_bloodpotenciesNestedInput
    clan_compulsions?: clan_compulsionsUpdateOneWithoutCharacter_bloodpotenciesNestedInput
  }

  export type character_bloodpotenciesUncheckedUpdateWithoutClan_banesInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
    blood_potency_level?: NullableStringFieldUpdateOperationsInput | string | null
    blood_surge?: NullableStringFieldUpdateOperationsInput | string | null
    bane_severity?: NullableIntFieldUpdateOperationsInput | number | null
    power_bonus?: NullableStringFieldUpdateOperationsInput | string | null
    feeding_penalty?: NullableStringFieldUpdateOperationsInput | string | null
    mend_amount?: NullableIntFieldUpdateOperationsInput | number | null
    rc_reroll?: NullableStringFieldUpdateOperationsInput | string | null
    clan_compulsion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type character_bloodpotenciesUncheckedUpdateManyWithoutClan_banesInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
    blood_potency_level?: NullableStringFieldUpdateOperationsInput | string | null
    blood_surge?: NullableStringFieldUpdateOperationsInput | string | null
    bane_severity?: NullableIntFieldUpdateOperationsInput | number | null
    power_bonus?: NullableStringFieldUpdateOperationsInput | string | null
    feeding_penalty?: NullableStringFieldUpdateOperationsInput | string | null
    mend_amount?: NullableIntFieldUpdateOperationsInput | number | null
    rc_reroll?: NullableStringFieldUpdateOperationsInput | string | null
    clan_compulsion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type charactersUpdateWithoutClan_banesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    player?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUpdateManyWithoutCharactersNestedInput
    character_alchemy_powers?: character_alchemy_powersUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUpdateManyWithoutCharactersNestedInput
    chronicles?: chroniclesUpdateOneWithoutCharactersNestedInput
    clan_compulsions?: clan_compulsionsUpdateOneWithoutCharactersNestedInput
    clans?: clansUpdateOneWithoutCharactersNestedInput
    char_groups?: char_groupsUpdateOneRequiredWithoutCharactersNestedInput
    predator_types?: predator_typesUpdateOneRequiredWithoutCharactersNestedInput
    sects?: sectsUpdateOneWithoutCharactersNestedInput
    users?: usersUpdateOneRequiredWithoutCharactersNestedInput
    exp_logs?: exp_logsUpdateManyWithoutCharactersNestedInput
  }

  export type charactersUncheckedUpdateWithoutClan_banesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clan_id?: NullableStringFieldUpdateOperationsInput | string | null
    clan_compulsion?: NullableStringFieldUpdateOperationsInput | string | null
    sect_id?: NullableStringFieldUpdateOperationsInput | string | null
    player?: StringFieldUpdateOperationsInput | string
    predator_type?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    chronicle_id?: NullableStringFieldUpdateOperationsInput | string | null
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    group_id?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUncheckedUpdateManyWithoutCharactersNestedInput
    character_alchemy_powers?: character_alchemy_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUncheckedUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUncheckedUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUncheckedUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUncheckedUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUncheckedUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUncheckedUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUncheckedUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUncheckedUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUncheckedUpdateManyWithoutCharactersNestedInput
    exp_logs?: exp_logsUncheckedUpdateManyWithoutCharactersNestedInput
  }

  export type charactersUncheckedUpdateManyWithoutClan_banesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clan_id?: NullableStringFieldUpdateOperationsInput | string | null
    clan_compulsion?: NullableStringFieldUpdateOperationsInput | string | null
    sect_id?: NullableStringFieldUpdateOperationsInput | string | null
    player?: StringFieldUpdateOperationsInput | string
    predator_type?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    chronicle_id?: NullableStringFieldUpdateOperationsInput | string | null
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    group_id?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
  }

  export type character_bloodpotenciesCreateManyClan_compulsionsInput = {
    id?: string
    char_id: string
    blood_potency_level?: string | null
    blood_surge?: string | null
    bane_severity?: number | null
    power_bonus?: string | null
    feeding_penalty?: string | null
    mend_amount?: number | null
    rc_reroll?: string | null
    clane_bane?: string | null
  }

  export type charactersCreateManyClan_compulsionsInput = {
    id?: string
    user_id: string
    name: string
    clan_id?: string | null
    clan_bane?: string | null
    sect_id?: string | null
    player: string
    predator_type: string
    generation: number
    chronicle_id?: string | null
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    group_id: string
    type?: $Enums.Entity
  }

  export type character_bloodpotenciesUpdateWithoutClan_compulsionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    blood_surge?: NullableStringFieldUpdateOperationsInput | string | null
    bane_severity?: NullableIntFieldUpdateOperationsInput | number | null
    power_bonus?: NullableStringFieldUpdateOperationsInput | string | null
    feeding_penalty?: NullableStringFieldUpdateOperationsInput | string | null
    mend_amount?: NullableIntFieldUpdateOperationsInput | number | null
    rc_reroll?: NullableStringFieldUpdateOperationsInput | string | null
    blood_potency?: blood_potencyUpdateOneWithoutCharacter_bloodpotenciesNestedInput
    characters?: charactersUpdateOneRequiredWithoutCharacter_bloodpotenciesNestedInput
    clan_banes?: clan_banesUpdateOneWithoutCharacter_bloodpotenciesNestedInput
  }

  export type character_bloodpotenciesUncheckedUpdateWithoutClan_compulsionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
    blood_potency_level?: NullableStringFieldUpdateOperationsInput | string | null
    blood_surge?: NullableStringFieldUpdateOperationsInput | string | null
    bane_severity?: NullableIntFieldUpdateOperationsInput | number | null
    power_bonus?: NullableStringFieldUpdateOperationsInput | string | null
    feeding_penalty?: NullableStringFieldUpdateOperationsInput | string | null
    mend_amount?: NullableIntFieldUpdateOperationsInput | number | null
    rc_reroll?: NullableStringFieldUpdateOperationsInput | string | null
    clane_bane?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type character_bloodpotenciesUncheckedUpdateManyWithoutClan_compulsionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
    blood_potency_level?: NullableStringFieldUpdateOperationsInput | string | null
    blood_surge?: NullableStringFieldUpdateOperationsInput | string | null
    bane_severity?: NullableIntFieldUpdateOperationsInput | number | null
    power_bonus?: NullableStringFieldUpdateOperationsInput | string | null
    feeding_penalty?: NullableStringFieldUpdateOperationsInput | string | null
    mend_amount?: NullableIntFieldUpdateOperationsInput | number | null
    rc_reroll?: NullableStringFieldUpdateOperationsInput | string | null
    clane_bane?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type charactersUpdateWithoutClan_compulsionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    player?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUpdateManyWithoutCharactersNestedInput
    character_alchemy_powers?: character_alchemy_powersUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUpdateManyWithoutCharactersNestedInput
    chronicles?: chroniclesUpdateOneWithoutCharactersNestedInput
    clan_banes?: clan_banesUpdateOneWithoutCharactersNestedInput
    clans?: clansUpdateOneWithoutCharactersNestedInput
    char_groups?: char_groupsUpdateOneRequiredWithoutCharactersNestedInput
    predator_types?: predator_typesUpdateOneRequiredWithoutCharactersNestedInput
    sects?: sectsUpdateOneWithoutCharactersNestedInput
    users?: usersUpdateOneRequiredWithoutCharactersNestedInput
    exp_logs?: exp_logsUpdateManyWithoutCharactersNestedInput
  }

  export type charactersUncheckedUpdateWithoutClan_compulsionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clan_id?: NullableStringFieldUpdateOperationsInput | string | null
    clan_bane?: NullableStringFieldUpdateOperationsInput | string | null
    sect_id?: NullableStringFieldUpdateOperationsInput | string | null
    player?: StringFieldUpdateOperationsInput | string
    predator_type?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    chronicle_id?: NullableStringFieldUpdateOperationsInput | string | null
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    group_id?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUncheckedUpdateManyWithoutCharactersNestedInput
    character_alchemy_powers?: character_alchemy_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUncheckedUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUncheckedUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUncheckedUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUncheckedUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUncheckedUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUncheckedUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUncheckedUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUncheckedUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUncheckedUpdateManyWithoutCharactersNestedInput
    exp_logs?: exp_logsUncheckedUpdateManyWithoutCharactersNestedInput
  }

  export type charactersUncheckedUpdateManyWithoutClan_compulsionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clan_id?: NullableStringFieldUpdateOperationsInput | string | null
    clan_bane?: NullableStringFieldUpdateOperationsInput | string | null
    sect_id?: NullableStringFieldUpdateOperationsInput | string | null
    player?: StringFieldUpdateOperationsInput | string
    predator_type?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    chronicle_id?: NullableStringFieldUpdateOperationsInput | string | null
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    group_id?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
  }

  export type advantagesCreateManyClansInput = {
    id?: string
    parent_name?: string | null
    name: string
    description: string
    type: $Enums.type
    level: number
    for: $Enums.forWhom
    sect_req?: string | null
  }

  export type charactersCreateManyClansInput = {
    id?: string
    user_id: string
    name: string
    clan_bane?: string | null
    clan_compulsion?: string | null
    sect_id?: string | null
    player: string
    predator_type: string
    generation: number
    chronicle_id?: string | null
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    group_id: string
    type?: $Enums.Entity
  }

  export type clan_banesCreateManyClansInput = {
    id?: string
    name: string
    description: string
  }

  export type clan_compulsionsCreateManyClansInput = {
    id?: string
    name: string
    description: string
  }

  export type advantagesUpdateWithoutClansInput = {
    id?: StringFieldUpdateOperationsInput | string
    parent_name?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumtypeFieldUpdateOperationsInput | $Enums.type
    level?: IntFieldUpdateOperationsInput | number
    for?: EnumforWhomFieldUpdateOperationsInput | $Enums.forWhom
    sects?: sectsUpdateOneWithoutAdvantagesNestedInput
    character_advantages?: character_advantagesUpdateManyWithoutAdvantagesNestedInput
  }

  export type advantagesUncheckedUpdateWithoutClansInput = {
    id?: StringFieldUpdateOperationsInput | string
    parent_name?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumtypeFieldUpdateOperationsInput | $Enums.type
    level?: IntFieldUpdateOperationsInput | number
    for?: EnumforWhomFieldUpdateOperationsInput | $Enums.forWhom
    sect_req?: NullableStringFieldUpdateOperationsInput | string | null
    character_advantages?: character_advantagesUncheckedUpdateManyWithoutAdvantagesNestedInput
  }

  export type advantagesUncheckedUpdateManyWithoutClansInput = {
    id?: StringFieldUpdateOperationsInput | string
    parent_name?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumtypeFieldUpdateOperationsInput | $Enums.type
    level?: IntFieldUpdateOperationsInput | number
    for?: EnumforWhomFieldUpdateOperationsInput | $Enums.forWhom
    sect_req?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type charactersUpdateWithoutClansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    player?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUpdateManyWithoutCharactersNestedInput
    character_alchemy_powers?: character_alchemy_powersUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUpdateManyWithoutCharactersNestedInput
    chronicles?: chroniclesUpdateOneWithoutCharactersNestedInput
    clan_banes?: clan_banesUpdateOneWithoutCharactersNestedInput
    clan_compulsions?: clan_compulsionsUpdateOneWithoutCharactersNestedInput
    char_groups?: char_groupsUpdateOneRequiredWithoutCharactersNestedInput
    predator_types?: predator_typesUpdateOneRequiredWithoutCharactersNestedInput
    sects?: sectsUpdateOneWithoutCharactersNestedInput
    users?: usersUpdateOneRequiredWithoutCharactersNestedInput
    exp_logs?: exp_logsUpdateManyWithoutCharactersNestedInput
  }

  export type charactersUncheckedUpdateWithoutClansInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clan_bane?: NullableStringFieldUpdateOperationsInput | string | null
    clan_compulsion?: NullableStringFieldUpdateOperationsInput | string | null
    sect_id?: NullableStringFieldUpdateOperationsInput | string | null
    player?: StringFieldUpdateOperationsInput | string
    predator_type?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    chronicle_id?: NullableStringFieldUpdateOperationsInput | string | null
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    group_id?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUncheckedUpdateManyWithoutCharactersNestedInput
    character_alchemy_powers?: character_alchemy_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUncheckedUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUncheckedUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUncheckedUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUncheckedUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUncheckedUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUncheckedUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUncheckedUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUncheckedUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUncheckedUpdateManyWithoutCharactersNestedInput
    exp_logs?: exp_logsUncheckedUpdateManyWithoutCharactersNestedInput
  }

  export type charactersUncheckedUpdateManyWithoutClansInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clan_bane?: NullableStringFieldUpdateOperationsInput | string | null
    clan_compulsion?: NullableStringFieldUpdateOperationsInput | string | null
    sect_id?: NullableStringFieldUpdateOperationsInput | string | null
    player?: StringFieldUpdateOperationsInput | string
    predator_type?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    chronicle_id?: NullableStringFieldUpdateOperationsInput | string | null
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    group_id?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
  }

  export type clan_banesUpdateWithoutClansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    character_bloodpotencies?: character_bloodpotenciesUpdateManyWithoutClan_banesNestedInput
    characters?: charactersUpdateManyWithoutClan_banesNestedInput
  }

  export type clan_banesUncheckedUpdateWithoutClansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    character_bloodpotencies?: character_bloodpotenciesUncheckedUpdateManyWithoutClan_banesNestedInput
    characters?: charactersUncheckedUpdateManyWithoutClan_banesNestedInput
  }

  export type clan_banesUncheckedUpdateManyWithoutClansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type clan_compulsionsUpdateWithoutClansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    character_bloodpotencies?: character_bloodpotenciesUpdateManyWithoutClan_compulsionsNestedInput
    characters?: charactersUpdateManyWithoutClan_compulsionsNestedInput
  }

  export type clan_compulsionsUncheckedUpdateWithoutClansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    character_bloodpotencies?: character_bloodpotenciesUncheckedUpdateManyWithoutClan_compulsionsNestedInput
    characters?: charactersUncheckedUpdateManyWithoutClan_compulsionsNestedInput
  }

  export type clan_compulsionsUncheckedUpdateManyWithoutClansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type character_discipline_powersCreateManyDiscipline_powersInput = {
    id?: string
    char_id: string
  }

  export type character_discipline_powersUpdateWithoutDiscipline_powersInput = {
    id?: StringFieldUpdateOperationsInput | string
    characters?: charactersUpdateOneRequiredWithoutCharacter_discipline_powersNestedInput
  }

  export type character_discipline_powersUncheckedUpdateWithoutDiscipline_powersInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
  }

  export type character_discipline_powersUncheckedUpdateManyWithoutDiscipline_powersInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
  }

  export type character_disciplinesCreateManyDisciplinesInput = {
    id?: string
    char_id: string
  }

  export type discipline_powersCreateManyDisciplinesInput = {
    id?: string
    name: string
    level: number
    description: string
    dice_pool: string
    cost: string
    prerequisites: string
    amalgam: string
    system: string
    duration: string
  }

  export type character_disciplinesUpdateWithoutDisciplinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    characters?: charactersUpdateOneRequiredWithoutCharacter_disciplinesNestedInput
  }

  export type character_disciplinesUncheckedUpdateWithoutDisciplinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
  }

  export type character_disciplinesUncheckedUpdateManyWithoutDisciplinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
  }

  export type discipline_powersUpdateWithoutDisciplinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    dice_pool?: StringFieldUpdateOperationsInput | string
    cost?: StringFieldUpdateOperationsInput | string
    prerequisites?: StringFieldUpdateOperationsInput | string
    amalgam?: StringFieldUpdateOperationsInput | string
    system?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    character_discipline_powers?: character_discipline_powersUpdateManyWithoutDiscipline_powersNestedInput
  }

  export type discipline_powersUncheckedUpdateWithoutDisciplinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    dice_pool?: StringFieldUpdateOperationsInput | string
    cost?: StringFieldUpdateOperationsInput | string
    prerequisites?: StringFieldUpdateOperationsInput | string
    amalgam?: StringFieldUpdateOperationsInput | string
    system?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    character_discipline_powers?: character_discipline_powersUncheckedUpdateManyWithoutDiscipline_powersNestedInput
  }

  export type discipline_powersUncheckedUpdateManyWithoutDisciplinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    dice_pool?: StringFieldUpdateOperationsInput | string
    cost?: StringFieldUpdateOperationsInput | string
    prerequisites?: StringFieldUpdateOperationsInput | string
    amalgam?: StringFieldUpdateOperationsInput | string
    system?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
  }

  export type charactersCreateManyPredator_typesInput = {
    id?: string
    user_id: string
    name: string
    clan_id?: string | null
    clan_bane?: string | null
    clan_compulsion?: string | null
    sect_id?: string | null
    player: string
    generation: number
    chronicle_id?: string | null
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    group_id: string
    type?: $Enums.Entity
  }

  export type charactersUpdateWithoutPredator_typesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    player?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUpdateManyWithoutCharactersNestedInput
    character_alchemy_powers?: character_alchemy_powersUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUpdateManyWithoutCharactersNestedInput
    chronicles?: chroniclesUpdateOneWithoutCharactersNestedInput
    clan_banes?: clan_banesUpdateOneWithoutCharactersNestedInput
    clan_compulsions?: clan_compulsionsUpdateOneWithoutCharactersNestedInput
    clans?: clansUpdateOneWithoutCharactersNestedInput
    char_groups?: char_groupsUpdateOneRequiredWithoutCharactersNestedInput
    sects?: sectsUpdateOneWithoutCharactersNestedInput
    users?: usersUpdateOneRequiredWithoutCharactersNestedInput
    exp_logs?: exp_logsUpdateManyWithoutCharactersNestedInput
  }

  export type charactersUncheckedUpdateWithoutPredator_typesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clan_id?: NullableStringFieldUpdateOperationsInput | string | null
    clan_bane?: NullableStringFieldUpdateOperationsInput | string | null
    clan_compulsion?: NullableStringFieldUpdateOperationsInput | string | null
    sect_id?: NullableStringFieldUpdateOperationsInput | string | null
    player?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    chronicle_id?: NullableStringFieldUpdateOperationsInput | string | null
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    group_id?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUncheckedUpdateManyWithoutCharactersNestedInput
    character_alchemy_powers?: character_alchemy_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUncheckedUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUncheckedUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUncheckedUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUncheckedUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUncheckedUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUncheckedUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUncheckedUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUncheckedUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUncheckedUpdateManyWithoutCharactersNestedInput
    exp_logs?: exp_logsUncheckedUpdateManyWithoutCharactersNestedInput
  }

  export type charactersUncheckedUpdateManyWithoutPredator_typesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clan_id?: NullableStringFieldUpdateOperationsInput | string | null
    clan_bane?: NullableStringFieldUpdateOperationsInput | string | null
    clan_compulsion?: NullableStringFieldUpdateOperationsInput | string | null
    sect_id?: NullableStringFieldUpdateOperationsInput | string | null
    player?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    chronicle_id?: NullableStringFieldUpdateOperationsInput | string | null
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    group_id?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
  }

  export type character_ritualsCreateManyRitualsInput = {
    id?: string
    char_id: string
  }

  export type character_ritualsUpdateWithoutRitualsInput = {
    id?: StringFieldUpdateOperationsInput | string
    characters?: charactersUpdateOneRequiredWithoutCharacter_ritualsNestedInput
  }

  export type character_ritualsUncheckedUpdateWithoutRitualsInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
  }

  export type character_ritualsUncheckedUpdateManyWithoutRitualsInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
  }

  export type advantagesCreateManySectsInput = {
    id?: string
    parent_name?: string | null
    name: string
    description: string
    type: $Enums.type
    level: number
    for: $Enums.forWhom
    clan_req?: string | null
  }

  export type charactersCreateManySectsInput = {
    id?: string
    user_id: string
    name: string
    clan_id?: string | null
    clan_bane?: string | null
    clan_compulsion?: string | null
    player: string
    predator_type: string
    generation: number
    chronicle_id?: string | null
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    group_id: string
    type?: $Enums.Entity
  }

  export type advantagesUpdateWithoutSectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    parent_name?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumtypeFieldUpdateOperationsInput | $Enums.type
    level?: IntFieldUpdateOperationsInput | number
    for?: EnumforWhomFieldUpdateOperationsInput | $Enums.forWhom
    clans?: clansUpdateOneWithoutAdvantagesNestedInput
    character_advantages?: character_advantagesUpdateManyWithoutAdvantagesNestedInput
  }

  export type advantagesUncheckedUpdateWithoutSectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    parent_name?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumtypeFieldUpdateOperationsInput | $Enums.type
    level?: IntFieldUpdateOperationsInput | number
    for?: EnumforWhomFieldUpdateOperationsInput | $Enums.forWhom
    clan_req?: NullableStringFieldUpdateOperationsInput | string | null
    character_advantages?: character_advantagesUncheckedUpdateManyWithoutAdvantagesNestedInput
  }

  export type advantagesUncheckedUpdateManyWithoutSectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    parent_name?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumtypeFieldUpdateOperationsInput | $Enums.type
    level?: IntFieldUpdateOperationsInput | number
    for?: EnumforWhomFieldUpdateOperationsInput | $Enums.forWhom
    clan_req?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type charactersUpdateWithoutSectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    player?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUpdateManyWithoutCharactersNestedInput
    character_alchemy_powers?: character_alchemy_powersUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUpdateManyWithoutCharactersNestedInput
    chronicles?: chroniclesUpdateOneWithoutCharactersNestedInput
    clan_banes?: clan_banesUpdateOneWithoutCharactersNestedInput
    clan_compulsions?: clan_compulsionsUpdateOneWithoutCharactersNestedInput
    clans?: clansUpdateOneWithoutCharactersNestedInput
    char_groups?: char_groupsUpdateOneRequiredWithoutCharactersNestedInput
    predator_types?: predator_typesUpdateOneRequiredWithoutCharactersNestedInput
    users?: usersUpdateOneRequiredWithoutCharactersNestedInput
    exp_logs?: exp_logsUpdateManyWithoutCharactersNestedInput
  }

  export type charactersUncheckedUpdateWithoutSectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clan_id?: NullableStringFieldUpdateOperationsInput | string | null
    clan_bane?: NullableStringFieldUpdateOperationsInput | string | null
    clan_compulsion?: NullableStringFieldUpdateOperationsInput | string | null
    player?: StringFieldUpdateOperationsInput | string
    predator_type?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    chronicle_id?: NullableStringFieldUpdateOperationsInput | string | null
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    group_id?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUncheckedUpdateManyWithoutCharactersNestedInput
    character_alchemy_powers?: character_alchemy_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUncheckedUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUncheckedUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUncheckedUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUncheckedUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUncheckedUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUncheckedUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUncheckedUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUncheckedUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUncheckedUpdateManyWithoutCharactersNestedInput
    exp_logs?: exp_logsUncheckedUpdateManyWithoutCharactersNestedInput
  }

  export type charactersUncheckedUpdateManyWithoutSectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clan_id?: NullableStringFieldUpdateOperationsInput | string | null
    clan_bane?: NullableStringFieldUpdateOperationsInput | string | null
    clan_compulsion?: NullableStringFieldUpdateOperationsInput | string | null
    player?: StringFieldUpdateOperationsInput | string
    predator_type?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    chronicle_id?: NullableStringFieldUpdateOperationsInput | string | null
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    group_id?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
  }

  export type character_skillsCreateManySkillsInput = {
    id?: string
    char_id: string
    level?: number
  }

  export type character_specialtiesCreateManySkillsInput = {
    id?: string
    char_id: string
    specialty_name: string
  }

  export type character_skillsUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    characters?: charactersUpdateOneRequiredWithoutCharacter_skillsNestedInput
  }

  export type character_skillsUncheckedUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
  }

  export type character_skillsUncheckedUpdateManyWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
  }

  export type character_specialtiesUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    specialty_name?: StringFieldUpdateOperationsInput | string
    characters?: charactersUpdateOneRequiredWithoutCharacter_specialtiesNestedInput
  }

  export type character_specialtiesUncheckedUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
    specialty_name?: StringFieldUpdateOperationsInput | string
  }

  export type character_specialtiesUncheckedUpdateManyWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
    specialty_name?: StringFieldUpdateOperationsInput | string
  }

  export type char_groupsCreateManyUsersInput = {
    id?: string
    parent_id?: string | null
    name: string
    description: string
  }

  export type charactersCreateManyUsersInput = {
    id?: string
    name: string
    clan_id?: string | null
    clan_bane?: string | null
    clan_compulsion?: string | null
    sect_id?: string | null
    player: string
    predator_type: string
    generation: number
    chronicle_id?: string | null
    custom_chronicle?: string | null
    ambition: string
    desire: string
    sire: string
    total_experience?: number
    chronicle_tenets: string
    group_id: string
    type?: $Enums.Entity
  }

  export type chroniclesCreateManyUsersInput = {
    id?: string
    name: string
    description: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type exp_logsCreateManyUsersInput = {
    id?: string
    char_id: string
    section?: string | null
    name?: string | null
    prev_level?: number | null
    new_level?: number | null
    expanditure?: number | null
    created_at?: Date | string
  }

  export type char_groupsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    char_groups?: char_groupsUpdateOneWithoutOther_char_groupsNestedInput
    other_char_groups?: char_groupsUpdateManyWithoutChar_groupsNestedInput
    characters?: charactersUpdateManyWithoutChar_groupsNestedInput
  }

  export type char_groupsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    other_char_groups?: char_groupsUncheckedUpdateManyWithoutChar_groupsNestedInput
    characters?: charactersUncheckedUpdateManyWithoutChar_groupsNestedInput
  }

  export type char_groupsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type charactersUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    player?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUpdateManyWithoutCharactersNestedInput
    character_alchemy_powers?: character_alchemy_powersUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUpdateManyWithoutCharactersNestedInput
    chronicles?: chroniclesUpdateOneWithoutCharactersNestedInput
    clan_banes?: clan_banesUpdateOneWithoutCharactersNestedInput
    clan_compulsions?: clan_compulsionsUpdateOneWithoutCharactersNestedInput
    clans?: clansUpdateOneWithoutCharactersNestedInput
    char_groups?: char_groupsUpdateOneRequiredWithoutCharactersNestedInput
    predator_types?: predator_typesUpdateOneRequiredWithoutCharactersNestedInput
    sects?: sectsUpdateOneWithoutCharactersNestedInput
    exp_logs?: exp_logsUpdateManyWithoutCharactersNestedInput
  }

  export type charactersUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clan_id?: NullableStringFieldUpdateOperationsInput | string | null
    clan_bane?: NullableStringFieldUpdateOperationsInput | string | null
    clan_compulsion?: NullableStringFieldUpdateOperationsInput | string | null
    sect_id?: NullableStringFieldUpdateOperationsInput | string | null
    player?: StringFieldUpdateOperationsInput | string
    predator_type?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    chronicle_id?: NullableStringFieldUpdateOperationsInput | string | null
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    group_id?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
    character_advantages?: character_advantagesUncheckedUpdateManyWithoutCharactersNestedInput
    character_alchemy_powers?: character_alchemy_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_attributes?: character_attributesUncheckedUpdateManyWithoutCharactersNestedInput
    character_bloodpotencies?: character_bloodpotenciesUncheckedUpdateManyWithoutCharactersNestedInput
    character_discipline_powers?: character_discipline_powersUncheckedUpdateManyWithoutCharactersNestedInput
    character_disciplines?: character_disciplinesUncheckedUpdateManyWithoutCharactersNestedInput
    character_healths?: character_healthsUncheckedUpdateManyWithoutCharactersNestedInput
    character_humanity?: character_humanityUncheckedUpdateManyWithoutCharactersNestedInput
    character_profile?: character_profileUncheckedUpdateManyWithoutCharactersNestedInput
    character_rituals?: character_ritualsUncheckedUpdateManyWithoutCharactersNestedInput
    character_skills?: character_skillsUncheckedUpdateManyWithoutCharactersNestedInput
    character_specialties?: character_specialtiesUncheckedUpdateManyWithoutCharactersNestedInput
    character_willpowers?: character_willpowersUncheckedUpdateManyWithoutCharactersNestedInput
    exp_logs?: exp_logsUncheckedUpdateManyWithoutCharactersNestedInput
  }

  export type charactersUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    clan_id?: NullableStringFieldUpdateOperationsInput | string | null
    clan_bane?: NullableStringFieldUpdateOperationsInput | string | null
    clan_compulsion?: NullableStringFieldUpdateOperationsInput | string | null
    sect_id?: NullableStringFieldUpdateOperationsInput | string | null
    player?: StringFieldUpdateOperationsInput | string
    predator_type?: StringFieldUpdateOperationsInput | string
    generation?: IntFieldUpdateOperationsInput | number
    chronicle_id?: NullableStringFieldUpdateOperationsInput | string | null
    custom_chronicle?: NullableStringFieldUpdateOperationsInput | string | null
    ambition?: StringFieldUpdateOperationsInput | string
    desire?: StringFieldUpdateOperationsInput | string
    sire?: StringFieldUpdateOperationsInput | string
    total_experience?: IntFieldUpdateOperationsInput | number
    chronicle_tenets?: StringFieldUpdateOperationsInput | string
    group_id?: StringFieldUpdateOperationsInput | string
    type?: EnumEntityFieldUpdateOperationsInput | $Enums.Entity
  }

  export type chroniclesUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    characters?: charactersUpdateManyWithoutChroniclesNestedInput
  }

  export type chroniclesUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    characters?: charactersUncheckedUpdateManyWithoutChroniclesNestedInput
  }

  export type chroniclesUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type exp_logsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    prev_level?: NullableIntFieldUpdateOperationsInput | number | null
    new_level?: NullableIntFieldUpdateOperationsInput | number | null
    expanditure?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    characters?: charactersUpdateOneRequiredWithoutExp_logsNestedInput
  }

  export type exp_logsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    prev_level?: NullableIntFieldUpdateOperationsInput | number | null
    new_level?: NullableIntFieldUpdateOperationsInput | number | null
    expanditure?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type exp_logsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    char_id?: StringFieldUpdateOperationsInput | string
    section?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    prev_level?: NullableIntFieldUpdateOperationsInput | number | null
    new_level?: NullableIntFieldUpdateOperationsInput | number | null
    expanditure?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}